/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const G_GINT16_MODIFIER: &[u8; 2] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINT64_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINT64_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3] = b"li\0";
pub const G_GOFFSET_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GOFFSET_FORMAT: &[u8; 3] = b"li\0";
pub const G_POLLFD_FORMAT: &[u8; 3] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 76;
pub const GLIB_MICRO_VERSION: u32 = 6;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &[u8; 3] = b"so\0";
pub const G_PID_FORMAT: &[u8; 2] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2] = b":\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_STR_DELIMITERS: &[u8; 8] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11] = b"0123456789\0";
pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ;
pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const GST_PADDING: u32 = 4;
pub const GST_PADDING_LARGE: u32 = 20;
pub const GST_DISABLE_CAST_CHECKS: u32 = 0;
pub const GST_DISABLE_GLIB_ASSERTS: u32 = 0;
pub const GST_DISABLE_GLIB_CHECKS: u32 = 0;
pub const GST_HAVE_UNALIGNED_ACCESS: u32 = 1;
pub const GST_VERSION_MAJOR: u32 = 1;
pub const GST_VERSION_MINOR: u32 = 20;
pub const GST_VERSION_MICRO: u32 = 3;
pub const GST_VERSION_NANO: u32 = 0;
pub const GST_TIME_FORMAT: &[u8; 17] = b"u:%02u:%02u.%09u\0";
pub const GST_STIME_FORMAT: &[u8; 19] = b"c%u:%02u:%02u.%09u\0";
pub const GST_ALLOCATOR_SYSMEM: &[u8; 13] = b"SystemMemory\0";
pub const GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: &[u8; 20] = b"memory:SystemMemory\0";
pub const GST_META_TAG_MEMORY_STR: &[u8; 7] = b"memory\0";
pub const GST_EVENT_NUM_SHIFT: u32 = 8;
pub const GST_TAG_TITLE: &[u8; 6] = b"title\0";
pub const GST_TAG_TITLE_SORTNAME: &[u8; 15] = b"title-sortname\0";
pub const GST_TAG_ARTIST: &[u8; 7] = b"artist\0";
pub const GST_TAG_ARTIST_SORTNAME: &[u8; 16] = b"artist-sortname\0";
pub const GST_TAG_ALBUM: &[u8; 6] = b"album\0";
pub const GST_TAG_ALBUM_SORTNAME: &[u8; 15] = b"album-sortname\0";
pub const GST_TAG_ALBUM_ARTIST: &[u8; 13] = b"album-artist\0";
pub const GST_TAG_ALBUM_ARTIST_SORTNAME: &[u8; 22] = b"album-artist-sortname\0";
pub const GST_TAG_COMPOSER: &[u8; 9] = b"composer\0";
pub const GST_TAG_CONDUCTOR: &[u8; 10] = b"conductor\0";
pub const GST_TAG_DATE: &[u8; 5] = b"date\0";
pub const GST_TAG_DATE_TIME: &[u8; 9] = b"datetime\0";
pub const GST_TAG_GENRE: &[u8; 6] = b"genre\0";
pub const GST_TAG_COMMENT: &[u8; 8] = b"comment\0";
pub const GST_TAG_EXTENDED_COMMENT: &[u8; 17] = b"extended-comment\0";
pub const GST_TAG_TRACK_NUMBER: &[u8; 13] = b"track-number\0";
pub const GST_TAG_TRACK_COUNT: &[u8; 12] = b"track-count\0";
pub const GST_TAG_ALBUM_VOLUME_NUMBER: &[u8; 18] = b"album-disc-number\0";
pub const GST_TAG_ALBUM_VOLUME_COUNT: &[u8; 17] = b"album-disc-count\0";
pub const GST_TAG_LOCATION: &[u8; 9] = b"location\0";
pub const GST_TAG_HOMEPAGE: &[u8; 9] = b"homepage\0";
pub const GST_TAG_DESCRIPTION: &[u8; 12] = b"description\0";
pub const GST_TAG_VERSION: &[u8; 8] = b"version\0";
pub const GST_TAG_ISRC: &[u8; 5] = b"isrc\0";
pub const GST_TAG_ORGANIZATION: &[u8; 13] = b"organization\0";
pub const GST_TAG_COPYRIGHT: &[u8; 10] = b"copyright\0";
pub const GST_TAG_COPYRIGHT_URI: &[u8; 14] = b"copyright-uri\0";
pub const GST_TAG_ENCODED_BY: &[u8; 11] = b"encoded-by\0";
pub const GST_TAG_CONTACT: &[u8; 8] = b"contact\0";
pub const GST_TAG_LICENSE: &[u8; 8] = b"license\0";
pub const GST_TAG_LICENSE_URI: &[u8; 12] = b"license-uri\0";
pub const GST_TAG_PERFORMER: &[u8; 10] = b"performer\0";
pub const GST_TAG_DURATION: &[u8; 9] = b"duration\0";
pub const GST_TAG_CODEC: &[u8; 6] = b"codec\0";
pub const GST_TAG_VIDEO_CODEC: &[u8; 12] = b"video-codec\0";
pub const GST_TAG_AUDIO_CODEC: &[u8; 12] = b"audio-codec\0";
pub const GST_TAG_SUBTITLE_CODEC: &[u8; 15] = b"subtitle-codec\0";
pub const GST_TAG_CONTAINER_FORMAT: &[u8; 17] = b"container-format\0";
pub const GST_TAG_BITRATE: &[u8; 8] = b"bitrate\0";
pub const GST_TAG_NOMINAL_BITRATE: &[u8; 16] = b"nominal-bitrate\0";
pub const GST_TAG_MINIMUM_BITRATE: &[u8; 16] = b"minimum-bitrate\0";
pub const GST_TAG_MAXIMUM_BITRATE: &[u8; 16] = b"maximum-bitrate\0";
pub const GST_TAG_SERIAL: &[u8; 7] = b"serial\0";
pub const GST_TAG_ENCODER: &[u8; 8] = b"encoder\0";
pub const GST_TAG_ENCODER_VERSION: &[u8; 16] = b"encoder-version\0";
pub const GST_TAG_TRACK_GAIN: &[u8; 22] = b"replaygain-track-gain\0";
pub const GST_TAG_TRACK_PEAK: &[u8; 22] = b"replaygain-track-peak\0";
pub const GST_TAG_ALBUM_GAIN: &[u8; 22] = b"replaygain-album-gain\0";
pub const GST_TAG_ALBUM_PEAK: &[u8; 22] = b"replaygain-album-peak\0";
pub const GST_TAG_REFERENCE_LEVEL: &[u8; 27] = b"replaygain-reference-level\0";
pub const GST_TAG_LANGUAGE_CODE: &[u8; 14] = b"language-code\0";
pub const GST_TAG_LANGUAGE_NAME: &[u8; 14] = b"language-name\0";
pub const GST_TAG_IMAGE: &[u8; 6] = b"image\0";
pub const GST_TAG_PREVIEW_IMAGE: &[u8; 14] = b"preview-image\0";
pub const GST_TAG_ATTACHMENT: &[u8; 11] = b"attachment\0";
pub const GST_TAG_BEATS_PER_MINUTE: &[u8; 17] = b"beats-per-minute\0";
pub const GST_TAG_KEYWORDS: &[u8; 9] = b"keywords\0";
pub const GST_TAG_GEO_LOCATION_NAME: &[u8; 18] = b"geo-location-name\0";
pub const GST_TAG_GEO_LOCATION_LATITUDE: &[u8; 22] = b"geo-location-latitude\0";
pub const GST_TAG_GEO_LOCATION_LONGITUDE: &[u8; 23] = b"geo-location-longitude\0";
pub const GST_TAG_GEO_LOCATION_ELEVATION: &[u8; 23] = b"geo-location-elevation\0";
pub const GST_TAG_GEO_LOCATION_COUNTRY: &[u8; 21] = b"geo-location-country\0";
pub const GST_TAG_GEO_LOCATION_CITY: &[u8; 18] = b"geo-location-city\0";
pub const GST_TAG_GEO_LOCATION_SUBLOCATION: &[u8; 25] = b"geo-location-sublocation\0";
pub const GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR: &[u8; 30] = b"geo-location-horizontal-error\0";
pub const GST_TAG_GEO_LOCATION_MOVEMENT_SPEED: &[u8; 28] = b"geo-location-movement-speed\0";
pub const GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION: &[u8; 32] = b"geo-location-movement-direction\0";
pub const GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION: &[u8; 31] = b"geo-location-capture-direction\0";
pub const GST_TAG_SHOW_NAME: &[u8; 10] = b"show-name\0";
pub const GST_TAG_SHOW_SORTNAME: &[u8; 14] = b"show-sortname\0";
pub const GST_TAG_SHOW_EPISODE_NUMBER: &[u8; 20] = b"show-episode-number\0";
pub const GST_TAG_SHOW_SEASON_NUMBER: &[u8; 19] = b"show-season-number\0";
pub const GST_TAG_LYRICS: &[u8; 7] = b"lyrics\0";
pub const GST_TAG_COMPOSER_SORTNAME: &[u8; 18] = b"composer-sortname\0";
pub const GST_TAG_GROUPING: &[u8; 9] = b"grouping\0";
pub const GST_TAG_USER_RATING: &[u8; 12] = b"user-rating\0";
pub const GST_TAG_DEVICE_MANUFACTURER: &[u8; 20] = b"device-manufacturer\0";
pub const GST_TAG_DEVICE_MODEL: &[u8; 13] = b"device-model\0";
pub const GST_TAG_APPLICATION_NAME: &[u8; 17] = b"application-name\0";
pub const GST_TAG_APPLICATION_DATA: &[u8; 17] = b"application-data\0";
pub const GST_TAG_IMAGE_ORIENTATION: &[u8; 18] = b"image-orientation\0";
pub const GST_TAG_PUBLISHER: &[u8; 10] = b"publisher\0";
pub const GST_TAG_INTERPRETED_BY: &[u8; 15] = b"interpreted-by\0";
pub const GST_TAG_MIDI_BASE_NOTE: &[u8; 15] = b"midi-base-note\0";
pub const GST_TAG_PRIVATE_DATA: &[u8; 13] = b"private-data\0";
pub const GST_QUERY_NUM_SHIFT: u32 = 8;
pub const GST_TOC_REPEAT_COUNT_INFINITE: i32 = -1;
pub const GST_CAN_INLINE: u32 = 1;
pub const GST_LICENSE_UNKNOWN: &[u8; 8] = b"unknown\0";
pub const GST_URI_NO_PORT: u32 = 0;
pub const GST_ELEMENT_FACTORY_KLASS_DECODER: &[u8; 8] = b"Decoder\0";
pub const GST_ELEMENT_FACTORY_KLASS_ENCODER: &[u8; 8] = b"Encoder\0";
pub const GST_ELEMENT_FACTORY_KLASS_SINK: &[u8; 5] = b"Sink\0";
pub const GST_ELEMENT_FACTORY_KLASS_SRC: &[u8; 7] = b"Source\0";
pub const GST_ELEMENT_FACTORY_KLASS_MUXER: &[u8; 6] = b"Muxer\0";
pub const GST_ELEMENT_FACTORY_KLASS_DEMUXER: &[u8; 8] = b"Demuxer\0";
pub const GST_ELEMENT_FACTORY_KLASS_PARSER: &[u8; 7] = b"Parser\0";
pub const GST_ELEMENT_FACTORY_KLASS_PAYLOADER: &[u8; 10] = b"Payloader\0";
pub const GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER: &[u8; 12] = b"Depayloader\0";
pub const GST_ELEMENT_FACTORY_KLASS_FORMATTER: &[u8; 10] = b"Formatter\0";
pub const GST_ELEMENT_FACTORY_KLASS_DECRYPTOR: &[u8; 10] = b"Decryptor\0";
pub const GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR: &[u8; 10] = b"Encryptor\0";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: &[u8; 6] = b"Video\0";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: &[u8; 6] = b"Audio\0";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: &[u8; 6] = b"Image\0";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: &[u8; 9] = b"Subtitle\0";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA: &[u8; 9] = b"Metadata\0";
pub const GST_ELEMENT_FACTORY_KLASS_HARDWARE: &[u8; 9] = b"Hardware\0";
pub const GST_ELEMENT_METADATA_LONGNAME: &[u8; 10] = b"long-name\0";
pub const GST_ELEMENT_METADATA_KLASS: &[u8; 6] = b"klass\0";
pub const GST_ELEMENT_METADATA_DESCRIPTION: &[u8; 12] = b"description\0";
pub const GST_ELEMENT_METADATA_AUTHOR: &[u8; 7] = b"author\0";
pub const GST_ELEMENT_METADATA_DOC_URI: &[u8; 8] = b"doc-uri\0";
pub const GST_ELEMENT_METADATA_ICON_NAME: &[u8; 10] = b"icon-name\0";
pub const GST_DEBUG_FG_MASK: u32 = 15;
pub const GST_DEBUG_BG_MASK: u32 = 240;
pub const GST_DEBUG_FORMAT_MASK: u32 = 65280;
pub const GST_PTR_FORMAT: &[u8; 4] = b"p\x07A\0";
pub const GST_SEGMENT_FORMAT: &[u8; 4] = b"p\x07B\0";
pub const GST_TIMEP_FORMAT: &[u8; 4] = b"p\x07T\0";
pub const GST_STIMEP_FORMAT: &[u8; 4] = b"p\x07S\0";
pub const GST_FOURCC_FORMAT: &[u8; 8] = b"c%c%c%c\0";
pub const GST_VALUE_LESS_THAN: i32 = -1;
pub const GST_VALUE_EQUAL: u32 = 0;
pub const GST_VALUE_GREATER_THAN: u32 = 1;
pub const GST_VALUE_UNORDERED: u32 = 2;
pub const GST_PARAM_CONTROLLABLE: u32 = 512;
pub const GST_PARAM_MUTABLE_READY: u32 = 1024;
pub const GST_PARAM_MUTABLE_PAUSED: u32 = 2048;
pub const GST_PARAM_MUTABLE_PLAYING: u32 = 4096;
pub const GST_PARAM_DOC_SHOW_DEFAULT: u32 = 8192;
pub const GST_PARAM_CONDITIONALLY_AVAILABLE: u32 = 16384;
pub const GST_PARAM_USER_SHIFT: u32 = 65536;
pub const GST_PROTECTION_SYSTEM_ID_CAPS_FIELD: &[u8; 18] = b"protection-system\0";
pub const GST_PROTECTION_UNSPECIFIED_SYSTEM_ID: &[u8; 22] = b"unspecified-system-id\0";
pub const GST_SEQNUM_INVALID: u32 = 0;
pub const GST_GROUP_ID_INVALID: u32 = 0;
pub const GST_VIDEO_TILE_TYPE_SHIFT: u32 = 16;
pub const GST_VIDEO_TILE_TYPE_MASK: u32 = 65535;
pub const GST_VIDEO_TILE_Y_TILES_SHIFT: u32 = 16;
pub const GST_VIDEO_TILE_X_TILES_MASK: u32 = 65535;
pub const GST_VIDEO_MAX_PLANES: u32 = 4;
pub const GST_VIDEO_MAX_COMPONENTS: u32 = 4;
pub const GST_VIDEO_COMP_Y: u32 = 0;
pub const GST_VIDEO_COMP_U: u32 = 1;
pub const GST_VIDEO_COMP_V: u32 = 2;
pub const GST_VIDEO_COMP_R: u32 = 0;
pub const GST_VIDEO_COMP_G: u32 = 1;
pub const GST_VIDEO_COMP_B: u32 = 2;
pub const GST_VIDEO_COMP_A: u32 = 3;
pub const GST_VIDEO_COMP_INDEX: u32 = 0;
pub const GST_VIDEO_COMP_PALETTE: u32 = 1;
pub const GST_VIDEO_SIZE_RANGE: &[u8; 17] = b"(int) [ 1, max ]\0";
pub const GST_VIDEO_FPS_RANGE: &[u8; 22] = b"(fraction) [ 0, max ]\0";
pub const GST_VIDEO_FORMATS_ALL : & [u8 ; 934] = b"{ ABGR64_LE, BGRA64_LE, AYUV64, ARGB64_LE, ARGB64, RGBA64_LE, ABGR64_BE, BGRA64_BE, ARGB64_BE, RGBA64_BE, GBRA_12LE, GBRA_12BE, Y412_LE, Y412_BE, A444_10LE, GBRA_10LE, A444_10BE, GBRA_10BE, A422_10LE, A422_10BE, A420_10LE, A420_10BE, RGB10A2_LE, BGR10A2_LE, Y410, GBRA, ABGR, VUYA, BGRA, AYUV, ARGB, RGBA, A420, AV12, Y444_16LE, Y444_16BE, v216, P016_LE, P016_BE, Y444_12LE, GBR_12LE, Y444_12BE, GBR_12BE, I422_12LE, I422_12BE, Y212_LE, Y212_BE, I420_12LE, I420_12BE, P012_LE, P012_BE, Y444_10LE, GBR_10LE, Y444_10BE, GBR_10BE, r210, I422_10LE, I422_10BE, NV16_10LE32, Y210, v210, UYVP, I420_10LE, I420_10BE, P010_10LE, NV12_10LE32, NV12_10LE40, P010_10BE, Y444, RGBP, GBR, BGRP, NV24, xBGR, BGRx, xRGB, RGBx, BGR, IYU2, v308, RGB, Y42B, NV61, NV16, VYUY, UYVY, YVYU, YUY2, I420, YV12, NV21, NV12, NV12_64Z32, NV12_4L4, NV12_32L32, Y41B, IYU1, YVU9, YUV9, RGB16, BGR16, RGB15, BGR15, RGB8P, GRAY16_LE, GRAY16_BE, GRAY10_LE32, GRAY8 }\0" ;
pub const GST_VIDEO_COLORIMETRY_BT601: &[u8; 6] = b"bt601\0";
pub const GST_VIDEO_COLORIMETRY_BT709: &[u8; 6] = b"bt709\0";
pub const GST_VIDEO_COLORIMETRY_SMPTE240M: &[u8; 10] = b"smpte240m\0";
pub const GST_VIDEO_COLORIMETRY_SRGB: &[u8; 5] = b"sRGB\0";
pub const GST_VIDEO_COLORIMETRY_BT2020: &[u8; 7] = b"bt2020\0";
pub const GST_VIDEO_COLORIMETRY_BT2020_10: &[u8; 10] = b"bt2020-10\0";
pub const GST_VIDEO_COLORIMETRY_BT2100_PQ: &[u8; 10] = b"bt2100-pq\0";
pub const GST_VIDEO_COLORIMETRY_BT2100_HLG: &[u8; 11] = b"bt2100-hlg\0";
pub const GST_CAPS_FEATURE_FORMAT_INTERLACED: &[u8; 18] = b"format:Interlaced\0";
pub const GST_VIDEO_CONVERTER_OPT_RESAMPLER_METHOD: &[u8; 35] =
    b"GstVideoConverter.resampler-method\0";
pub const GST_VIDEO_CONVERTER_OPT_CHROMA_RESAMPLER_METHOD: &[u8; 42] =
    b"GstVideoConverter.chroma-resampler-method\0";
pub const GST_VIDEO_CONVERTER_OPT_RESAMPLER_TAPS: &[u8; 33] = b"GstVideoConverter.resampler-taps\0";
pub const GST_VIDEO_CONVERTER_OPT_DITHER_METHOD: &[u8; 32] = b"GstVideoConverter.dither-method\0";
pub const GST_VIDEO_CONVERTER_OPT_DITHER_QUANTIZATION: &[u8; 38] =
    b"GstVideoConverter.dither-quantization\0";
pub const GST_VIDEO_CONVERTER_OPT_SRC_X: &[u8; 24] = b"GstVideoConverter.src-x\0";
pub const GST_VIDEO_CONVERTER_OPT_SRC_Y: &[u8; 24] = b"GstVideoConverter.src-y\0";
pub const GST_VIDEO_CONVERTER_OPT_SRC_WIDTH: &[u8; 28] = b"GstVideoConverter.src-width\0";
pub const GST_VIDEO_CONVERTER_OPT_SRC_HEIGHT: &[u8; 29] = b"GstVideoConverter.src-height\0";
pub const GST_VIDEO_CONVERTER_OPT_DEST_X: &[u8; 25] = b"GstVideoConverter.dest-x\0";
pub const GST_VIDEO_CONVERTER_OPT_DEST_Y: &[u8; 25] = b"GstVideoConverter.dest-y\0";
pub const GST_VIDEO_CONVERTER_OPT_DEST_WIDTH: &[u8; 29] = b"GstVideoConverter.dest-width\0";
pub const GST_VIDEO_CONVERTER_OPT_DEST_HEIGHT: &[u8; 30] = b"GstVideoConverter.dest-height\0";
pub const GST_VIDEO_CONVERTER_OPT_FILL_BORDER: &[u8; 30] = b"GstVideoConverter.fill-border\0";
pub const GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE: &[u8; 30] = b"GstVideoConverter.alpha-value\0";
pub const GST_VIDEO_CONVERTER_OPT_ALPHA_MODE: &[u8; 29] = b"GstVideoConverter.alpha-mode\0";
pub const GST_VIDEO_CONVERTER_OPT_BORDER_ARGB: &[u8; 30] = b"GstVideoConverter.border-argb\0";
pub const GST_VIDEO_CONVERTER_OPT_CHROMA_MODE: &[u8; 30] = b"GstVideoConverter.chroma-mode\0";
pub const GST_VIDEO_CONVERTER_OPT_MATRIX_MODE: &[u8; 30] = b"GstVideoConverter.matrix-mode\0";
pub const GST_VIDEO_CONVERTER_OPT_GAMMA_MODE: &[u8; 29] = b"GstVideoConverter.gamma-mode\0";
pub const GST_VIDEO_CONVERTER_OPT_PRIMARIES_MODE: &[u8; 33] = b"GstVideoConverter.primaries-mode\0";
pub const GST_VIDEO_CONVERTER_OPT_THREADS: &[u8; 26] = b"GstVideoConverter.threads\0";
pub const GST_VIDEO_CONVERTER_OPT_ASYNC_TASKS: &[u8; 30] = b"GstVideoConverter.async-tasks\0";
pub const GST_VIDEO_RESAMPLER_OPT_CUBIC_B: &[u8; 26] = b"GstVideoResampler.cubic-b\0";
pub const GST_VIDEO_RESAMPLER_OPT_CUBIC_C: &[u8; 26] = b"GstVideoResampler.cubic-c\0";
pub const GST_VIDEO_RESAMPLER_OPT_ENVELOPE: &[u8; 27] = b"GstVideoResampler.envelope\0";
pub const GST_VIDEO_RESAMPLER_OPT_SHARPNESS: &[u8; 28] = b"GstVideoResampler.sharpness\0";
pub const GST_VIDEO_RESAMPLER_OPT_SHARPEN: &[u8; 26] = b"GstVideoResampler.sharpen\0";
pub const GST_VIDEO_RESAMPLER_OPT_MAX_TAPS: &[u8; 27] = b"GstVideoResampler.max-taps\0";
pub const GST_VIDEO_SCALER_OPT_DITHER_METHOD: &[u8; 29] = b"GstVideoScaler.dither-method\0";
pub const GST_META_TAG_VIDEO_STR: &[u8; 6] = b"video\0";
pub const GST_META_TAG_VIDEO_ORIENTATION_STR: &[u8; 12] = b"orientation\0";
pub const GST_META_TAG_VIDEO_SIZE_STR: &[u8; 5] = b"size\0";
pub const GST_META_TAG_VIDEO_COLORSPACE_STR: &[u8; 11] = b"colorspace\0";
pub const GST_CAPS_FEATURE_META_GST_VIDEO_AFFINE_TRANSFORMATION_META: &[u8; 34] =
    b"meta:GstVideoAffineTransformation\0";
pub const GST_BUFFER_POOL_OPTION_VIDEO_AFFINE_TRANSFORMATION_META: &[u8; 45] =
    b"GstBufferPoolOptionVideoAffineTransformation\0";
pub const GST_VIDEO_DECODER_SINK_NAME: &[u8; 5] = b"sink\0";
pub const GST_VIDEO_DECODER_SRC_NAME: &[u8; 4] = b"src\0";
pub const GST_VIDEO_DECODER_MAX_ERRORS: u32 = 10;
pub const GST_VIDEO_ENCODER_SINK_NAME: &[u8; 5] = b"sink\0";
pub const GST_VIDEO_ENCODER_SRC_NAME: &[u8; 4] = b"src\0";
pub const GST_BASE_TRANSFORM_SINK_NAME: &[u8; 5] = b"sink\0";
pub const GST_BASE_TRANSFORM_SRC_NAME: &[u8; 4] = b"src\0";
pub const GST_CAPS_FEATURE_META_GST_VIDEO_META: &[u8; 18] = b"meta:GstVideoMeta\0";
pub const GST_CAPS_FEATURE_META_GST_VIDEO_GL_TEXTURE_UPLOAD_META: &[u8; 33] =
    b"meta:GstVideoGLTextureUploadMeta\0";
pub const GST_BUFFER_POOL_OPTION_VIDEO_GL_TEXTURE_UPLOAD_META: &[u8; 44] =
    b"GstBufferPoolOptionVideoGLTextureUploadMeta\0";
pub const GST_BUFFER_POOL_OPTION_VIDEO_META: &[u8; 29] = b"GstBufferPoolOptionVideoMeta\0";
pub const GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT: &[u8; 34] =
    b"GstBufferPoolOptionVideoAlignment\0";
pub const GST_CAPS_FEATURE_META_GST_VIDEO_OVERLAY_COMPOSITION: &[u8; 32] =
    b"meta:GstVideoOverlayComposition\0";
pub const GST_VIDEO_OVERLAY_COMPOSITION_BLEND_FORMATS : & [u8 ; 934] = b"{ ABGR64_LE, BGRA64_LE, AYUV64, ARGB64_LE, ARGB64, RGBA64_LE, ABGR64_BE, BGRA64_BE, ARGB64_BE, RGBA64_BE, GBRA_12LE, GBRA_12BE, Y412_LE, Y412_BE, A444_10LE, GBRA_10LE, A444_10BE, GBRA_10BE, A422_10LE, A422_10BE, A420_10LE, A420_10BE, RGB10A2_LE, BGR10A2_LE, Y410, GBRA, ABGR, VUYA, BGRA, AYUV, ARGB, RGBA, A420, AV12, Y444_16LE, Y444_16BE, v216, P016_LE, P016_BE, Y444_12LE, GBR_12LE, Y444_12BE, GBR_12BE, I422_12LE, I422_12BE, Y212_LE, Y212_BE, I420_12LE, I420_12BE, P012_LE, P012_BE, Y444_10LE, GBR_10LE, Y444_10BE, GBR_10BE, r210, I422_10LE, I422_10BE, NV16_10LE32, Y210, v210, UYVP, I420_10LE, I420_10BE, P010_10LE, NV12_10LE32, NV12_10LE40, P010_10BE, Y444, RGBP, GBR, BGRP, NV24, xBGR, BGRx, xRGB, RGBx, BGR, IYU2, v308, RGB, Y42B, NV61, NV16, VYUY, UYVY, YVYU, YUY2, I420, YV12, NV21, NV12, NV12_64Z32, NV12_4L4, NV12_32L32, Y41B, IYU1, YVU9, YUV9, RGB16, BGR16, RGB15, BGR15, RGB8P, GRAY16_LE, GRAY16_BE, GRAY10_LE32, GRAY8 }\0" ;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const DS_MAX_POLYGON_POINTS: u32 = 8;
pub const MAX_USER_FIELDS: u32 = 4;
pub const MAX_RESERVED_FIELDS: u32 = 4;
pub const MAX_LABEL_SIZE: u32 = 128;
pub const MAX_ELEMENTS_IN_DISPLAY_META: u32 = 16;
pub const UNTRACKED_OBJECT_ID: i32 = -1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RESERVED_BYTES: u32 = 16;
pub const MAX_COMPONENT_LEN: u32 = 64;
pub const NVDS_META_STRING: &[u8; 9] = b"nvdsmeta\0";
pub const NVDSINFER_MAX_DIMS: u32 = 8;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
#[doc = " GEqualFuncFull:\n @a: a value\n @b: a value to compare with\n @user_data: user data provided by the caller\n\n Specifies the type of a function used to test two values for\n equality. The function should return %TRUE if both values are equal\n and %FALSE otherwise.\n\n This is a version of #GEqualFunc which provides a @user_data closure from\n the caller.\n\n Returns: %TRUE if @a = @b; %FALSE otherwise\n Since: 2.74"]
pub type GEqualFuncFull = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
    ["Alignment of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754"][::std::mem::size_of::<_GFloatIEEE754>() - 4usize];
    ["Alignment of _GFloatIEEE754"][::std::mem::align_of::<_GFloatIEEE754>() - 4usize];
    ["Offset of field: _GFloatIEEE754::v_float"]
        [::std::mem::offset_of!(_GFloatIEEE754, v_float) - 0usize];
    ["Offset of field: _GFloatIEEE754::mpn"][::std::mem::offset_of!(_GFloatIEEE754, mpn) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>() - 8usize];
    ["Alignment of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_low_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_low_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_high_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_high_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754"][::std::mem::size_of::<_GDoubleIEEE754>() - 8usize];
    ["Alignment of _GDoubleIEEE754"][::std::mem::align_of::<_GDoubleIEEE754>() - 8usize];
    ["Offset of field: _GDoubleIEEE754::v_double"]
        [::std::mem::offset_of!(_GDoubleIEEE754, v_double) - 0usize];
    ["Offset of field: _GDoubleIEEE754::mpn"]
        [::std::mem::offset_of!(_GDoubleIEEE754, mpn) - 0usize];
};
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTimeVal"][::std::mem::size_of::<_GTimeVal>() - 16usize];
    ["Alignment of _GTimeVal"][::std::mem::align_of::<_GTimeVal>() - 8usize];
    ["Offset of field: _GTimeVal::tv_sec"][::std::mem::offset_of!(_GTimeVal, tv_sec) - 0usize];
    ["Offset of field: _GTimeVal::tv_usec"][::std::mem::offset_of!(_GTimeVal, tv_usec) - 8usize];
};
pub type grefcount = gint;
pub type gatomicrefcount = gint;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GArray"][::std::mem::size_of::<_GArray>() - 16usize];
    ["Alignment of _GArray"][::std::mem::align_of::<_GArray>() - 8usize];
    ["Offset of field: _GArray::data"][::std::mem::offset_of!(_GArray, data) - 0usize];
    ["Offset of field: _GArray::len"][::std::mem::offset_of!(_GArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GByteArray"][::std::mem::size_of::<_GByteArray>() - 16usize];
    ["Alignment of _GByteArray"][::std::mem::align_of::<_GByteArray>() - 8usize];
    ["Offset of field: _GByteArray::data"][::std::mem::offset_of!(_GByteArray, data) - 0usize];
    ["Offset of field: _GByteArray::len"][::std::mem::offset_of!(_GByteArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPtrArray"][::std::mem::size_of::<_GPtrArray>() - 16usize];
    ["Alignment of _GPtrArray"][::std::mem::align_of::<_GPtrArray>() - 8usize];
    ["Offset of field: _GPtrArray::pdata"][::std::mem::offset_of!(_GPtrArray, pdata) - 0usize];
    ["Offset of field: _GPtrArray::len"][::std::mem::offset_of!(_GPtrArray, len) - 8usize];
};
unsafe extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_new_take(
        data: gpointer,
        len: gsize,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
unsafe extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
unsafe extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
    -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: gsize,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: gsize,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
}
unsafe extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
unsafe extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
    -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_exchange(
        atomic: *mut ::std::os::raw::c_void,
        newval: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
unsafe extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GError"][::std::mem::size_of::<_GError>() - 16usize];
    ["Alignment of _GError"][::std::mem::align_of::<_GError>() - 8usize];
    ["Offset of field: _GError::domain"][::std::mem::offset_of!(_GError, domain) - 0usize];
    ["Offset of field: _GError::code"][::std::mem::offset_of!(_GError, code) - 4usize];
    ["Offset of field: _GError::message"][::std::mem::offset_of!(_GError, message) - 8usize];
};
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
unsafe extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_free(error: *mut GError);
}
unsafe extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
unsafe extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
unsafe extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
unsafe extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
unsafe extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugKey"][::std::mem::size_of::<_GDebugKey>() - 16usize];
    ["Alignment of _GDebugKey"][::std::mem::align_of::<_GDebugKey>() - 8usize];
    ["Offset of field: _GDebugKey::key"][::std::mem::offset_of!(_GDebugKey, key) - 0usize];
    ["Offset of field: _GDebugKey::value"][::std::mem::offset_of!(_GDebugKey, value) - 8usize];
};
unsafe extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
unsafe extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMutex"][::std::mem::size_of::<_GMutex>() - 8usize];
    ["Alignment of _GMutex"][::std::mem::align_of::<_GMutex>() - 8usize];
    ["Offset of field: _GMutex::p"][::std::mem::offset_of!(_GMutex, p) - 0usize];
    ["Offset of field: _GMutex::i"][::std::mem::offset_of!(_GMutex, i) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRWLock"][::std::mem::size_of::<_GRWLock>() - 16usize];
    ["Alignment of _GRWLock"][::std::mem::align_of::<_GRWLock>() - 8usize];
    ["Offset of field: _GRWLock::p"][::std::mem::offset_of!(_GRWLock, p) - 0usize];
    ["Offset of field: _GRWLock::i"][::std::mem::offset_of!(_GRWLock, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCond"][::std::mem::size_of::<_GCond>() - 16usize];
    ["Alignment of _GCond"][::std::mem::align_of::<_GCond>() - 8usize];
    ["Offset of field: _GCond::p"][::std::mem::offset_of!(_GCond, p) - 0usize];
    ["Offset of field: _GCond::i"][::std::mem::offset_of!(_GCond, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRecMutex"][::std::mem::size_of::<_GRecMutex>() - 16usize];
    ["Alignment of _GRecMutex"][::std::mem::align_of::<_GRecMutex>() - 8usize];
    ["Offset of field: _GRecMutex::p"][::std::mem::offset_of!(_GRecMutex, p) - 0usize];
    ["Offset of field: _GRecMutex::i"][::std::mem::offset_of!(_GRecMutex, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPrivate"][::std::mem::size_of::<_GPrivate>() - 32usize];
    ["Alignment of _GPrivate"][::std::mem::align_of::<_GPrivate>() - 8usize];
    ["Offset of field: _GPrivate::p"][::std::mem::offset_of!(_GPrivate, p) - 0usize];
    ["Offset of field: _GPrivate::notify"][::std::mem::offset_of!(_GPrivate, notify) - 8usize];
    ["Offset of field: _GPrivate::future"][::std::mem::offset_of!(_GPrivate, future) - 16usize];
};
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOnce"][::std::mem::size_of::<_GOnce>() - 16usize];
    ["Alignment of _GOnce"][::std::mem::align_of::<_GOnce>() - 8usize];
    ["Offset of field: _GOnce::status"][::std::mem::offset_of!(_GOnce, status) - 0usize];
    ["Offset of field: _GOnce::retval"][::std::mem::offset_of!(_GOnce, retval) - 8usize];
};
unsafe extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
unsafe extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
unsafe extern "C" {
    pub fn g_thread_yield();
}
unsafe extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
unsafe extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
unsafe extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
unsafe extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
unsafe extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_uid) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_tid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_overrun) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_status) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_utime) - 16usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_stime) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"]
        [::std::mem::offset_of!(
            siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            _lower
        ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"]
        [::std::mem::offset_of!(
            siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            _upper
        ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _addr_bnd
    ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _pkey
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr_lsb) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, _bounds) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_band) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_fd) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _call_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _syscall) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _arch) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1>() - 112usize];
    ["Alignment of siginfo_t__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_kill"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _kill) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_timer"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _timer) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_rt"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _rt) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigchld) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigfault) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigpoll) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigsys) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 128usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_errno"][::std::mem::offset_of!(siginfo_t, si_errno) - 4usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 8usize];
    ["Offset of field: siginfo_t::__pad0"][::std::mem::offset_of!(siginfo_t, __pad0) - 12usize];
    ["Offset of field: siginfo_t::_sifields"]
        [::std::mem::offset_of!(siginfo_t, _sifields) - 16usize];
};
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_4 = 8;
pub const SEGV_MTESERR: _bindgen_ty_4 = 9;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _function) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _attribute) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1"][::std::mem::size_of::<sigevent__bindgen_ty_1>() - 48usize];
    ["Alignment of sigevent__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_tid"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _tid) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _sigev_thread) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 64usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 12usize];
    ["Offset of field: sigevent::_sigev_un"][::std::mem::offset_of!(sigevent, _sigev_un) - 16usize];
};
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
unsafe extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
    -> __sighandler_t;
}
unsafe extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
unsafe extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction__bindgen_ty_1"][::std::mem::size_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Alignment of sigaction__bindgen_ty_1"]
        [::std::mem::align_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_handler"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_handler) - 0usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_sigaction) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 152usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_handler"]
        [::std::mem::offset_of!(sigaction, __sigaction_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::std::mem::offset_of!(sigaction, sa_flags) - 136usize];
    ["Offset of field: sigaction::sa_restorer"]
        [::std::mem::offset_of!(sigaction, sa_restorer) - 144usize];
};
unsafe extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpx_sw_bytes"][::std::mem::size_of::<_fpx_sw_bytes>() - 48usize];
    ["Alignment of _fpx_sw_bytes"][::std::mem::align_of::<_fpx_sw_bytes>() - 8usize];
    ["Offset of field: _fpx_sw_bytes::magic1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, magic1) - 0usize];
    ["Offset of field: _fpx_sw_bytes::extended_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, extended_size) - 4usize];
    ["Offset of field: _fpx_sw_bytes::xstate_bv"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_bv) - 8usize];
    ["Offset of field: _fpx_sw_bytes::xstate_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_size) - 16usize];
    ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, __glibc_reserved1) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpreg"][::std::mem::size_of::<_fpreg>() - 10usize];
    ["Alignment of _fpreg"][::std::mem::align_of::<_fpreg>() - 2usize];
    ["Offset of field: _fpreg::significand"][::std::mem::offset_of!(_fpreg, significand) - 0usize];
    ["Offset of field: _fpreg::exponent"][::std::mem::offset_of!(_fpreg, exponent) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpxreg"][::std::mem::size_of::<_fpxreg>() - 16usize];
    ["Alignment of _fpxreg"][::std::mem::align_of::<_fpxreg>() - 2usize];
    ["Offset of field: _fpxreg::significand"]
        [::std::mem::offset_of!(_fpxreg, significand) - 0usize];
    ["Offset of field: _fpxreg::exponent"][::std::mem::offset_of!(_fpxreg, exponent) - 8usize];
    ["Offset of field: _fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xmmreg"][::std::mem::size_of::<_xmmreg>() - 16usize];
    ["Alignment of _xmmreg"][::std::mem::align_of::<_xmmreg>() - 4usize];
    ["Offset of field: _xmmreg::element"][::std::mem::offset_of!(_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpstate"][::std::mem::size_of::<_fpstate>() - 512usize];
    ["Alignment of _fpstate"][::std::mem::align_of::<_fpstate>() - 8usize];
    ["Offset of field: _fpstate::cwd"][::std::mem::offset_of!(_fpstate, cwd) - 0usize];
    ["Offset of field: _fpstate::swd"][::std::mem::offset_of!(_fpstate, swd) - 2usize];
    ["Offset of field: _fpstate::ftw"][::std::mem::offset_of!(_fpstate, ftw) - 4usize];
    ["Offset of field: _fpstate::fop"][::std::mem::offset_of!(_fpstate, fop) - 6usize];
    ["Offset of field: _fpstate::rip"][::std::mem::offset_of!(_fpstate, rip) - 8usize];
    ["Offset of field: _fpstate::rdp"][::std::mem::offset_of!(_fpstate, rdp) - 16usize];
    ["Offset of field: _fpstate::mxcsr"][::std::mem::offset_of!(_fpstate, mxcsr) - 24usize];
    ["Offset of field: _fpstate::mxcr_mask"][::std::mem::offset_of!(_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _fpstate::_st"][::std::mem::offset_of!(_fpstate, _st) - 32usize];
    ["Offset of field: _fpstate::_xmm"][::std::mem::offset_of!(_fpstate, _xmm) - 160usize];
    ["Offset of field: _fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpstate, __glibc_reserved1) - 416usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext__bindgen_ty_1"]
        [::std::mem::size_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Alignment of sigcontext__bindgen_ty_1"]
        [::std::mem::align_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigcontext__bindgen_ty_1::fpstate"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, fpstate) - 0usize];
    ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, __fpstate_word) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext"][::std::mem::size_of::<sigcontext>() - 256usize];
    ["Alignment of sigcontext"][::std::mem::align_of::<sigcontext>() - 8usize];
    ["Offset of field: sigcontext::r8"][::std::mem::offset_of!(sigcontext, r8) - 0usize];
    ["Offset of field: sigcontext::r9"][::std::mem::offset_of!(sigcontext, r9) - 8usize];
    ["Offset of field: sigcontext::r10"][::std::mem::offset_of!(sigcontext, r10) - 16usize];
    ["Offset of field: sigcontext::r11"][::std::mem::offset_of!(sigcontext, r11) - 24usize];
    ["Offset of field: sigcontext::r12"][::std::mem::offset_of!(sigcontext, r12) - 32usize];
    ["Offset of field: sigcontext::r13"][::std::mem::offset_of!(sigcontext, r13) - 40usize];
    ["Offset of field: sigcontext::r14"][::std::mem::offset_of!(sigcontext, r14) - 48usize];
    ["Offset of field: sigcontext::r15"][::std::mem::offset_of!(sigcontext, r15) - 56usize];
    ["Offset of field: sigcontext::rdi"][::std::mem::offset_of!(sigcontext, rdi) - 64usize];
    ["Offset of field: sigcontext::rsi"][::std::mem::offset_of!(sigcontext, rsi) - 72usize];
    ["Offset of field: sigcontext::rbp"][::std::mem::offset_of!(sigcontext, rbp) - 80usize];
    ["Offset of field: sigcontext::rbx"][::std::mem::offset_of!(sigcontext, rbx) - 88usize];
    ["Offset of field: sigcontext::rdx"][::std::mem::offset_of!(sigcontext, rdx) - 96usize];
    ["Offset of field: sigcontext::rax"][::std::mem::offset_of!(sigcontext, rax) - 104usize];
    ["Offset of field: sigcontext::rcx"][::std::mem::offset_of!(sigcontext, rcx) - 112usize];
    ["Offset of field: sigcontext::rsp"][::std::mem::offset_of!(sigcontext, rsp) - 120usize];
    ["Offset of field: sigcontext::rip"][::std::mem::offset_of!(sigcontext, rip) - 128usize];
    ["Offset of field: sigcontext::eflags"][::std::mem::offset_of!(sigcontext, eflags) - 136usize];
    ["Offset of field: sigcontext::cs"][::std::mem::offset_of!(sigcontext, cs) - 144usize];
    ["Offset of field: sigcontext::gs"][::std::mem::offset_of!(sigcontext, gs) - 146usize];
    ["Offset of field: sigcontext::fs"][::std::mem::offset_of!(sigcontext, fs) - 148usize];
    ["Offset of field: sigcontext::__pad0"][::std::mem::offset_of!(sigcontext, __pad0) - 150usize];
    ["Offset of field: sigcontext::err"][::std::mem::offset_of!(sigcontext, err) - 152usize];
    ["Offset of field: sigcontext::trapno"][::std::mem::offset_of!(sigcontext, trapno) - 160usize];
    ["Offset of field: sigcontext::oldmask"]
        [::std::mem::offset_of!(sigcontext, oldmask) - 168usize];
    ["Offset of field: sigcontext::cr2"][::std::mem::offset_of!(sigcontext, cr2) - 176usize];
    ["Offset of field: sigcontext::__reserved1"]
        [::std::mem::offset_of!(sigcontext, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xsave_hdr"][::std::mem::size_of::<_xsave_hdr>() - 64usize];
    ["Alignment of _xsave_hdr"][::std::mem::align_of::<_xsave_hdr>() - 8usize];
    ["Offset of field: _xsave_hdr::xstate_bv"]
        [::std::mem::offset_of!(_xsave_hdr, xstate_bv) - 0usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved1"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved1) - 8usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved2"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved2) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ymmh_state"][::std::mem::size_of::<_ymmh_state>() - 256usize];
    ["Alignment of _ymmh_state"][::std::mem::align_of::<_ymmh_state>() - 4usize];
    ["Offset of field: _ymmh_state::ymmh_space"]
        [::std::mem::offset_of!(_ymmh_state, ymmh_space) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xstate"][::std::mem::size_of::<_xstate>() - 832usize];
    ["Alignment of _xstate"][::std::mem::align_of::<_xstate>() - 8usize];
    ["Offset of field: _xstate::fpstate"][::std::mem::offset_of!(_xstate, fpstate) - 0usize];
    ["Offset of field: _xstate::xstate_hdr"]
        [::std::mem::offset_of!(_xstate, xstate_hdr) - 512usize];
    ["Offset of field: _xstate::ymmh"][::std::mem::offset_of!(_xstate, ymmh) - 576usize];
};
unsafe extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stack_t"][::std::mem::size_of::<stack_t>() - 24usize];
    ["Alignment of stack_t"][::std::mem::align_of::<stack_t>() - 8usize];
    ["Offset of field: stack_t::ss_sp"][::std::mem::offset_of!(stack_t, ss_sp) - 0usize];
    ["Offset of field: stack_t::ss_flags"][::std::mem::offset_of!(stack_t, ss_flags) - 8usize];
    ["Offset of field: stack_t::ss_size"][::std::mem::offset_of!(stack_t, ss_size) - 16usize];
};
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpxreg"][::std::mem::size_of::<_libc_fpxreg>() - 16usize];
    ["Alignment of _libc_fpxreg"][::std::mem::align_of::<_libc_fpxreg>() - 2usize];
    ["Offset of field: _libc_fpxreg::significand"]
        [::std::mem::offset_of!(_libc_fpxreg, significand) - 0usize];
    ["Offset of field: _libc_fpxreg::exponent"]
        [::std::mem::offset_of!(_libc_fpxreg, exponent) - 8usize];
    ["Offset of field: _libc_fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_xmmreg"][::std::mem::size_of::<_libc_xmmreg>() - 16usize];
    ["Alignment of _libc_xmmreg"][::std::mem::align_of::<_libc_xmmreg>() - 4usize];
    ["Offset of field: _libc_xmmreg::element"]
        [::std::mem::offset_of!(_libc_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpstate"][::std::mem::size_of::<_libc_fpstate>() - 512usize];
    ["Alignment of _libc_fpstate"][::std::mem::align_of::<_libc_fpstate>() - 8usize];
    ["Offset of field: _libc_fpstate::cwd"][::std::mem::offset_of!(_libc_fpstate, cwd) - 0usize];
    ["Offset of field: _libc_fpstate::swd"][::std::mem::offset_of!(_libc_fpstate, swd) - 2usize];
    ["Offset of field: _libc_fpstate::ftw"][::std::mem::offset_of!(_libc_fpstate, ftw) - 4usize];
    ["Offset of field: _libc_fpstate::fop"][::std::mem::offset_of!(_libc_fpstate, fop) - 6usize];
    ["Offset of field: _libc_fpstate::rip"][::std::mem::offset_of!(_libc_fpstate, rip) - 8usize];
    ["Offset of field: _libc_fpstate::rdp"][::std::mem::offset_of!(_libc_fpstate, rdp) - 16usize];
    ["Offset of field: _libc_fpstate::mxcsr"]
        [::std::mem::offset_of!(_libc_fpstate, mxcsr) - 24usize];
    ["Offset of field: _libc_fpstate::mxcr_mask"]
        [::std::mem::offset_of!(_libc_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _libc_fpstate::_st"][::std::mem::offset_of!(_libc_fpstate, _st) - 32usize];
    ["Offset of field: _libc_fpstate::_xmm"]
        [::std::mem::offset_of!(_libc_fpstate, _xmm) - 160usize];
    ["Offset of field: _libc_fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpstate, __glibc_reserved1) - 416usize];
};
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mcontext_t"][::std::mem::size_of::<mcontext_t>() - 256usize];
    ["Alignment of mcontext_t"][::std::mem::align_of::<mcontext_t>() - 8usize];
    ["Offset of field: mcontext_t::gregs"][::std::mem::offset_of!(mcontext_t, gregs) - 0usize];
    ["Offset of field: mcontext_t::fpregs"][::std::mem::offset_of!(mcontext_t, fpregs) - 184usize];
    ["Offset of field: mcontext_t::__reserved1"]
        [::std::mem::offset_of!(mcontext_t, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucontext_t"][::std::mem::size_of::<ucontext_t>() - 968usize];
    ["Alignment of ucontext_t"][::std::mem::align_of::<ucontext_t>() - 8usize];
    ["Offset of field: ucontext_t::uc_flags"]
        [::std::mem::offset_of!(ucontext_t, uc_flags) - 0usize];
    ["Offset of field: ucontext_t::uc_link"][::std::mem::offset_of!(ucontext_t, uc_link) - 8usize];
    ["Offset of field: ucontext_t::uc_stack"]
        [::std::mem::offset_of!(ucontext_t, uc_stack) - 16usize];
    ["Offset of field: ucontext_t::uc_mcontext"]
        [::std::mem::offset_of!(ucontext_t, uc_mcontext) - 40usize];
    ["Offset of field: ucontext_t::uc_sigmask"]
        [::std::mem::offset_of!(ucontext_t, uc_sigmask) - 296usize];
    ["Offset of field: ucontext_t::__fpregs_mem"]
        [::std::mem::offset_of!(ucontext_t, __fpregs_mem) - 424usize];
    ["Offset of field: ucontext_t::__ssp"][::std::mem::offset_of!(ucontext_t, __ssp) - 936usize];
};
unsafe extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
unsafe extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
unsafe extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n An opaque structure that represents a date and time, including a time zone.\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
unsafe extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n An opaque data structure representing a set of bookmarks."]
pub type GBookmarkFile = _GBookmarkFile;
unsafe extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
unsafe extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
unsafe extern "C" {
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
unsafe extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:\n\n An opaque structure representing a checksumming operation.\n\n To create a new GChecksum, use g_checksum_new(). To free\n a GChecksum, use g_checksum_free().\n\n Since: 2.16"]
pub type GChecksum = _GChecksum;
unsafe extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
unsafe extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
unsafe extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
unsafe extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
unsafe extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
unsafe extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
unsafe extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
unsafe extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDate"][::std::mem::size_of::<_GDate>() - 8usize];
    ["Alignment of _GDate"][::std::mem::align_of::<_GDate>() - 4usize];
};
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_days_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_days_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dmy_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dmy_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn day_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_day_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn month_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_month_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn year_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_year_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
unsafe extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
unsafe extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
unsafe extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
unsafe extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
unsafe extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
unsafe extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
unsafe extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
unsafe extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
unsafe extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
unsafe extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
unsafe extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
unsafe extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
unsafe extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
unsafe extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
unsafe extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
unsafe extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
unsafe extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesnt currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
unsafe extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
    -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
unsafe extern "C" {
    pub fn g_free(mem: gpointer);
}
unsafe extern "C" {
    pub fn g_free_sized(mem: gpointer, size: usize);
}
unsafe extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
unsafe extern "C" {
    pub fn g_aligned_free_sized(mem: gpointer, alignment: usize, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemVTable"][::std::mem::size_of::<_GMemVTable>() - 48usize];
    ["Alignment of _GMemVTable"][::std::mem::align_of::<_GMemVTable>() - 8usize];
    ["Offset of field: _GMemVTable::malloc"][::std::mem::offset_of!(_GMemVTable, malloc) - 0usize];
    ["Offset of field: _GMemVTable::realloc"]
        [::std::mem::offset_of!(_GMemVTable, realloc) - 8usize];
    ["Offset of field: _GMemVTable::free"][::std::mem::offset_of!(_GMemVTable, free) - 16usize];
    ["Offset of field: _GMemVTable::calloc"][::std::mem::offset_of!(_GMemVTable, calloc) - 24usize];
    ["Offset of field: _GMemVTable::try_malloc"]
        [::std::mem::offset_of!(_GMemVTable, try_malloc) - 32usize];
    ["Offset of field: _GMemVTable::try_realloc"]
        [::std::mem::offset_of!(_GMemVTable, try_realloc) - 40usize];
};
unsafe extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
unsafe extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
unsafe extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
unsafe extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNode"][::std::mem::size_of::<_GNode>() - 40usize];
    ["Alignment of _GNode"][::std::mem::align_of::<_GNode>() - 8usize];
    ["Offset of field: _GNode::data"][::std::mem::offset_of!(_GNode, data) - 0usize];
    ["Offset of field: _GNode::next"][::std::mem::offset_of!(_GNode, next) - 8usize];
    ["Offset of field: _GNode::prev"][::std::mem::offset_of!(_GNode, prev) - 16usize];
    ["Offset of field: _GNode::parent"][::std::mem::offset_of!(_GNode, parent) - 24usize];
    ["Offset of field: _GNode::children"][::std::mem::offset_of!(_GNode, children) - 32usize];
};
unsafe extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
unsafe extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
unsafe extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
    -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
unsafe extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GList"][::std::mem::size_of::<_GList>() - 24usize];
    ["Alignment of _GList"][::std::mem::align_of::<_GList>() - 8usize];
    ["Offset of field: _GList::data"][::std::mem::offset_of!(_GList, data) - 0usize];
    ["Offset of field: _GList::next"][::std::mem::offset_of!(_GList, next) - 8usize];
    ["Offset of field: _GList::prev"][::std::mem::offset_of!(_GList, prev) - 16usize];
};
unsafe extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_free(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
    -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
unsafe extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHashTableIter"][::std::mem::size_of::<_GHashTableIter>() - 40usize];
    ["Alignment of _GHashTableIter"][::std::mem::align_of::<_GHashTableIter>() - 8usize];
    ["Offset of field: _GHashTableIter::dummy1"]
        [::std::mem::offset_of!(_GHashTableIter, dummy1) - 0usize];
    ["Offset of field: _GHashTableIter::dummy2"]
        [::std::mem::offset_of!(_GHashTableIter, dummy2) - 8usize];
    ["Offset of field: _GHashTableIter::dummy3"]
        [::std::mem::offset_of!(_GHashTableIter, dummy3) - 16usize];
    ["Offset of field: _GHashTableIter::dummy4"]
        [::std::mem::offset_of!(_GHashTableIter, dummy4) - 24usize];
    ["Offset of field: _GHashTableIter::dummy5"]
        [::std::mem::offset_of!(_GHashTableIter, dummy5) - 28usize];
    ["Offset of field: _GHashTableIter::dummy6"]
        [::std::mem::offset_of!(_GHashTableIter, dummy6) - 32usize];
};
unsafe extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:\n\n An opaque structure representing a HMAC operation.\n To create a new GHmac, use g_hmac_new(). To free\n a GHmac, use g_hmac_unref().\n\n Since: 2.30"]
pub type GHmac = _GHmac;
unsafe extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
    -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
unsafe extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHookList"][::std::mem::size_of::<_GHookList>() - 56usize];
    ["Alignment of _GHookList"][::std::mem::align_of::<_GHookList>() - 8usize];
    ["Offset of field: _GHookList::seq_id"][::std::mem::offset_of!(_GHookList, seq_id) - 0usize];
    ["Offset of field: _GHookList::hooks"][::std::mem::offset_of!(_GHookList, hooks) - 16usize];
    ["Offset of field: _GHookList::dummy3"][::std::mem::offset_of!(_GHookList, dummy3) - 24usize];
    ["Offset of field: _GHookList::finalize_hook"]
        [::std::mem::offset_of!(_GHookList, finalize_hook) - 32usize];
    ["Offset of field: _GHookList::dummy"][::std::mem::offset_of!(_GHookList, dummy) - 40usize];
};
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hook_size_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hook_size_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_setup_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_setup_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHook"][::std::mem::size_of::<_GHook>() - 64usize];
    ["Alignment of _GHook"][::std::mem::align_of::<_GHook>() - 8usize];
    ["Offset of field: _GHook::data"][::std::mem::offset_of!(_GHook, data) - 0usize];
    ["Offset of field: _GHook::next"][::std::mem::offset_of!(_GHook, next) - 8usize];
    ["Offset of field: _GHook::prev"][::std::mem::offset_of!(_GHook, prev) - 16usize];
    ["Offset of field: _GHook::ref_count"][::std::mem::offset_of!(_GHook, ref_count) - 24usize];
    ["Offset of field: _GHook::hook_id"][::std::mem::offset_of!(_GHook, hook_id) - 32usize];
    ["Offset of field: _GHook::flags"][::std::mem::offset_of!(_GHook, flags) - 40usize];
    ["Offset of field: _GHook::func"][::std::mem::offset_of!(_GHook, func) - 48usize];
    ["Offset of field: _GHook::destroy"][::std::mem::offset_of!(_GHook, destroy) - 56usize];
};
unsafe extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
unsafe extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
unsafe extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
unsafe extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
unsafe extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPollFD"][::std::mem::size_of::<_GPollFD>() - 8usize];
    ["Alignment of _GPollFD"][::std::mem::align_of::<_GPollFD>() - 4usize];
    ["Offset of field: _GPollFD::fd"][::std::mem::offset_of!(_GPollFD, fd) - 0usize];
    ["Offset of field: _GPollFD::events"][::std::mem::offset_of!(_GPollFD, events) - 4usize];
    ["Offset of field: _GPollFD::revents"][::std::mem::offset_of!(_GPollFD, revents) - 6usize];
};
unsafe extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSList"][::std::mem::size_of::<_GSList>() - 16usize];
    ["Alignment of _GSList"][::std::mem::align_of::<_GSList>() - 8usize];
    ["Offset of field: _GSList::data"][::std::mem::offset_of!(_GSList, data) - 0usize];
    ["Offset of field: _GSList::next"][::std::mem::offset_of!(_GSList, next) - 8usize];
};
unsafe extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
unsafe extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GSourceOnceFunc:\n @user_data: data passed to the function, set when the source was\n   created\n\n A source function that is only called once before being removed from the main\n context automatically.\n\n See: g_idle_add_once(), g_timeout_add_once()\n\n Since: 2.74"]
pub type GSourceOnceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSource"][::std::mem::size_of::<_GSource>() - 96usize];
    ["Alignment of _GSource"][::std::mem::align_of::<_GSource>() - 8usize];
    ["Offset of field: _GSource::callback_data"]
        [::std::mem::offset_of!(_GSource, callback_data) - 0usize];
    ["Offset of field: _GSource::callback_funcs"]
        [::std::mem::offset_of!(_GSource, callback_funcs) - 8usize];
    ["Offset of field: _GSource::source_funcs"]
        [::std::mem::offset_of!(_GSource, source_funcs) - 16usize];
    ["Offset of field: _GSource::ref_count"][::std::mem::offset_of!(_GSource, ref_count) - 24usize];
    ["Offset of field: _GSource::context"][::std::mem::offset_of!(_GSource, context) - 32usize];
    ["Offset of field: _GSource::priority"][::std::mem::offset_of!(_GSource, priority) - 40usize];
    ["Offset of field: _GSource::flags"][::std::mem::offset_of!(_GSource, flags) - 44usize];
    ["Offset of field: _GSource::source_id"][::std::mem::offset_of!(_GSource, source_id) - 48usize];
    ["Offset of field: _GSource::poll_fds"][::std::mem::offset_of!(_GSource, poll_fds) - 56usize];
    ["Offset of field: _GSource::prev"][::std::mem::offset_of!(_GSource, prev) - 64usize];
    ["Offset of field: _GSource::next"][::std::mem::offset_of!(_GSource, next) - 72usize];
    ["Offset of field: _GSource::name"][::std::mem::offset_of!(_GSource, name) - 80usize];
    ["Offset of field: _GSource::priv_"][::std::mem::offset_of!(_GSource, priv_) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceCallbackFuncs"][::std::mem::size_of::<_GSourceCallbackFuncs>() - 24usize];
    ["Alignment of _GSourceCallbackFuncs"]
        [::std::mem::align_of::<_GSourceCallbackFuncs>() - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::ref_"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, ref_) - 0usize];
    ["Offset of field: _GSourceCallbackFuncs::unref"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, unref) - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::get"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, get) - 16usize];
};
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceFuncs"][::std::mem::size_of::<_GSourceFuncs>() - 48usize];
    ["Alignment of _GSourceFuncs"][::std::mem::align_of::<_GSourceFuncs>() - 8usize];
    ["Offset of field: _GSourceFuncs::prepare"]
        [::std::mem::offset_of!(_GSourceFuncs, prepare) - 0usize];
    ["Offset of field: _GSourceFuncs::check"]
        [::std::mem::offset_of!(_GSourceFuncs, check) - 8usize];
    ["Offset of field: _GSourceFuncs::dispatch"]
        [::std::mem::offset_of!(_GSourceFuncs, dispatch) - 16usize];
    ["Offset of field: _GSourceFuncs::finalize"]
        [::std::mem::offset_of!(_GSourceFuncs, finalize) - 24usize];
    ["Offset of field: _GSourceFuncs::closure_callback"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_callback) - 32usize];
    ["Offset of field: _GSourceFuncs::closure_marshal"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_marshal) - 40usize];
};
unsafe extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
unsafe extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
unsafe extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
unsafe extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_main_depth() -> gint;
}
unsafe extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
unsafe extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
unsafe extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
unsafe extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
unsafe extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
unsafe extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
unsafe extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
unsafe extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
unsafe extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
unsafe extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
unsafe extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
unsafe extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_get_real_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
unsafe extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
unsafe extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
unsafe extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n\n These are the possible line break classifications.\n\n Since new unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
unsafe extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
unsafe extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
unsafe extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
unsafe extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
    -> *mut gunichar;
}
unsafe extern "C" {
    pub static g_utf8_skip: *const gchar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
    -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static g_ascii_table: *const guint16;
}
unsafe extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
unsafe extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
unsafe extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
unsafe extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
unsafe extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
unsafe extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GString"][::std::mem::size_of::<_GString>() - 24usize];
    ["Alignment of _GString"][::std::mem::align_of::<_GString>() - 8usize];
    ["Offset of field: _GString::str_"][::std::mem::offset_of!(_GString, str_) - 0usize];
    ["Offset of field: _GString::len"][::std::mem::offset_of!(_GString, len) - 8usize];
    ["Offset of field: _GString::allocated_len"]
        [::std::mem::offset_of!(_GString, allocated_len) - 16usize];
};
unsafe extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
unsafe extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
unsafe extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
    -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOChannel"][::std::mem::size_of::<_GIOChannel>() - 112usize];
    ["Alignment of _GIOChannel"][::std::mem::align_of::<_GIOChannel>() - 8usize];
    ["Offset of field: _GIOChannel::ref_count"]
        [::std::mem::offset_of!(_GIOChannel, ref_count) - 0usize];
    ["Offset of field: _GIOChannel::funcs"][::std::mem::offset_of!(_GIOChannel, funcs) - 8usize];
    ["Offset of field: _GIOChannel::encoding"]
        [::std::mem::offset_of!(_GIOChannel, encoding) - 16usize];
    ["Offset of field: _GIOChannel::read_cd"]
        [::std::mem::offset_of!(_GIOChannel, read_cd) - 24usize];
    ["Offset of field: _GIOChannel::write_cd"]
        [::std::mem::offset_of!(_GIOChannel, write_cd) - 32usize];
    ["Offset of field: _GIOChannel::line_term"]
        [::std::mem::offset_of!(_GIOChannel, line_term) - 40usize];
    ["Offset of field: _GIOChannel::line_term_len"]
        [::std::mem::offset_of!(_GIOChannel, line_term_len) - 48usize];
    ["Offset of field: _GIOChannel::buf_size"]
        [::std::mem::offset_of!(_GIOChannel, buf_size) - 56usize];
    ["Offset of field: _GIOChannel::read_buf"]
        [::std::mem::offset_of!(_GIOChannel, read_buf) - 64usize];
    ["Offset of field: _GIOChannel::encoded_read_buf"]
        [::std::mem::offset_of!(_GIOChannel, encoded_read_buf) - 72usize];
    ["Offset of field: _GIOChannel::write_buf"]
        [::std::mem::offset_of!(_GIOChannel, write_buf) - 80usize];
    ["Offset of field: _GIOChannel::partial_write_buf"]
        [::std::mem::offset_of!(_GIOChannel, partial_write_buf) - 88usize];
    ["Offset of field: _GIOChannel::reserved1"]
        [::std::mem::offset_of!(_GIOChannel, reserved1) - 96usize];
    ["Offset of field: _GIOChannel::reserved2"]
        [::std::mem::offset_of!(_GIOChannel, reserved2) - 104usize];
};
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_buffer_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_buffer_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_encode_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_encode_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn close_on_unref_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_close_on_unref_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_readable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_readable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_writeable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_writeable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_seekable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_seekable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOFuncs"][::std::mem::size_of::<_GIOFuncs>() - 64usize];
    ["Alignment of _GIOFuncs"][::std::mem::align_of::<_GIOFuncs>() - 8usize];
    ["Offset of field: _GIOFuncs::io_read"][::std::mem::offset_of!(_GIOFuncs, io_read) - 0usize];
    ["Offset of field: _GIOFuncs::io_write"][::std::mem::offset_of!(_GIOFuncs, io_write) - 8usize];
    ["Offset of field: _GIOFuncs::io_seek"][::std::mem::offset_of!(_GIOFuncs, io_seek) - 16usize];
    ["Offset of field: _GIOFuncs::io_close"][::std::mem::offset_of!(_GIOFuncs, io_close) - 24usize];
    ["Offset of field: _GIOFuncs::io_create_watch"]
        [::std::mem::offset_of!(_GIOFuncs, io_create_watch) - 32usize];
    ["Offset of field: _GIOFuncs::io_free"][::std::mem::offset_of!(_GIOFuncs, io_free) - 40usize];
    ["Offset of field: _GIOFuncs::io_set_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_set_flags) - 48usize];
    ["Offset of field: _GIOFuncs::io_get_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_get_flags) - 56usize];
};
unsafe extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
unsafe extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
unsafe extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
unsafe extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
unsafe extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
unsafe extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
unsafe extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMarkupParser"][::std::mem::size_of::<_GMarkupParser>() - 40usize];
    ["Alignment of _GMarkupParser"][::std::mem::align_of::<_GMarkupParser>() - 8usize];
    ["Offset of field: _GMarkupParser::start_element"]
        [::std::mem::offset_of!(_GMarkupParser, start_element) - 0usize];
    ["Offset of field: _GMarkupParser::end_element"]
        [::std::mem::offset_of!(_GMarkupParser, end_element) - 8usize];
    ["Offset of field: _GMarkupParser::text"]
        [::std::mem::offset_of!(_GMarkupParser, text) - 16usize];
    ["Offset of field: _GMarkupParser::passthrough"]
        [::std::mem::offset_of!(_GMarkupParser, passthrough) - 24usize];
    ["Offset of field: _GMarkupParser::error"]
        [::std::mem::offset_of!(_GMarkupParser, error) - 32usize];
};
unsafe extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:\n\n A type in the GVariant type system.\n\n Two types may not be compared by value; use g_variant_type_equal() or\n g_variant_type_is_subtype_of().  May be copied using\n g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
unsafe extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
unsafe extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
unsafe extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
unsafe extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
unsafe extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
unsafe extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
unsafe extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
unsafe extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
unsafe extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
unsafe extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantIter"][::std::mem::size_of::<_GVariantIter>() - 128usize];
    ["Alignment of _GVariantIter"][::std::mem::align_of::<_GVariantIter>() - 8usize];
    ["Offset of field: _GVariantIter::x"][::std::mem::offset_of!(_GVariantIter, x) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
unsafe extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::partial_magic"][::std::mem::offset_of!(
        _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
        partial_magic
    ) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::type_"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, type_) - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder"][::std::mem::size_of::<_GVariantBuilder>() - 128usize];
    ["Alignment of _GVariantBuilder"][::std::mem::align_of::<_GVariantBuilder>() - 8usize];
    ["Offset of field: _GVariantBuilder::u"][::std::mem::offset_of!(_GVariantBuilder, u) - 0usize];
};
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
unsafe extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::asv"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, asv) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::partial_magic"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, partial_magic) - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict"][::std::mem::size_of::<_GVariantDict>() - 128usize];
    ["Alignment of _GVariantDict"][::std::mem::align_of::<_GVariantDict>() - 8usize];
    ["Offset of field: _GVariantDict::u"][::std::mem::offset_of!(_GVariantDict, u) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
unsafe extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
unsafe extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
unsafe extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
unsafe extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GLogField"][::std::mem::size_of::<_GLogField>() - 24usize];
    ["Alignment of _GLogField"][::std::mem::align_of::<_GLogField>() - 8usize];
    ["Offset of field: _GLogField::key"][::std::mem::offset_of!(_GLogField, key) - 0usize];
    ["Offset of field: _GLogField::value"][::std::mem::offset_of!(_GLogField, value) - 8usize];
    ["Offset of field: _GLogField::length"][::std::mem::offset_of!(_GLogField, length) - 16usize];
};
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
unsafe extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
unsafe extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
unsafe extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
unsafe extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
unsafe extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
unsafe extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
unsafe extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed. i.e. %FALSE will\n     be stored into the argument rather than %TRUE.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOptionEntry"][::std::mem::size_of::<_GOptionEntry>() - 48usize];
    ["Alignment of _GOptionEntry"][::std::mem::align_of::<_GOptionEntry>() - 8usize];
    ["Offset of field: _GOptionEntry::long_name"]
        [::std::mem::offset_of!(_GOptionEntry, long_name) - 0usize];
    ["Offset of field: _GOptionEntry::short_name"]
        [::std::mem::offset_of!(_GOptionEntry, short_name) - 8usize];
    ["Offset of field: _GOptionEntry::flags"]
        [::std::mem::offset_of!(_GOptionEntry, flags) - 12usize];
    ["Offset of field: _GOptionEntry::arg"][::std::mem::offset_of!(_GOptionEntry, arg) - 16usize];
    ["Offset of field: _GOptionEntry::arg_data"]
        [::std::mem::offset_of!(_GOptionEntry, arg_data) - 24usize];
    ["Offset of field: _GOptionEntry::description"]
        [::std::mem::offset_of!(_GOptionEntry, description) - 32usize];
    ["Offset of field: _GOptionEntry::arg_description"]
        [::std::mem::offset_of!(_GOptionEntry, arg_description) - 40usize];
};
unsafe extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
unsafe extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
unsafe extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
unsafe extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
unsafe extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
unsafe extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
pub type GPathBuf = _GPathBuf;
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPathBuf {
    pub dummy: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPathBuf"][::std::mem::size_of::<_GPathBuf>() - 64usize];
    ["Alignment of _GPathBuf"][::std::mem::align_of::<_GPathBuf>() - 8usize];
    ["Offset of field: _GPathBuf::dummy"][::std::mem::offset_of!(_GPathBuf, dummy) - 0usize];
};
unsafe extern "C" {
    pub fn g_path_buf_new() -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_new_from_path(path: *const ::std::os::raw::c_char) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_init_from_path(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
}
unsafe extern "C" {
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_free(buf: *mut GPathBuf);
}
unsafe extern "C" {
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_push(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_set_filename(
        buf: *mut GPathBuf,
        file_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_set_extension(
        buf: *mut GPathBuf,
        extension: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
unsafe extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
unsafe extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GQueue"][::std::mem::size_of::<_GQueue>() - 24usize];
    ["Alignment of _GQueue"][::std::mem::align_of::<_GQueue>() - 8usize];
    ["Offset of field: _GQueue::head"][::std::mem::offset_of!(_GQueue, head) - 0usize];
    ["Offset of field: _GQueue::tail"][::std::mem::offset_of!(_GQueue, tail) - 8usize];
    ["Offset of field: _GQueue::length"][::std::mem::offset_of!(_GQueue, length) - 16usize];
};
unsafe extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
unsafe extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
unsafe extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
unsafe extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
unsafe extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
unsafe extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
unsafe extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
unsafe extern "C" {
    pub fn g_random_int() -> guint32;
}
unsafe extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_random_double() -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT\n     compilation, which, if the just-in-time compiler is available, further\n     processes a compiled pattern into machine code that executes much\n     faster. However, it comes at the cost of extra processing before the\n     match is performed, so it is most beneficial to use this when the same\n     compiled pattern is used for matching many times. Before 2.74 this\n     option used the built-in non-JIT optimizations in pcre1.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,\n     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:\n\n A GRegex is the \"compiled\" form of a regular expression pattern.\n This structure is opaque and its fields cannot be accessed directly.\n\n Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
unsafe extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
unsafe extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
unsafe extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
unsafe extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
unsafe extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTokenValue"][::std::mem::size_of::<_GTokenValue>() - 8usize];
    ["Alignment of _GTokenValue"][::std::mem::align_of::<_GTokenValue>() - 8usize];
    ["Offset of field: _GTokenValue::v_symbol"]
        [::std::mem::offset_of!(_GTokenValue, v_symbol) - 0usize];
    ["Offset of field: _GTokenValue::v_identifier"]
        [::std::mem::offset_of!(_GTokenValue, v_identifier) - 0usize];
    ["Offset of field: _GTokenValue::v_binary"]
        [::std::mem::offset_of!(_GTokenValue, v_binary) - 0usize];
    ["Offset of field: _GTokenValue::v_octal"]
        [::std::mem::offset_of!(_GTokenValue, v_octal) - 0usize];
    ["Offset of field: _GTokenValue::v_int"][::std::mem::offset_of!(_GTokenValue, v_int) - 0usize];
    ["Offset of field: _GTokenValue::v_int64"]
        [::std::mem::offset_of!(_GTokenValue, v_int64) - 0usize];
    ["Offset of field: _GTokenValue::v_float"]
        [::std::mem::offset_of!(_GTokenValue, v_float) - 0usize];
    ["Offset of field: _GTokenValue::v_hex"][::std::mem::offset_of!(_GTokenValue, v_hex) - 0usize];
    ["Offset of field: _GTokenValue::v_string"]
        [::std::mem::offset_of!(_GTokenValue, v_string) - 0usize];
    ["Offset of field: _GTokenValue::v_comment"]
        [::std::mem::offset_of!(_GTokenValue, v_comment) - 0usize];
    ["Offset of field: _GTokenValue::v_char"]
        [::std::mem::offset_of!(_GTokenValue, v_char) - 0usize];
    ["Offset of field: _GTokenValue::v_error"]
        [::std::mem::offset_of!(_GTokenValue, v_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScannerConfig"][::std::mem::size_of::<_GScannerConfig>() - 40usize];
    ["Alignment of _GScannerConfig"][::std::mem::align_of::<_GScannerConfig>() - 8usize];
    ["Offset of field: _GScannerConfig::cset_skip_characters"]
        [::std::mem::offset_of!(_GScannerConfig, cset_skip_characters) - 0usize];
    ["Offset of field: _GScannerConfig::cset_identifier_first"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_first) - 8usize];
    ["Offset of field: _GScannerConfig::cset_identifier_nth"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_nth) - 16usize];
    ["Offset of field: _GScannerConfig::cpair_comment_single"]
        [::std::mem::offset_of!(_GScannerConfig, cpair_comment_single) - 24usize];
    ["Offset of field: _GScannerConfig::padding_dummy"]
        [::std::mem::offset_of!(_GScannerConfig, padding_dummy) - 36usize];
};
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn case_sensitive_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_case_sensitive_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_single_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_single_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_1char_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_1char_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_NULL_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_NULL_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_symbols_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_symbols_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_binary_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_binary_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_octal_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_octal_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_dollar_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_dollar_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_sq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_sq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_dq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_dq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numbers_2_int_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numbers_2_int_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn int_2_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_int_2_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn identifier_2_string_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_identifier_2_string_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn char_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_char_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn symbol_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_symbol_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scope_0_fallback_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scope_0_fallback_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn store_int64_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_store_int64_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScanner"][::std::mem::size_of::<_GScanner>() - 144usize];
    ["Alignment of _GScanner"][::std::mem::align_of::<_GScanner>() - 8usize];
    ["Offset of field: _GScanner::user_data"]
        [::std::mem::offset_of!(_GScanner, user_data) - 0usize];
    ["Offset of field: _GScanner::max_parse_errors"]
        [::std::mem::offset_of!(_GScanner, max_parse_errors) - 8usize];
    ["Offset of field: _GScanner::parse_errors"]
        [::std::mem::offset_of!(_GScanner, parse_errors) - 12usize];
    ["Offset of field: _GScanner::input_name"]
        [::std::mem::offset_of!(_GScanner, input_name) - 16usize];
    ["Offset of field: _GScanner::qdata"][::std::mem::offset_of!(_GScanner, qdata) - 24usize];
    ["Offset of field: _GScanner::config"][::std::mem::offset_of!(_GScanner, config) - 32usize];
    ["Offset of field: _GScanner::token"][::std::mem::offset_of!(_GScanner, token) - 40usize];
    ["Offset of field: _GScanner::value"][::std::mem::offset_of!(_GScanner, value) - 48usize];
    ["Offset of field: _GScanner::line"][::std::mem::offset_of!(_GScanner, line) - 56usize];
    ["Offset of field: _GScanner::position"][::std::mem::offset_of!(_GScanner, position) - 60usize];
    ["Offset of field: _GScanner::next_token"]
        [::std::mem::offset_of!(_GScanner, next_token) - 64usize];
    ["Offset of field: _GScanner::next_value"]
        [::std::mem::offset_of!(_GScanner, next_value) - 72usize];
    ["Offset of field: _GScanner::next_line"]
        [::std::mem::offset_of!(_GScanner, next_line) - 80usize];
    ["Offset of field: _GScanner::next_position"]
        [::std::mem::offset_of!(_GScanner, next_position) - 84usize];
    ["Offset of field: _GScanner::symbol_table"]
        [::std::mem::offset_of!(_GScanner, symbol_table) - 88usize];
    ["Offset of field: _GScanner::input_fd"][::std::mem::offset_of!(_GScanner, input_fd) - 96usize];
    ["Offset of field: _GScanner::text"][::std::mem::offset_of!(_GScanner, text) - 104usize];
    ["Offset of field: _GScanner::text_end"]
        [::std::mem::offset_of!(_GScanner, text_end) - 112usize];
    ["Offset of field: _GScanner::buffer"][::std::mem::offset_of!(_GScanner, buffer) - 120usize];
    ["Offset of field: _GScanner::scope_id"]
        [::std::mem::offset_of!(_GScanner, scope_id) - 128usize];
    ["Offset of field: _GScanner::msg_handler"]
        [::std::mem::offset_of!(_GScanner, msg_handler) - 136usize];
};
unsafe extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
unsafe extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
unsafe extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
unsafe extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
unsafe extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
unsafe extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
unsafe extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
unsafe extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
unsafe extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
    -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
unsafe extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
unsafe extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
unsafe extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
unsafe extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:\n @data: user data passed to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " G_SPAWN_CHILD_INHERITS_STDOUT:\n\n The child will inherit the parent's standard output.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[doc = " G_SPAWN_CHILD_INHERITS_STDERR:\n\n The child will inherit the parent's standard error.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[doc = " G_SPAWN_STDIN_FROM_DEV_NULL:\n\n The child's standard input is attached to `/dev/null`.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n @G_SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.\n     Since: 2.74\n @G_SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.\n     Since: 2.74\n @G_SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.\n     Since: 2.74\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
unsafe extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
unsafe extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
#[doc = " GStrvBuilder:\n\n A helper object to build a %NULL-terminated string array\n by appending. See g_strv_builder_new().\n\n Since: 2.68"]
pub type GStrvBuilder = _GStrvBuilder;
unsafe extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
unsafe extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
unsafe extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
unsafe extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
unsafe extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
unsafe extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_fail();
}
unsafe extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_failed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
unsafe extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_timer_start();
}
unsafe extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
unsafe extern "C" {
    pub fn g_test_timer_last() -> f64;
}
unsafe extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
unsafe extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
unsafe extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_double() -> f64;
}
unsafe extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
unsafe extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
unsafe extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestConfig"][::std::mem::size_of::<GTestConfig>() - 24usize];
    ["Alignment of GTestConfig"][::std::mem::align_of::<GTestConfig>() - 4usize];
    ["Offset of field: GTestConfig::test_initialized"]
        [::std::mem::offset_of!(GTestConfig, test_initialized) - 0usize];
    ["Offset of field: GTestConfig::test_quick"]
        [::std::mem::offset_of!(GTestConfig, test_quick) - 4usize];
    ["Offset of field: GTestConfig::test_perf"]
        [::std::mem::offset_of!(GTestConfig, test_perf) - 8usize];
    ["Offset of field: GTestConfig::test_verbose"]
        [::std::mem::offset_of!(GTestConfig, test_verbose) - 12usize];
    ["Offset of field: GTestConfig::test_quiet"]
        [::std::mem::offset_of!(GTestConfig, test_quiet) - 16usize];
    ["Offset of field: GTestConfig::test_undefined"]
        [::std::mem::offset_of!(GTestConfig, test_undefined) - 20usize];
};
unsafe extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogMsg"][::std::mem::size_of::<GTestLogMsg>() - 32usize];
    ["Alignment of GTestLogMsg"][::std::mem::align_of::<GTestLogMsg>() - 8usize];
    ["Offset of field: GTestLogMsg::log_type"]
        [::std::mem::offset_of!(GTestLogMsg, log_type) - 0usize];
    ["Offset of field: GTestLogMsg::n_strings"]
        [::std::mem::offset_of!(GTestLogMsg, n_strings) - 4usize];
    ["Offset of field: GTestLogMsg::strings"]
        [::std::mem::offset_of!(GTestLogMsg, strings) - 8usize];
    ["Offset of field: GTestLogMsg::n_nums"][::std::mem::offset_of!(GTestLogMsg, n_nums) - 16usize];
    ["Offset of field: GTestLogMsg::nums"][::std::mem::offset_of!(GTestLogMsg, nums) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogBuffer"][::std::mem::size_of::<GTestLogBuffer>() - 16usize];
    ["Alignment of GTestLogBuffer"][::std::mem::align_of::<GTestLogBuffer>() - 8usize];
    ["Offset of field: GTestLogBuffer::data"]
        [::std::mem::offset_of!(GTestLogBuffer, data) - 0usize];
    ["Offset of field: GTestLogBuffer::msgs"]
        [::std::mem::offset_of!(GTestLogBuffer, msgs) - 8usize];
};
unsafe extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
unsafe extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
unsafe extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
unsafe extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadPool"][::std::mem::size_of::<_GThreadPool>() - 24usize];
    ["Alignment of _GThreadPool"][::std::mem::align_of::<_GThreadPool>() - 8usize];
    ["Offset of field: _GThreadPool::func"][::std::mem::offset_of!(_GThreadPool, func) - 0usize];
    ["Offset of field: _GThreadPool::user_data"]
        [::std::mem::offset_of!(_GThreadPool, user_data) - 8usize];
    ["Offset of field: _GThreadPool::exclusive"]
        [::std::mem::offset_of!(_GThreadPool, exclusive) - 16usize];
};
unsafe extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
unsafe extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
unsafe extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
unsafe extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
unsafe extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
unsafe extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
unsafe extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTrashStack"][::std::mem::size_of::<_GTrashStack>() - 8usize];
    ["Alignment of _GTrashStack"][::std::mem::align_of::<_GTrashStack>() - 8usize];
    ["Offset of field: _GTrashStack::next"][::std::mem::offset_of!(_GTrashStack, next) - 0usize];
};
unsafe extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
unsafe extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
unsafe extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
unsafe extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
unsafe extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Dont use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
unsafe extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUriParamsIter"][::std::mem::size_of::<_GUriParamsIter>() - 280usize];
    ["Alignment of _GUriParamsIter"][::std::mem::align_of::<_GUriParamsIter>() - 8usize];
    ["Offset of field: _GUriParamsIter::dummy0"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy0) - 0usize];
    ["Offset of field: _GUriParamsIter::dummy1"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy1) - 8usize];
    ["Offset of field: _GUriParamsIter::dummy2"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy2) - 16usize];
    ["Offset of field: _GUriParamsIter::dummy3"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy3) - 24usize];
};
unsafe extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
unsafe extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
unsafe extern "C" {
    pub static glib_major_version: guint;
}
unsafe extern "C" {
    pub static glib_minor_version: guint;
}
unsafe extern "C" {
    pub static glib_micro_version: guint;
}
unsafe extern "C" {
    pub static glib_interface_age: guint;
}
unsafe extern "C" {
    pub static glib_binary_age: guint;
}
unsafe extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
unsafe extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
unsafe extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
unsafe extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_info();
}
unsafe extern "C" {
    pub fn g_blow_chunks();
}
unsafe extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
unsafe extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_pop_allocator();
}
unsafe extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_slist_pop_allocator();
}
unsafe extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
unsafe extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
unsafe extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
unsafe extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
unsafe extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCompletion"][::std::mem::size_of::<_GCompletion>() - 40usize];
    ["Alignment of _GCompletion"][::std::mem::align_of::<_GCompletion>() - 8usize];
    ["Offset of field: _GCompletion::items"][::std::mem::offset_of!(_GCompletion, items) - 0usize];
    ["Offset of field: _GCompletion::func"][::std::mem::offset_of!(_GCompletion, func) - 8usize];
    ["Offset of field: _GCompletion::prefix"]
        [::std::mem::offset_of!(_GCompletion, prefix) - 16usize];
    ["Offset of field: _GCompletion::cache"][::std::mem::offset_of!(_GCompletion, cache) - 24usize];
    ["Offset of field: _GCompletion::strncmp_func"]
        [::std::mem::offset_of!(_GCompletion, strncmp_func) - 32usize];
};
unsafe extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
unsafe extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
unsafe extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
unsafe extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTuples"][::std::mem::size_of::<_GTuples>() - 4usize];
    ["Alignment of _GTuples"][::std::mem::align_of::<_GTuples>() - 4usize];
    ["Offset of field: _GTuples::len"][::std::mem::offset_of!(_GTuples, len) - 0usize];
};
unsafe extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
unsafe extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
unsafe extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
unsafe extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
unsafe extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
unsafe extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
unsafe extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThread"][::std::mem::size_of::<_GThread>() - 24usize];
    ["Alignment of _GThread"][::std::mem::align_of::<_GThread>() - 8usize];
    ["Offset of field: _GThread::func"][::std::mem::offset_of!(_GThread, func) - 0usize];
    ["Offset of field: _GThread::data"][::std::mem::offset_of!(_GThread, data) - 8usize];
    ["Offset of field: _GThread::joinable"][::std::mem::offset_of!(_GThread, joinable) - 16usize];
    ["Offset of field: _GThread::priority"][::std::mem::offset_of!(_GThread, priority) - 20usize];
};
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadFunctions"][::std::mem::size_of::<_GThreadFunctions>() - 168usize];
    ["Alignment of _GThreadFunctions"][::std::mem::align_of::<_GThreadFunctions>() - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_new"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_new) - 0usize];
    ["Offset of field: _GThreadFunctions::mutex_lock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_lock) - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_trylock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_trylock) - 16usize];
    ["Offset of field: _GThreadFunctions::mutex_unlock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_unlock) - 24usize];
    ["Offset of field: _GThreadFunctions::mutex_free"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_free) - 32usize];
    ["Offset of field: _GThreadFunctions::cond_new"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_new) - 40usize];
    ["Offset of field: _GThreadFunctions::cond_signal"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_signal) - 48usize];
    ["Offset of field: _GThreadFunctions::cond_broadcast"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_broadcast) - 56usize];
    ["Offset of field: _GThreadFunctions::cond_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_wait) - 64usize];
    ["Offset of field: _GThreadFunctions::cond_timed_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_timed_wait) - 72usize];
    ["Offset of field: _GThreadFunctions::cond_free"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_free) - 80usize];
    ["Offset of field: _GThreadFunctions::private_new"]
        [::std::mem::offset_of!(_GThreadFunctions, private_new) - 88usize];
    ["Offset of field: _GThreadFunctions::private_get"]
        [::std::mem::offset_of!(_GThreadFunctions, private_get) - 96usize];
    ["Offset of field: _GThreadFunctions::private_set"]
        [::std::mem::offset_of!(_GThreadFunctions, private_set) - 104usize];
    ["Offset of field: _GThreadFunctions::thread_create"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_create) - 112usize];
    ["Offset of field: _GThreadFunctions::thread_yield"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_yield) - 120usize];
    ["Offset of field: _GThreadFunctions::thread_join"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_join) - 128usize];
    ["Offset of field: _GThreadFunctions::thread_exit"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_exit) - 136usize];
    ["Offset of field: _GThreadFunctions::thread_set_priority"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_set_priority) - 144usize];
    ["Offset of field: _GThreadFunctions::thread_self"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_self) - 152usize];
    ["Offset of field: _GThreadFunctions::thread_equal"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_equal) - 160usize];
};
unsafe extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
unsafe extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
unsafe extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
unsafe extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
unsafe extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_tag"][::std::mem::size_of::<__jmp_buf_tag>() - 200usize];
    ["Alignment of __jmp_buf_tag"][::std::mem::align_of::<__jmp_buf_tag>() - 8usize];
    ["Offset of field: __jmp_buf_tag::__jmpbuf"]
        [::std::mem::offset_of!(__jmp_buf_tag, __jmpbuf) - 0usize];
    ["Offset of field: __jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__jmp_buf_tag, __mask_was_saved) - 64usize];
    ["Offset of field: __jmp_buf_tag::__saved_mask"]
        [::std::mem::offset_of!(__jmp_buf_tag, __saved_mask) - 72usize];
};
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"][::std::mem::size_of::<_pthread_cleanup_buffer>() - 32usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::std::mem::align_of::<_pthread_cleanup_buffer>() - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 24usize];
};
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __cancel_jmp_buf_tag"][::std::mem::size_of::<__cancel_jmp_buf_tag>() - 72usize];
    ["Alignment of __cancel_jmp_buf_tag"][::std::mem::align_of::<__cancel_jmp_buf_tag>() - 8usize];
    ["Offset of field: __cancel_jmp_buf_tag::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __cancel_jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __mask_was_saved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::std::mem::size_of::<__pthread_unwind_buf_t>() - 104usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::std::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"][::std::mem::size_of::<__pthread_cleanup_frame>() - 24usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::std::mem::align_of::<__pthread_cleanup_frame>() - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 20usize];
};
unsafe extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GStaticMutex"][::std::mem::size_of::<GStaticMutex>() - 48usize];
    ["Alignment of GStaticMutex"][::std::mem::align_of::<GStaticMutex>() - 8usize];
    ["Offset of field: GStaticMutex::mutex"][::std::mem::offset_of!(GStaticMutex, mutex) - 0usize];
    ["Offset of field: GStaticMutex::unused"]
        [::std::mem::offset_of!(GStaticMutex, unused) - 8usize];
};
unsafe extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Alignment of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::owner"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, owner) - 0usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::dummy"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, dummy) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex"][::std::mem::size_of::<_GStaticRecMutex>() - 64usize];
    ["Alignment of _GStaticRecMutex"][::std::mem::align_of::<_GStaticRecMutex>() - 8usize];
    ["Offset of field: _GStaticRecMutex::mutex"]
        [::std::mem::offset_of!(_GStaticRecMutex, mutex) - 0usize];
    ["Offset of field: _GStaticRecMutex::depth"]
        [::std::mem::offset_of!(_GStaticRecMutex, depth) - 48usize];
    ["Offset of field: _GStaticRecMutex::unused"]
        [::std::mem::offset_of!(_GStaticRecMutex, unused) - 56usize];
};
unsafe extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRWLock"][::std::mem::size_of::<_GStaticRWLock>() - 80usize];
    ["Alignment of _GStaticRWLock"][::std::mem::align_of::<_GStaticRWLock>() - 8usize];
    ["Offset of field: _GStaticRWLock::mutex"]
        [::std::mem::offset_of!(_GStaticRWLock, mutex) - 0usize];
    ["Offset of field: _GStaticRWLock::read_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, read_cond) - 48usize];
    ["Offset of field: _GStaticRWLock::write_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, write_cond) - 56usize];
    ["Offset of field: _GStaticRWLock::read_counter"]
        [::std::mem::offset_of!(_GStaticRWLock, read_counter) - 64usize];
    ["Offset of field: _GStaticRWLock::have_writer"]
        [::std::mem::offset_of!(_GStaticRWLock, have_writer) - 68usize];
    ["Offset of field: _GStaticRWLock::want_to_read"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_read) - 72usize];
    ["Offset of field: _GStaticRWLock::want_to_write"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_write) - 76usize];
};
unsafe extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticPrivate"][::std::mem::size_of::<_GStaticPrivate>() - 4usize];
    ["Alignment of _GStaticPrivate"][::std::mem::align_of::<_GStaticPrivate>() - 4usize];
    ["Offset of field: _GStaticPrivate::index"]
        [::std::mem::offset_of!(_GStaticPrivate, index) - 0usize];
};
unsafe extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
unsafe extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
unsafe extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
pub type GPathBuf_autoptr = *mut GPathBuf;
pub type GPathBuf_listautoptr = *mut GList;
pub type GPathBuf_slistautoptr = *mut GSList;
pub type GPathBuf_queueautoptr = *mut GQueue;
pub type GType = gsize;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
pub type GTypeInterface = _GTypeInterface;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
pub type GTypeInfo = _GTypeInfo;
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
pub type GInterfaceInfo = _GInterfaceInfo;
#[doc = " GTypeValueTable:\n @value_init: Default initialize @values contents by poking values\n  directly into the value->data array. The data array of\n  the #GValue passed into this function was zero-filled\n  with `memset()`, so no care has to be taken to free any\n  old contents. E.g. for the implementation of a string\n  value that may never be %NULL, the implementation might\n  look like:\n  |[<!-- language=\"C\" -->\n  value->data[0].v_pointer = g_strdup (\"\");\n  ]|\n @value_free: Free any old contents that might be left in the\n  data array of the passed in @value. No resources may\n  remain allocated through the #GValue contents after\n  this function returns. E.g. for our above string type:\n  |[<!-- language=\"C\" -->\n  // only free strings without a specific flag for static storage\n  if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n    g_free (value->data[0].v_pointer);\n  ]|\n @value_copy: @dest_value is a #GValue with zero-filled data section\n  and @src_value is a properly setup #GValue of same or\n  derived type.\n  The purpose of this function is to copy the contents of\n  @src_value into @dest_value in a way, that even after\n  @src_value has been freed, the contents of @dest_value\n  remain valid. String type example:\n  |[<!-- language=\"C\" -->\n  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n  ]|\n @value_peek_pointer: If the value contents fit into a pointer, such as objects\n  or strings, return this pointer, so the caller can peek at\n  the current contents. To extend on our above string example:\n  |[<!-- language=\"C\" -->\n  return value->data[0].v_pointer;\n  ]|\n @collect_format: A string format describing how to collect the contents of\n  this value bit-by-bit. Each character in the format represents\n  an argument to be collected, and the characters themselves indicate\n  the type of the argument. Currently supported arguments are:\n  - 'i' - Integers. passed as collect_values[].v_int.\n  - 'l' - Longs. passed as collect_values[].v_long.\n  - 'd' - Doubles. passed as collect_values[].v_double.\n  - 'p' - Pointers. passed as collect_values[].v_pointer.\n  It should be noted that for variable argument list construction,\n  ANSI C promotes every type smaller than an integer to an int, and\n  floats to doubles. So for collection of short int or char, 'i'\n  needs to be used, and for collection of floats 'd'.\n @collect_value: The collect_value() function is responsible for converting the\n  values collected from a variable argument list into contents\n  suitable for storage in a GValue. This function should setup\n  @value similar to value_init(); e.g. for a string value that\n  does not allow %NULL pointers, it needs to either spew an error,\n  or do an implicit conversion by storing an empty string.\n  The @value passed in to this function has a zero-filled data\n  array, so just like for value_init() it is guaranteed to not\n  contain any old contents that might need freeing.\n  @n_collect_values is exactly the string length of @collect_format,\n  and @collect_values is an array of unions #GTypeCValue with\n  length @n_collect_values, containing the collected values\n  according to @collect_format.\n  @collect_flags is an argument provided as a hint by the caller.\n  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,\n  that the collected value contents may be considered \"static\"\n  for the duration of the @value lifetime.\n  Thus an extra copy of the contents stored in @collect_values is\n  not required for assignment to @value.\n  For our above string example, we continue with:\n  |[<!-- language=\"C\" -->\n  if (!collect_values[0].v_pointer)\n    value->data[0].v_pointer = g_strdup (\"\");\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n  {\n    value->data[0].v_pointer = collect_values[0].v_pointer;\n    // keep a flag for the value_free() implementation to not free this string\n    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n  }\n  else\n    value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n  return NULL;\n  ]|\n  It should be noted, that it is generally a bad idea to follow the\n  %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n  reentrancy requirements and reference count assertions performed\n  by the signal emission code, reference counts should always be\n  incremented for reference counted contents stored in the value->data\n  array.  To deviate from our string example for a moment, and taking\n  a look at an exemplary implementation for collect_value() of\n  #GObject:\n  |[<!-- language=\"C\" -->\n    GObject *object = G_OBJECT (collect_values[0].v_pointer);\n    g_return_val_if_fail (object != NULL,\n       g_strdup_printf (\"Object passed as invalid NULL pointer\"));\n    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n    value->data[0].v_pointer = g_object_ref (object);\n    return NULL;\n  ]|\n  The reference count for valid objects is always incremented,\n  regardless of @collect_flags. For invalid objects, the example\n  returns a newly allocated string without altering @value.\n  Upon success, collect_value() needs to return %NULL. If, however,\n  an error condition occurred, collect_value() may spew an\n  error by returning a newly allocated non-%NULL string, giving\n  a suitable description of the error condition.\n  The calling code makes no assumptions about the @value\n  contents being valid upon error returns, @value\n  is simply thrown away without further freeing. As such, it is\n  a good idea to not allocate #GValue contents, prior to returning\n  an error, however, collect_values() is not obliged to return\n  a correctly setup @value for error returns, simply because\n  any non-%NULL return is considered a fatal condition so further\n  program behaviour is undefined.\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n  analogous to @collect_format. Usually, @lcopy_format string consists\n  only of 'p's to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: This function is responsible for storing the @value contents into\n  arguments passed through a variable argument list which got\n  collected into @collect_values according to @lcopy_format.\n  @n_collect_values equals the string length of @lcopy_format,\n  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.\n  In contrast to collect_value(), lcopy_value() is obliged to\n  always properly support %G_VALUE_NOCOPY_CONTENTS.\n  Similar to collect_value() the function may prematurely abort\n  by returning a newly allocated string describing an error condition.\n  To complete the string example:\n  |[<!-- language=\"C\" -->\n  gchar **string_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (string_p != NULL,\n      g_strdup_printf (\"string location passed as NULL\"));\n  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n    *string_p = value->data[0].v_pointer;\n  else\n    *string_p = g_strdup (value->data[0].v_pointer);\n  ]|\n  And an illustrative version of lcopy_value() for\n  reference-counted types:\n  |[<!-- language=\"C\" -->\n  GObject **object_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (object_p != NULL,\n    g_strdup_printf (\"object location passed as NULL\"));\n  if (!value->data[0].v_pointer)\n    *object_p = NULL;\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n    *object_p = value->data[0].v_pointer;\n  else\n    *object_p = g_object_ref (value->data[0].v_pointer);\n  return NULL;\n  ]|\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
pub type GTypeValueTable = _GTypeValueTable;
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
pub type GTypeQuery = _GTypeQuery;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeClass"][::std::mem::size_of::<_GTypeClass>() - 8usize];
    ["Alignment of _GTypeClass"][::std::mem::align_of::<_GTypeClass>() - 8usize];
    ["Offset of field: _GTypeClass::g_type"][::std::mem::offset_of!(_GTypeClass, g_type) - 0usize];
};
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInstance"][::std::mem::size_of::<_GTypeInstance>() - 8usize];
    ["Alignment of _GTypeInstance"][::std::mem::align_of::<_GTypeInstance>() - 8usize];
    ["Offset of field: _GTypeInstance::g_class"]
        [::std::mem::offset_of!(_GTypeInstance, g_class) - 0usize];
};
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInterface"][::std::mem::size_of::<_GTypeInterface>() - 16usize];
    ["Alignment of _GTypeInterface"][::std::mem::align_of::<_GTypeInterface>() - 8usize];
    ["Offset of field: _GTypeInterface::g_type"]
        [::std::mem::offset_of!(_GTypeInterface, g_type) - 0usize];
    ["Offset of field: _GTypeInterface::g_instance_type"]
        [::std::mem::offset_of!(_GTypeInterface, g_instance_type) - 8usize];
};
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeQuery"][::std::mem::size_of::<_GTypeQuery>() - 24usize];
    ["Alignment of _GTypeQuery"][::std::mem::align_of::<_GTypeQuery>() - 8usize];
    ["Offset of field: _GTypeQuery::type_"][::std::mem::offset_of!(_GTypeQuery, type_) - 0usize];
    ["Offset of field: _GTypeQuery::type_name"]
        [::std::mem::offset_of!(_GTypeQuery, type_name) - 8usize];
    ["Offset of field: _GTypeQuery::class_size"]
        [::std::mem::offset_of!(_GTypeQuery, class_size) - 16usize];
    ["Offset of field: _GTypeQuery::instance_size"]
        [::std::mem::offset_of!(_GTypeQuery, instance_size) - 20usize];
};
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
#[doc = " GTypeDebugFlags:\n @G_TYPE_DEBUG_NONE: Print no messages\n @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping\n @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions\n @G_TYPE_DEBUG_MASK: Mask covering all debug flags\n @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type\n\n These flags used to be passed to g_type_init_with_debug_flags() which\n is now deprecated.\n\n If you need to enable debugging features, use the GOBJECT_DEBUG\n environment variable.\n\n Deprecated: 2.36: g_type_init() is now done automatically"]
pub type GTypeDebugFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_type_init();
}
unsafe extern "C" {
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
unsafe extern "C" {
    pub fn g_type_name(type_: GType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_type_qname(type_: GType) -> GQuark;
}
unsafe extern "C" {
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn g_type_parent(type_: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_depth(type_: GType) -> guint;
}
unsafe extern "C" {
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_unref(g_class: gpointer);
}
unsafe extern "C" {
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
unsafe extern "C" {
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
unsafe extern "C" {
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
#[doc = " GBaseInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize\n\n A callback function used by the type system to do base initialization\n of the class structures of derived types.\n\n This function is called as part of the initialization process of all derived\n classes and should reallocate or reset all dynamic class members copied over\n from the parent class.\n\n For example, class members (such as strings) that are not sufficiently\n handled by a plain memory copy of the parent class into the derived class\n have to be altered. See GClassInitFunc() for a discussion of the class\n initialization process."]
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GBaseFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n\n A callback function used by the type system to finalize those portions\n of a derived types class structure that were setup from the corresponding\n GBaseInitFunc() function.\n\n Class finalization basically works the inverse way in which class\n initialization is performed.\n\n See GClassInitFunc() for a discussion of the class initialization process."]
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GClassInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.\n @class_data: The @class_data member supplied via the #GTypeInfo structure.\n\n A callback function used by the type system to initialize the class\n of a specific type.\n\n This function should initialize all static class members.\n\n The initialization process of a class involves:\n\n - Copying common members from the parent class over to the\n   derived class structure.\n - Zero initialization of the remaining members not copied\n   over from the parent class.\n - Invocation of the GBaseInitFunc() initializers of all parent\n   types and the class' type.\n - Invocation of the class' GClassInitFunc() initializer.\n\n Since derived classes are partially initialized through a memory copy\n of the parent class, the general rule is that GBaseInitFunc() and\n GBaseFinalizeFunc() should take care of necessary reinitialization\n and release of those class members that were introduced by the type\n that specified these GBaseInitFunc()/GBaseFinalizeFunc().\n GClassInitFunc() should only care about initializing static\n class members, while dynamic class members (such as allocated strings\n or reference counted resources) are better handled by a GBaseInitFunc()\n for this type, so proper initialization of the dynamic class members\n is performed for class initialization of derived types as well.\n\n An example may help to correspond the intend of the different class\n initializers:\n\n |[<!-- language=\"C\" -->\n typedef struct {\n   GObjectClass parent_class;\n   gint         static_integer;\n   gchar       *dynamic_string;\n } TypeAClass;\n static void\n type_a_base_class_init (TypeAClass *class)\n {\n   class->dynamic_string = g_strdup (\"some string\");\n }\n static void\n type_a_base_class_finalize (TypeAClass *class)\n {\n   g_free (class->dynamic_string);\n }\n static void\n type_a_class_init (TypeAClass *class)\n {\n   class->static_integer = 42;\n }\n\n typedef struct {\n   TypeAClass   parent_class;\n   gfloat       static_float;\n   GString     *dynamic_gstring;\n } TypeBClass;\n static void\n type_b_base_class_init (TypeBClass *class)\n {\n   class->dynamic_gstring = g_string_new (\"some other string\");\n }\n static void\n type_b_base_class_finalize (TypeBClass *class)\n {\n   g_string_free (class->dynamic_gstring);\n }\n static void\n type_b_class_init (TypeBClass *class)\n {\n   class->static_float = 3.14159265358979323846;\n }\n ]|\n\n Initialization of TypeBClass will first cause initialization of\n TypeAClass (derived classes reference their parent classes, see\n g_type_class_ref() on this).\n\n Initialization of TypeAClass roughly involves zero-initializing its fields,\n then calling its GBaseInitFunc() type_a_base_class_init() to allocate\n its dynamic members (dynamic_string), and finally calling its GClassInitFunc()\n type_a_class_init() to initialize its static members (static_integer).\n The first step in the initialization process of TypeBClass is then\n a plain memory copy of the contents of TypeAClass into TypeBClass and\n zero-initialization of the remaining fields in TypeBClass.\n The dynamic members of TypeAClass within TypeBClass now need\n reinitialization which is performed by calling type_a_base_class_init()\n with an argument of TypeBClass.\n\n After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()\n is called to allocate the dynamic members of TypeBClass (dynamic_gstring),\n and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),\n is called to complete the initialization process with the static members\n (static_float).\n\n Corresponding finalization counter parts to the GBaseInitFunc() functions\n have to be provided to release allocated resources at class finalization\n time."]
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GClassFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n @class_data: The @class_data member supplied via the #GTypeInfo structure\n\n A callback function used by the type system to finalize a class.\n\n This function is rarely needed, as dynamically allocated class resources\n should be handled by GBaseInitFunc() and GBaseFinalizeFunc().\n\n Also, specification of a GClassFinalizeFunc() in the #GTypeInfo\n structure of a static type is invalid, because classes of static types\n will never be finalized (they are artificially kept alive when their\n reference count drops to zero)."]
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GInstanceInitFunc:\n @instance: The instance to initialize\n @g_class: (type GObject.TypeClass): The class of the type the instance is\n    created for\n\n A callback function used by the type system to initialize a new\n instance of a type.\n\n This function initializes all instance members and allocates any resources\n required by it.\n\n Initialization of a derived instance involves calling all its parent\n types instance initializers, so the class member of the instance\n is altered during its initialization to always point to the class that\n belongs to the type the current initializer was introduced for.\n\n The extended members of @instance are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
#[doc = " GInterfaceInitFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to initialize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to initialize a new\n interface.\n\n This function should initialize all internal data and* allocate any\n resources required by the interface.\n\n The members of @iface_data are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GInterfaceFinalizeFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to finalize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to finalize an interface.\n\n This function should destroy any internal data and release any resources\n allocated by the corresponding GInterfaceInitFunc() function."]
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GTypeClassCacheFunc:\n @cache_data: data that was given to the g_type_add_class_cache_func() call\n @g_class: (type GObject.TypeClass): The #GTypeClass structure which is\n    unreferenced\n\n A callback function which is called when the reference count of a class\n drops to zero.\n\n It may use g_type_class_ref() to prevent the class from being freed. You\n should not call g_type_class_unref() from a #GTypeClassCacheFunc function\n to prevent infinite recursion, use g_type_class_unref_uncached() instead.\n\n The functions have to check the class id passed in to figure\n whether they actually want to cache the class of this type, since all\n classes are routed through the same #GTypeClassCacheFunc chain.\n\n Returns: %TRUE to stop further #GTypeClassCacheFuncs from being\n  called, %FALSE to continue"]
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
#[doc = " GTypeInterfaceCheckFunc:\n @check_data: data passed to g_type_add_interface_check()\n @g_iface: (type GObject.TypeInterface): the interface that has been\n    initialized\n\n A callback called after an interface vtable is initialized.\n\n See g_type_add_interface_check().\n\n Since: 2.4"]
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
#[doc = " GTypeFundamentalFlags:\n @G_TYPE_FLAG_CLASSED: Indicates a classed type\n @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)\n @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type\n @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)\n\n Bit masks used to check or determine specific characteristics of a\n fundamental type."]
pub type GTypeFundamentalFlags = ::std::os::raw::c_uint;
pub const GTypeFlags_G_TYPE_FLAG_NONE: GTypeFlags = 0;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub const GTypeFlags_G_TYPE_FLAG_FINAL: GTypeFlags = 64;
pub const GTypeFlags_G_TYPE_FLAG_DEPRECATED: GTypeFlags = 128;
#[doc = " GTypeFlags:\n @G_TYPE_FLAG_NONE: No special flags. Since: 2.74\n @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be\n  created for an abstract type\n @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type\n  that introduces a value table, but can't be used for\n  g_value_init()\n @G_TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable\n  leaf node in a deep derivable type hierarchy tree. Since: 2.70\n @G_TYPE_FLAG_DEPRECATED: The type is deprecated and may be removed in a\n  future version. A warning will be emitted if it is instantiated while\n  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76\n\n Bit masks used to check or determine characteristics of a type."]
pub type GTypeFlags = ::std::os::raw::c_uint;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInfo"][::std::mem::size_of::<_GTypeInfo>() - 72usize];
    ["Alignment of _GTypeInfo"][::std::mem::align_of::<_GTypeInfo>() - 8usize];
    ["Offset of field: _GTypeInfo::class_size"]
        [::std::mem::offset_of!(_GTypeInfo, class_size) - 0usize];
    ["Offset of field: _GTypeInfo::base_init"]
        [::std::mem::offset_of!(_GTypeInfo, base_init) - 8usize];
    ["Offset of field: _GTypeInfo::base_finalize"]
        [::std::mem::offset_of!(_GTypeInfo, base_finalize) - 16usize];
    ["Offset of field: _GTypeInfo::class_init"]
        [::std::mem::offset_of!(_GTypeInfo, class_init) - 24usize];
    ["Offset of field: _GTypeInfo::class_finalize"]
        [::std::mem::offset_of!(_GTypeInfo, class_finalize) - 32usize];
    ["Offset of field: _GTypeInfo::class_data"]
        [::std::mem::offset_of!(_GTypeInfo, class_data) - 40usize];
    ["Offset of field: _GTypeInfo::instance_size"]
        [::std::mem::offset_of!(_GTypeInfo, instance_size) - 48usize];
    ["Offset of field: _GTypeInfo::n_preallocs"]
        [::std::mem::offset_of!(_GTypeInfo, n_preallocs) - 50usize];
    ["Offset of field: _GTypeInfo::instance_init"]
        [::std::mem::offset_of!(_GTypeInfo, instance_init) - 56usize];
    ["Offset of field: _GTypeInfo::value_table"]
        [::std::mem::offset_of!(_GTypeInfo, value_table) - 64usize];
};
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeFundamentalInfo"][::std::mem::size_of::<_GTypeFundamentalInfo>() - 4usize];
    ["Alignment of _GTypeFundamentalInfo"]
        [::std::mem::align_of::<_GTypeFundamentalInfo>() - 4usize];
    ["Offset of field: _GTypeFundamentalInfo::type_flags"]
        [::std::mem::offset_of!(_GTypeFundamentalInfo, type_flags) - 0usize];
};
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInterfaceInfo"][::std::mem::size_of::<_GInterfaceInfo>() - 24usize];
    ["Alignment of _GInterfaceInfo"][::std::mem::align_of::<_GInterfaceInfo>() - 8usize];
    ["Offset of field: _GInterfaceInfo::interface_init"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_init) - 0usize];
    ["Offset of field: _GInterfaceInfo::interface_finalize"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_finalize) - 8usize];
    ["Offset of field: _GInterfaceInfo::interface_data"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_data) - 16usize];
};
#[doc = " GTypeValueTable:\n @value_init: Default initialize @values contents by poking values\n  directly into the value->data array. The data array of\n  the #GValue passed into this function was zero-filled\n  with `memset()`, so no care has to be taken to free any\n  old contents. E.g. for the implementation of a string\n  value that may never be %NULL, the implementation might\n  look like:\n  |[<!-- language=\"C\" -->\n  value->data[0].v_pointer = g_strdup (\"\");\n  ]|\n @value_free: Free any old contents that might be left in the\n  data array of the passed in @value. No resources may\n  remain allocated through the #GValue contents after\n  this function returns. E.g. for our above string type:\n  |[<!-- language=\"C\" -->\n  // only free strings without a specific flag for static storage\n  if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n    g_free (value->data[0].v_pointer);\n  ]|\n @value_copy: @dest_value is a #GValue with zero-filled data section\n  and @src_value is a properly setup #GValue of same or\n  derived type.\n  The purpose of this function is to copy the contents of\n  @src_value into @dest_value in a way, that even after\n  @src_value has been freed, the contents of @dest_value\n  remain valid. String type example:\n  |[<!-- language=\"C\" -->\n  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n  ]|\n @value_peek_pointer: If the value contents fit into a pointer, such as objects\n  or strings, return this pointer, so the caller can peek at\n  the current contents. To extend on our above string example:\n  |[<!-- language=\"C\" -->\n  return value->data[0].v_pointer;\n  ]|\n @collect_format: A string format describing how to collect the contents of\n  this value bit-by-bit. Each character in the format represents\n  an argument to be collected, and the characters themselves indicate\n  the type of the argument. Currently supported arguments are:\n  - 'i' - Integers. passed as collect_values[].v_int.\n  - 'l' - Longs. passed as collect_values[].v_long.\n  - 'd' - Doubles. passed as collect_values[].v_double.\n  - 'p' - Pointers. passed as collect_values[].v_pointer.\n  It should be noted that for variable argument list construction,\n  ANSI C promotes every type smaller than an integer to an int, and\n  floats to doubles. So for collection of short int or char, 'i'\n  needs to be used, and for collection of floats 'd'.\n @collect_value: The collect_value() function is responsible for converting the\n  values collected from a variable argument list into contents\n  suitable for storage in a GValue. This function should setup\n  @value similar to value_init(); e.g. for a string value that\n  does not allow %NULL pointers, it needs to either spew an error,\n  or do an implicit conversion by storing an empty string.\n  The @value passed in to this function has a zero-filled data\n  array, so just like for value_init() it is guaranteed to not\n  contain any old contents that might need freeing.\n  @n_collect_values is exactly the string length of @collect_format,\n  and @collect_values is an array of unions #GTypeCValue with\n  length @n_collect_values, containing the collected values\n  according to @collect_format.\n  @collect_flags is an argument provided as a hint by the caller.\n  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,\n  that the collected value contents may be considered \"static\"\n  for the duration of the @value lifetime.\n  Thus an extra copy of the contents stored in @collect_values is\n  not required for assignment to @value.\n  For our above string example, we continue with:\n  |[<!-- language=\"C\" -->\n  if (!collect_values[0].v_pointer)\n    value->data[0].v_pointer = g_strdup (\"\");\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n  {\n    value->data[0].v_pointer = collect_values[0].v_pointer;\n    // keep a flag for the value_free() implementation to not free this string\n    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n  }\n  else\n    value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n  return NULL;\n  ]|\n  It should be noted, that it is generally a bad idea to follow the\n  %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n  reentrancy requirements and reference count assertions performed\n  by the signal emission code, reference counts should always be\n  incremented for reference counted contents stored in the value->data\n  array.  To deviate from our string example for a moment, and taking\n  a look at an exemplary implementation for collect_value() of\n  #GObject:\n  |[<!-- language=\"C\" -->\n    GObject *object = G_OBJECT (collect_values[0].v_pointer);\n    g_return_val_if_fail (object != NULL,\n       g_strdup_printf (\"Object passed as invalid NULL pointer\"));\n    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n    value->data[0].v_pointer = g_object_ref (object);\n    return NULL;\n  ]|\n  The reference count for valid objects is always incremented,\n  regardless of @collect_flags. For invalid objects, the example\n  returns a newly allocated string without altering @value.\n  Upon success, collect_value() needs to return %NULL. If, however,\n  an error condition occurred, collect_value() may spew an\n  error by returning a newly allocated non-%NULL string, giving\n  a suitable description of the error condition.\n  The calling code makes no assumptions about the @value\n  contents being valid upon error returns, @value\n  is simply thrown away without further freeing. As such, it is\n  a good idea to not allocate #GValue contents, prior to returning\n  an error, however, collect_values() is not obliged to return\n  a correctly setup @value for error returns, simply because\n  any non-%NULL return is considered a fatal condition so further\n  program behaviour is undefined.\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n  analogous to @collect_format. Usually, @lcopy_format string consists\n  only of 'p's to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: This function is responsible for storing the @value contents into\n  arguments passed through a variable argument list which got\n  collected into @collect_values according to @lcopy_format.\n  @n_collect_values equals the string length of @lcopy_format,\n  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.\n  In contrast to collect_value(), lcopy_value() is obliged to\n  always properly support %G_VALUE_NOCOPY_CONTENTS.\n  Similar to collect_value() the function may prematurely abort\n  by returning a newly allocated string describing an error condition.\n  To complete the string example:\n  |[<!-- language=\"C\" -->\n  gchar **string_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (string_p != NULL,\n      g_strdup_printf (\"string location passed as NULL\"));\n  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n    *string_p = value->data[0].v_pointer;\n  else\n    *string_p = g_strdup (value->data[0].v_pointer);\n  ]|\n  And an illustrative version of lcopy_value() for\n  reference-counted types:\n  |[<!-- language=\"C\" -->\n  GObject **object_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (object_p != NULL,\n    g_strdup_printf (\"object location passed as NULL\"));\n  if (!value->data[0].v_pointer)\n    *object_p = NULL;\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n    *object_p = value->data[0].v_pointer;\n  else\n    *object_p = g_object_ref (value->data[0].v_pointer);\n  return NULL;\n  ]|\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<
        unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue),
    >,
    pub value_peek_pointer:
        ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeValueTable"][::std::mem::size_of::<_GTypeValueTable>() - 64usize];
    ["Alignment of _GTypeValueTable"][::std::mem::align_of::<_GTypeValueTable>() - 8usize];
    ["Offset of field: _GTypeValueTable::value_init"]
        [::std::mem::offset_of!(_GTypeValueTable, value_init) - 0usize];
    ["Offset of field: _GTypeValueTable::value_free"]
        [::std::mem::offset_of!(_GTypeValueTable, value_free) - 8usize];
    ["Offset of field: _GTypeValueTable::value_copy"]
        [::std::mem::offset_of!(_GTypeValueTable, value_copy) - 16usize];
    ["Offset of field: _GTypeValueTable::value_peek_pointer"]
        [::std::mem::offset_of!(_GTypeValueTable, value_peek_pointer) - 24usize];
    ["Offset of field: _GTypeValueTable::collect_format"]
        [::std::mem::offset_of!(_GTypeValueTable, collect_format) - 32usize];
    ["Offset of field: _GTypeValueTable::collect_value"]
        [::std::mem::offset_of!(_GTypeValueTable, collect_value) - 40usize];
    ["Offset of field: _GTypeValueTable::lcopy_format"]
        [::std::mem::offset_of!(_GTypeValueTable, lcopy_format) - 48usize];
    ["Offset of field: _GTypeValueTable::lcopy_value"]
        [::std::mem::offset_of!(_GTypeValueTable, lcopy_value) - 56usize];
};
unsafe extern "C" {
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
unsafe extern "C" {
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
unsafe extern "C" {
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
unsafe extern "C" {
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_interface_instantiatable_prerequisite(interface_type: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
unsafe extern "C" {
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
unsafe extern "C" {
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
unsafe extern "C" {
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
unsafe extern "C" {
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_type_ensure(type_: GType);
}
unsafe extern "C" {
    pub fn g_type_get_type_registration_serial() -> guint;
}
unsafe extern "C" {
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
unsafe extern "C" {
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
unsafe extern "C" {
    pub fn g_type_fundamental_next() -> GType;
}
unsafe extern "C" {
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
unsafe extern "C" {
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
unsafe extern "C" {
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
unsafe extern "C" {
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
unsafe extern "C" {
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
unsafe extern "C" {
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
unsafe extern "C" {
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
unsafe extern "C" {
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
unsafe extern "C" {
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
unsafe extern "C" {
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
unsafe extern "C" {
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
#[doc = " GValueTransform:\n @src_value: Source value.\n @dest_value: Target value.\n\n The type of value transformation functions which can be registered with\n g_value_register_transform_func().\n\n @dest_value will be initialized to the correct destination type."]
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue__bindgen_ty_1"][::std::mem::size_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Alignment of _GValue__bindgen_ty_1"]
        [::std::mem::align_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_long"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_long) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_ulong"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_ulong) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_float"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_float) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_double"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_double) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_pointer"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_pointer) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue"][::std::mem::size_of::<_GValue>() - 24usize];
    ["Alignment of _GValue"][::std::mem::align_of::<_GValue>() - 8usize];
    ["Offset of field: _GValue::g_type"][::std::mem::offset_of!(_GValue, g_type) - 0usize];
    ["Offset of field: _GValue::data"][::std::mem::offset_of!(_GValue, data) - 8usize];
};
unsafe extern "C" {
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_unset(value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:\n @G_PARAM_READABLE: the parameter is readable\n @G_PARAM_WRITABLE: the parameter is writable\n @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE\n @G_PARAM_CONSTRUCT: the parameter will be set upon object construction\n @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction\n @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())\n  strict validation is not required\n @G_PARAM_STATIC_NAME: the string used as name when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_NICK: the string used as nick when constructing the\n  parameter is guaranteed to remain valid and\n  unmmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this\n   property will not automatically result in a \"notify\" signal being\n   emitted: the implementation must call g_object_notify() themselves\n   in case the property actually changes.  Since: 2.42.\n @G_PARAM_PRIVATE: internal\n @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed\n  in a future version. A warning will be generated if it is used\n  while running with G_ENABLE_DIAGNOSTIC=1.\n  Since 2.26\n\n Through the #GParamFlags flag values, certain aspects of parameters\n can be configured.\n\n See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
pub type GParamSpec = _GParamSpec;
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
pub type GParamSpecClass = _GParamSpecClass;
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpec"][::std::mem::size_of::<_GParamSpec>() - 72usize];
    ["Alignment of _GParamSpec"][::std::mem::align_of::<_GParamSpec>() - 8usize];
    ["Offset of field: _GParamSpec::g_type_instance"]
        [::std::mem::offset_of!(_GParamSpec, g_type_instance) - 0usize];
    ["Offset of field: _GParamSpec::name"][::std::mem::offset_of!(_GParamSpec, name) - 8usize];
    ["Offset of field: _GParamSpec::flags"][::std::mem::offset_of!(_GParamSpec, flags) - 16usize];
    ["Offset of field: _GParamSpec::value_type"]
        [::std::mem::offset_of!(_GParamSpec, value_type) - 24usize];
    ["Offset of field: _GParamSpec::owner_type"]
        [::std::mem::offset_of!(_GParamSpec, owner_type) - 32usize];
    ["Offset of field: _GParamSpec::_nick"][::std::mem::offset_of!(_GParamSpec, _nick) - 40usize];
    ["Offset of field: _GParamSpec::_blurb"][::std::mem::offset_of!(_GParamSpec, _blurb) - 48usize];
    ["Offset of field: _GParamSpec::qdata"][::std::mem::offset_of!(_GParamSpec, qdata) - 56usize];
    ["Offset of field: _GParamSpec::ref_count"]
        [::std::mem::offset_of!(_GParamSpec, ref_count) - 64usize];
    ["Offset of field: _GParamSpec::param_id"]
        [::std::mem::offset_of!(_GParamSpec, param_id) - 68usize];
};
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
    pub value_is_valid: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *const GValue) -> gboolean,
    >,
    pub dummy: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecClass"][::std::mem::size_of::<_GParamSpecClass>() - 80usize];
    ["Alignment of _GParamSpecClass"][::std::mem::align_of::<_GParamSpecClass>() - 8usize];
    ["Offset of field: _GParamSpecClass::g_type_class"]
        [::std::mem::offset_of!(_GParamSpecClass, g_type_class) - 0usize];
    ["Offset of field: _GParamSpecClass::value_type"]
        [::std::mem::offset_of!(_GParamSpecClass, value_type) - 8usize];
    ["Offset of field: _GParamSpecClass::finalize"]
        [::std::mem::offset_of!(_GParamSpecClass, finalize) - 16usize];
    ["Offset of field: _GParamSpecClass::value_set_default"]
        [::std::mem::offset_of!(_GParamSpecClass, value_set_default) - 24usize];
    ["Offset of field: _GParamSpecClass::value_validate"]
        [::std::mem::offset_of!(_GParamSpecClass, value_validate) - 32usize];
    ["Offset of field: _GParamSpecClass::values_cmp"]
        [::std::mem::offset_of!(_GParamSpecClass, values_cmp) - 40usize];
    ["Offset of field: _GParamSpecClass::value_is_valid"]
        [::std::mem::offset_of!(_GParamSpecClass, value_is_valid) - 48usize];
    ["Offset of field: _GParamSpecClass::dummy"]
        [::std::mem::offset_of!(_GParamSpecClass, dummy) - 56usize];
};
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParameter"][::std::mem::size_of::<_GParameter>() - 32usize];
    ["Alignment of _GParameter"][::std::mem::align_of::<_GParameter>() - 8usize];
    ["Offset of field: _GParameter::name"][::std::mem::offset_of!(_GParameter, name) - 0usize];
    ["Offset of field: _GParameter::value"][::std::mem::offset_of!(_GParameter, value) - 8usize];
};
unsafe extern "C" {
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_is_valid(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
unsafe extern "C" {
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecTypeInfo"][::std::mem::size_of::<_GParamSpecTypeInfo>() - 56usize];
    ["Alignment of _GParamSpecTypeInfo"][::std::mem::align_of::<_GParamSpecTypeInfo>() - 8usize];
    ["Offset of field: _GParamSpecTypeInfo::instance_size"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, instance_size) - 0usize];
    ["Offset of field: _GParamSpecTypeInfo::n_preallocs"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, n_preallocs) - 2usize];
    ["Offset of field: _GParamSpecTypeInfo::instance_init"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, instance_init) - 8usize];
    ["Offset of field: _GParamSpecTypeInfo::value_type"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_type) - 16usize];
    ["Offset of field: _GParamSpecTypeInfo::finalize"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, finalize) - 24usize];
    ["Offset of field: _GParamSpecTypeInfo::value_set_default"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_set_default) - 32usize];
    ["Offset of field: _GParamSpecTypeInfo::value_validate"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_validate) - 40usize];
    ["Offset of field: _GParamSpecTypeInfo::values_cmp"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, values_cmp) - 48usize];
};
unsafe extern "C" {
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_param_spec_is_valid_name(name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
unsafe extern "C" {
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
    -> *mut GList;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
#[doc = " GCallback:\n\n The type used for callback functions in structure definitions and function\n signatures.\n\n This doesn't mean that all callback functions must take no  parameters and\n return void. The required signature of a callback function is determined by\n the context in which is used (e.g. the signal to which it is connected).\n\n Use G_CALLBACK() to cast the callback function to a #GCallback."]
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " GClosureNotify:\n @data: data specified when registering the notification callback\n @closure: the #GClosure on which the notification is emitted\n\n The type used for the various notification callbacks which can be registered\n on closures."]
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
#[doc = " GClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @n_param_values: the length of the @param_values array\n @param_values: (array length=n_param_values): an array of\n  #GValues holding the arguments on which to invoke the\n  callback of @closure\n @invocation_hint: (nullable): the invocation hint given as the\n  last argument to g_closure_invoke()\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n\n The type used for marshaller functions."]
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
#[doc = " GVaClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @instance: (type GObject.TypeInstance): the instance on which the closure is\n  invoked.\n @args: va_list of arguments to be passed to the closure.\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n @n_params: the length of the @param_types array\n @param_types: (array length=n_params): the #GType of each argument from\n  @args.\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
#[doc = " GCClosure:\n @closure: the #GClosure\n @callback: the callback function\n\n A #GCClosure is a specialization of #GClosure for C function callbacks."]
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GClosureNotifyData"][::std::mem::size_of::<_GClosureNotifyData>() - 16usize];
    ["Alignment of _GClosureNotifyData"][::std::mem::align_of::<_GClosureNotifyData>() - 8usize];
    ["Offset of field: _GClosureNotifyData::data"]
        [::std::mem::offset_of!(_GClosureNotifyData, data) - 0usize];
    ["Offset of field: _GClosureNotifyData::notify"]
        [::std::mem::offset_of!(_GClosureNotifyData, notify) - 8usize];
};
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GClosure"][::std::mem::size_of::<_GClosure>() - 32usize];
    ["Alignment of _GClosure"][::std::mem::align_of::<_GClosure>() - 8usize];
    ["Offset of field: _GClosure::marshal"][::std::mem::offset_of!(_GClosure, marshal) - 8usize];
    ["Offset of field: _GClosure::data"][::std::mem::offset_of!(_GClosure, data) - 16usize];
    ["Offset of field: _GClosure::notifiers"]
        [::std::mem::offset_of!(_GClosure, notifiers) - 24usize];
};
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ref_count_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ref_count_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn meta_marshal_nouse_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_meta_marshal_nouse_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_guards_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_guards_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_fnotifiers_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_fnotifiers_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_inotifiers_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_inotifiers_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_inotify_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_inotify_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn floating_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_floating_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn derivative_flag_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_derivative_flag_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_marshal_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_marshal_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_invalid_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_invalid_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCClosure"][::std::mem::size_of::<_GCClosure>() - 40usize];
    ["Alignment of _GCClosure"][::std::mem::align_of::<_GCClosure>() - 8usize];
    ["Offset of field: _GCClosure::closure"][::std::mem::offset_of!(_GCClosure, closure) - 0usize];
    ["Offset of field: _GCClosure::callback"]
        [::std::mem::offset_of!(_GCClosure, callback) - 32usize];
};
unsafe extern "C" {
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_sink(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_unref(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
unsafe extern "C" {
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
unsafe extern "C" {
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
pub type GSignalQuery = _GSignalQuery;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
pub type GSignalInvocationHint = _GSignalInvocationHint;
#[doc = " GSignalCMarshaller:\n\n This is the signature of marshaller functions, required to marshall\n arrays of parameter values to signal emissions into C language callback\n invocations.\n\n It is merely an alias to #GClosureMarshal since the #GClosure mechanism\n takes over responsibility of actual function invocation for the signal\n system."]
pub type GSignalCMarshaller = GClosureMarshal;
#[doc = " GSignalCVaMarshaller:\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GSignalCVaMarshaller = GVaClosureMarshal;
#[doc = " GSignalEmissionHook:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @n_param_values: the number of parameters to the function, including\n  the instance on which the signal was emitted.\n @param_values: (array length=n_param_values): the instance on which\n  the signal was emitted, followed by the parameters of the emission.\n @data: user data associated with the hook.\n\n A simple function pointer to get invoked when the signal is emitted.\n\n Emission hooks allow you to tie a hook to the signal type, so that it will\n trap all emissions of that signal, from any object.\n\n You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.\n\n Returns: whether it wants to stay connected. If it returns %FALSE, the signal\n  hook is disconnected (and destroyed)."]
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSignalAccumulator:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @return_accu: Accumulator to collect callback return values in, this\n  is the return value of the current signal emission.\n @handler_return: A #GValue holding the return value of the signal handler.\n @data: Callback data that was specified when creating the signal.\n\n The signal accumulator is a special callback function that can be used\n to collect return values of the various callbacks that are called\n during a signal emission.\n\n The signal accumulator is specified at signal creation time, if it is\n left %NULL, no accumulation of callback return values is performed.\n The return value of signal emissions is then the value returned by the\n last callback.\n\n Returns: The accumulator function returns whether the signal emission\n  should be aborted. Returning %TRUE will continue with\n  the signal emission. Returning %FALSE will abort the current emission.\n  Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,\n  emission will occur as normal in the CLEANUP stage and the handler's\n  return value will be accumulated."]
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub const GSignalFlags_G_SIGNAL_ACCUMULATOR_FIRST_RUN: GSignalFlags = 131072;
#[doc = " GSignalFlags:\n @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.\n @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.\n @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.\n @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in\n  emission for this very object will not be emitted recursively,\n  but instead cause the first emission to be restarted.\n @G_SIGNAL_DETAILED: This signal supports \"::detail\" appendices to the signal name\n  upon handler connections and emissions.\n @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive\n  objects from user code via g_signal_emit() and friends, without\n  the need of being embedded into extra code that performs pre or\n  post emission adjustments on the object. They can also be thought\n  of as object methods which can be called generically by\n  third-party code.\n @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.\n @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the\n   arguments, even if there are no signal handlers connected.  Since 2.30.\n @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed\n   in a future version. A warning will be generated if it is connected while\n   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.\n @G_SIGNAL_ACCUMULATOR_FIRST_RUN: Only used in #GSignalAccumulator accumulator\n   functions for the #GSignalInvocationHint::run_type field to mark the first\n   call to the accumulator function for a signal emission.  Since 2.68.\n\n The signal flags are used to specify a signal's behaviour."]
pub type GSignalFlags = ::std::os::raw::c_uint;
pub const GConnectFlags_G_CONNECT_DEFAULT: GConnectFlags = 0;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
#[doc = " GConnectFlags:\n @G_CONNECT_DEFAULT: Default behaviour (no special flags). Since: 2.74\n @G_CONNECT_AFTER: If set, the handler should be called after the\n  default handler of the signal. Normally, the handler is called before\n  the default handler.\n @G_CONNECT_SWAPPED: If set, the instance and data should be swapped when\n  calling the handler; see g_signal_connect_swapped() for an example.\n\n The connection flags are used to specify the behaviour of a signal's\n connection."]
pub type GConnectFlags = ::std::os::raw::c_uint;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
#[doc = " GSignalMatchType:\n @G_SIGNAL_MATCH_ID: The signal id must be equal.\n @G_SIGNAL_MATCH_DETAIL: The signal detail must be equal.\n @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.\n @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.\n @G_SIGNAL_MATCH_DATA: The closure data must be the same.\n @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.\n\n The match types specify what g_signal_handlers_block_matched(),\n g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()\n match signals by."]
pub type GSignalMatchType = ::std::os::raw::c_uint;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSignalInvocationHint"][::std::mem::size_of::<_GSignalInvocationHint>() - 12usize];
    ["Alignment of _GSignalInvocationHint"]
        [::std::mem::align_of::<_GSignalInvocationHint>() - 4usize];
    ["Offset of field: _GSignalInvocationHint::signal_id"]
        [::std::mem::offset_of!(_GSignalInvocationHint, signal_id) - 0usize];
    ["Offset of field: _GSignalInvocationHint::detail"]
        [::std::mem::offset_of!(_GSignalInvocationHint, detail) - 4usize];
    ["Offset of field: _GSignalInvocationHint::run_type"]
        [::std::mem::offset_of!(_GSignalInvocationHint, run_type) - 8usize];
};
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSignalQuery"][::std::mem::size_of::<_GSignalQuery>() - 56usize];
    ["Alignment of _GSignalQuery"][::std::mem::align_of::<_GSignalQuery>() - 8usize];
    ["Offset of field: _GSignalQuery::signal_id"]
        [::std::mem::offset_of!(_GSignalQuery, signal_id) - 0usize];
    ["Offset of field: _GSignalQuery::signal_name"]
        [::std::mem::offset_of!(_GSignalQuery, signal_name) - 8usize];
    ["Offset of field: _GSignalQuery::itype"]
        [::std::mem::offset_of!(_GSignalQuery, itype) - 16usize];
    ["Offset of field: _GSignalQuery::signal_flags"]
        [::std::mem::offset_of!(_GSignalQuery, signal_flags) - 24usize];
    ["Offset of field: _GSignalQuery::return_type"]
        [::std::mem::offset_of!(_GSignalQuery, return_type) - 32usize];
    ["Offset of field: _GSignalQuery::n_params"]
        [::std::mem::offset_of!(_GSignalQuery, n_params) - 40usize];
    ["Offset of field: _GSignalQuery::param_types"]
        [::std::mem::offset_of!(_GSignalQuery, param_types) - 48usize];
};
unsafe extern "C" {
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
unsafe extern "C" {
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
unsafe extern "C" {
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
unsafe extern "C" {
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
unsafe extern "C" {
    pub fn g_signal_is_valid_name(name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
unsafe extern "C" {
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
unsafe extern "C" {
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
unsafe extern "C" {
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_clear_signal_handler(handler_id_ptr: *mut gulong, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
unsafe extern "C" {
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
unsafe extern "C" {
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
unsafe extern "C" {
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
unsafe extern "C" {
    pub fn _g_signals_destroy(itype: GType);
}
unsafe extern "C" {
    pub fn g_date_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_strv_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_gstring_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_hash_table_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_byte_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_ptr_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bytes_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_type_get_gtype() -> GType;
}
unsafe extern "C" {
    pub fn g_regex_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_match_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_time_zone_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_channel_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_condition_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_builder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_dict_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_key_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_main_loop_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_main_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_source_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pollfd_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_thread_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_checksum_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_option_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_uri_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tree_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pattern_spec_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_get_gtype() -> GType;
}
#[doc = " GBoxedCopyFunc:\n @boxed: (not nullable): The boxed structure to be copied.\n\n This function is provided by the user and should produce a copy\n of the passed in boxed structure.\n\n Returns: (not nullable): The newly created copy of the boxed structure."]
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
#[doc = " GBoxedFreeFunc:\n @boxed: (not nullable): The boxed structure to be freed.\n\n This function is provided by the user and should free the boxed\n structure passed."]
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
unsafe extern "C" {
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
unsafe extern "C" {
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_closure_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_get_type() -> GType;
}
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GObject = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GObjectClass = _GObjectClass;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GInitiallyUnowned = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GInitiallyUnownedClass = _GObjectClass;
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObjectGetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: a #GValue to return the property value in\n @pspec: the #GParamSpec describing the property\n\n The type of the @get_property function of #GObjectClass."]
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectSetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: the new value for the property\n @pspec: the #GParamSpec describing the property\n\n The type of the @set_property function of #GObjectClass."]
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectFinalizeFunc:\n @object: the #GObject being finalized\n\n The type of the @finalize function of #GObjectClass."]
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
#[doc = " GWeakNotify:\n @data: data that was provided when the weak reference was established\n @where_the_object_was: the object being disposed\n\n A #GWeakNotify function can be added to an object as a callback that gets\n triggered when the object is finalized.\n\n Since the object is already being disposed when the #GWeakNotify is called,\n there's not much you could do with the object, apart from e.g. using its\n address as hash-index or the like.\n\n In particular, this means its invalid to call g_object_ref(),\n g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),\n g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls\n them on the object from this callback."]
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObject"][::std::mem::size_of::<_GObject>() - 24usize];
    ["Alignment of _GObject"][::std::mem::align_of::<_GObject>() - 8usize];
    ["Offset of field: _GObject::g_type_instance"]
        [::std::mem::offset_of!(_GObject, g_type_instance) - 0usize];
    ["Offset of field: _GObject::ref_count"][::std::mem::offset_of!(_GObject, ref_count) - 8usize];
    ["Offset of field: _GObject::qdata"][::std::mem::offset_of!(_GObject, qdata) - 16usize];
};
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub n_construct_properties: gsize,
    pub pspecs: gpointer,
    pub n_pspecs: gsize,
    pub pdummy: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectClass"][::std::mem::size_of::<_GObjectClass>() - 136usize];
    ["Alignment of _GObjectClass"][::std::mem::align_of::<_GObjectClass>() - 8usize];
    ["Offset of field: _GObjectClass::g_type_class"]
        [::std::mem::offset_of!(_GObjectClass, g_type_class) - 0usize];
    ["Offset of field: _GObjectClass::construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, construct_properties) - 8usize];
    ["Offset of field: _GObjectClass::constructor"]
        [::std::mem::offset_of!(_GObjectClass, constructor) - 16usize];
    ["Offset of field: _GObjectClass::set_property"]
        [::std::mem::offset_of!(_GObjectClass, set_property) - 24usize];
    ["Offset of field: _GObjectClass::get_property"]
        [::std::mem::offset_of!(_GObjectClass, get_property) - 32usize];
    ["Offset of field: _GObjectClass::dispose"]
        [::std::mem::offset_of!(_GObjectClass, dispose) - 40usize];
    ["Offset of field: _GObjectClass::finalize"]
        [::std::mem::offset_of!(_GObjectClass, finalize) - 48usize];
    ["Offset of field: _GObjectClass::dispatch_properties_changed"]
        [::std::mem::offset_of!(_GObjectClass, dispatch_properties_changed) - 56usize];
    ["Offset of field: _GObjectClass::notify"]
        [::std::mem::offset_of!(_GObjectClass, notify) - 64usize];
    ["Offset of field: _GObjectClass::constructed"]
        [::std::mem::offset_of!(_GObjectClass, constructed) - 72usize];
    ["Offset of field: _GObjectClass::flags"]
        [::std::mem::offset_of!(_GObjectClass, flags) - 80usize];
    ["Offset of field: _GObjectClass::n_construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, n_construct_properties) - 88usize];
    ["Offset of field: _GObjectClass::pspecs"]
        [::std::mem::offset_of!(_GObjectClass, pspecs) - 96usize];
    ["Offset of field: _GObjectClass::n_pspecs"]
        [::std::mem::offset_of!(_GObjectClass, n_pspecs) - 104usize];
    ["Offset of field: _GObjectClass::pdummy"]
        [::std::mem::offset_of!(_GObjectClass, pdummy) - 112usize];
};
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectConstructParam"][::std::mem::size_of::<_GObjectConstructParam>() - 16usize];
    ["Alignment of _GObjectConstructParam"]
        [::std::mem::align_of::<_GObjectConstructParam>() - 8usize];
    ["Offset of field: _GObjectConstructParam::pspec"]
        [::std::mem::offset_of!(_GObjectConstructParam, pspec) - 0usize];
    ["Offset of field: _GObjectConstructParam::value"]
        [::std::mem::offset_of!(_GObjectConstructParam, value) - 8usize];
};
unsafe extern "C" {
    #[doc = " GInitiallyUnowned:\n\n A type for objects that have an initially floating reference.\n\n All the fields in the `GInitiallyUnowned` structure are private to the\n implementation and should never be accessed directly.\n/\n/**\n GInitiallyUnownedClass:\n\n The class structure for the GInitiallyUnowned type."]
    pub fn g_initially_unowned_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_freeze_notify(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_object_thaw_notify(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_take_ref(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_unref(object: gpointer);
}
unsafe extern "C" {
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
unsafe extern "C" {
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
#[doc = " GToggleNotify:\n @data: Callback data passed to g_object_add_toggle_ref()\n @object: The object on which g_object_add_toggle_ref() was called.\n @is_last_ref: %TRUE if the toggle reference is now the\n  last reference to the object. %FALSE if the toggle\n  reference was the last reference and there are now other\n  references.\n\n A callback function used for notification when the state\n of a toggle reference changes.\n\n See also: g_object_add_toggle_ref()"]
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
unsafe extern "C" {
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_object_force_floating(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_run_dispose(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GWeakRef__bindgen_ty_1"][::std::mem::size_of::<GWeakRef__bindgen_ty_1>() - 8usize];
    ["Alignment of GWeakRef__bindgen_ty_1"]
        [::std::mem::align_of::<GWeakRef__bindgen_ty_1>() - 8usize];
    ["Offset of field: GWeakRef__bindgen_ty_1::p"]
        [::std::mem::offset_of!(GWeakRef__bindgen_ty_1, p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GWeakRef"][::std::mem::size_of::<GWeakRef>() - 8usize];
    ["Alignment of GWeakRef"][::std::mem::align_of::<GWeakRef>() - 8usize];
    ["Offset of field: GWeakRef::priv_"][::std::mem::offset_of!(GWeakRef, priv_) - 0usize];
};
unsafe extern "C" {
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
unsafe extern "C" {
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
unsafe extern "C" {
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
unsafe extern "C" {
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
#[doc = " GBinding:\n\n GBinding is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.26"]
pub type GBinding = _GBinding;
#[doc = " GBindingTransformFunc:\n @binding: a #GBinding\n @from_value: the #GValue containing the value to transform\n @to_value: the #GValue in which to store the transformed value\n @user_data: data passed to the transform function\n\n A function to be called to transform @from_value to @to_value.\n\n If this is the @transform_to function of a binding, then @from_value\n is the @source_property on the @source object, and @to_value is the\n @target_property on the @target object. If this is the\n @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,\n then those roles are reversed.\n\n Returns: %TRUE if the transformation was successful, and %FALSE\n   otherwise\n\n Since: 2.26"]
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
#[doc = " GBindingFlags:\n @G_BINDING_DEFAULT: The default binding; if the source property\n   changes, the target property is updated with its value.\n @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the\n   property of the source or the property of the target changes,\n   the other is updated.\n @G_BINDING_SYNC_CREATE: Synchronize the values of the source and\n   target properties when creating the binding; the direction of\n   the synchronization is always from the source to the target.\n @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are\n   booleans, setting one to %TRUE will result in the other being\n   set to %FALSE and vice versa. This flag will only work for\n   boolean properties, and cannot be used when passing custom\n   transformation functions to g_object_bind_property_full().\n\n Flags to be passed to g_object_bind_property() or\n g_object_bind_property_full().\n\n This enumeration can be extended at later date.\n\n Since: 2.26"]
pub type GBindingFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_binding_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
unsafe extern "C" {
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_dup_source(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_dup_target(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_binding_unbind(binding: *mut GBinding);
}
unsafe extern "C" {
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
unsafe extern "C" {
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
unsafe extern "C" {
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBindingGroup {
    _unused: [u8; 0],
}
#[doc = " GBindingGroup:\n\n GBindingGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GBindingGroup = _GBindingGroup;
unsafe extern "C" {
    pub fn g_binding_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_group_new() -> *mut GBindingGroup;
}
unsafe extern "C" {
    pub fn g_binding_group_dup_source(self_: *mut GBindingGroup) -> gpointer;
}
unsafe extern "C" {
    pub fn g_binding_group_set_source(self_: *mut GBindingGroup, source: gpointer);
}
unsafe extern "C" {
    pub fn g_binding_group_bind(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    );
}
unsafe extern "C" {
    pub fn g_binding_group_bind_full(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        user_data_destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_binding_group_bind_with_closures(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    );
}
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
pub type GEnumClass = _GEnumClass;
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
pub type GFlagsClass = _GFlagsClass;
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
pub type GEnumValue = _GEnumValue;
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
pub type GFlagsValue = _GFlagsValue;
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEnumClass"][::std::mem::size_of::<_GEnumClass>() - 32usize];
    ["Alignment of _GEnumClass"][::std::mem::align_of::<_GEnumClass>() - 8usize];
    ["Offset of field: _GEnumClass::g_type_class"]
        [::std::mem::offset_of!(_GEnumClass, g_type_class) - 0usize];
    ["Offset of field: _GEnumClass::minimum"]
        [::std::mem::offset_of!(_GEnumClass, minimum) - 8usize];
    ["Offset of field: _GEnumClass::maximum"]
        [::std::mem::offset_of!(_GEnumClass, maximum) - 12usize];
    ["Offset of field: _GEnumClass::n_values"]
        [::std::mem::offset_of!(_GEnumClass, n_values) - 16usize];
    ["Offset of field: _GEnumClass::values"][::std::mem::offset_of!(_GEnumClass, values) - 24usize];
};
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFlagsClass"][::std::mem::size_of::<_GFlagsClass>() - 24usize];
    ["Alignment of _GFlagsClass"][::std::mem::align_of::<_GFlagsClass>() - 8usize];
    ["Offset of field: _GFlagsClass::g_type_class"]
        [::std::mem::offset_of!(_GFlagsClass, g_type_class) - 0usize];
    ["Offset of field: _GFlagsClass::mask"][::std::mem::offset_of!(_GFlagsClass, mask) - 8usize];
    ["Offset of field: _GFlagsClass::n_values"]
        [::std::mem::offset_of!(_GFlagsClass, n_values) - 12usize];
    ["Offset of field: _GFlagsClass::values"]
        [::std::mem::offset_of!(_GFlagsClass, values) - 16usize];
};
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEnumValue"][::std::mem::size_of::<_GEnumValue>() - 24usize];
    ["Alignment of _GEnumValue"][::std::mem::align_of::<_GEnumValue>() - 8usize];
    ["Offset of field: _GEnumValue::value"][::std::mem::offset_of!(_GEnumValue, value) - 0usize];
    ["Offset of field: _GEnumValue::value_name"]
        [::std::mem::offset_of!(_GEnumValue, value_name) - 8usize];
    ["Offset of field: _GEnumValue::value_nick"]
        [::std::mem::offset_of!(_GEnumValue, value_nick) - 16usize];
};
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFlagsValue"][::std::mem::size_of::<_GFlagsValue>() - 24usize];
    ["Alignment of _GFlagsValue"][::std::mem::align_of::<_GFlagsValue>() - 8usize];
    ["Offset of field: _GFlagsValue::value"][::std::mem::offset_of!(_GFlagsValue, value) - 0usize];
    ["Offset of field: _GFlagsValue::value_name"]
        [::std::mem::offset_of!(_GFlagsValue, value_name) - 8usize];
    ["Offset of field: _GFlagsValue::value_nick"]
        [::std::mem::offset_of!(_GFlagsValue, value_nick) - 16usize];
};
unsafe extern "C" {
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
    -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
unsafe extern "C" {
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
unsafe extern "C" {
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
unsafe extern "C" {
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
unsafe extern "C" {
    pub fn g_unicode_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unicode_break_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unicode_script_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_normalize_mode_get_type() -> GType;
}
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
pub type GParamSpecChar = _GParamSpecChar;
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
pub type GParamSpecUChar = _GParamSpecUChar;
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
pub type GParamSpecBoolean = _GParamSpecBoolean;
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
pub type GParamSpecInt = _GParamSpecInt;
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
pub type GParamSpecUInt = _GParamSpecUInt;
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
pub type GParamSpecLong = _GParamSpecLong;
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
pub type GParamSpecULong = _GParamSpecULong;
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
pub type GParamSpecInt64 = _GParamSpecInt64;
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
pub type GParamSpecUInt64 = _GParamSpecUInt64;
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
pub type GParamSpecUnichar = _GParamSpecUnichar;
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
pub type GParamSpecEnum = _GParamSpecEnum;
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
pub type GParamSpecFlags = _GParamSpecFlags;
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
pub type GParamSpecFloat = _GParamSpecFloat;
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
pub type GParamSpecDouble = _GParamSpecDouble;
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
pub type GParamSpecString = _GParamSpecString;
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
pub type GParamSpecParam = _GParamSpecParam;
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
pub type GParamSpecBoxed = _GParamSpecBoxed;
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
pub type GParamSpecPointer = _GParamSpecPointer;
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
pub type GParamSpecValueArray = _GParamSpecValueArray;
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
pub type GParamSpecObject = _GParamSpecObject;
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
pub type GParamSpecOverride = _GParamSpecOverride;
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
pub type GParamSpecGType = _GParamSpecGType;
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
pub type GParamSpecVariant = _GParamSpecVariant;
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecChar"][::std::mem::size_of::<_GParamSpecChar>() - 80usize];
    ["Alignment of _GParamSpecChar"][::std::mem::align_of::<_GParamSpecChar>() - 8usize];
    ["Offset of field: _GParamSpecChar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecChar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecChar::minimum"]
        [::std::mem::offset_of!(_GParamSpecChar, minimum) - 72usize];
    ["Offset of field: _GParamSpecChar::maximum"]
        [::std::mem::offset_of!(_GParamSpecChar, maximum) - 73usize];
    ["Offset of field: _GParamSpecChar::default_value"]
        [::std::mem::offset_of!(_GParamSpecChar, default_value) - 74usize];
};
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUChar"][::std::mem::size_of::<_GParamSpecUChar>() - 80usize];
    ["Alignment of _GParamSpecUChar"][::std::mem::align_of::<_GParamSpecUChar>() - 8usize];
    ["Offset of field: _GParamSpecUChar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUChar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUChar::minimum"]
        [::std::mem::offset_of!(_GParamSpecUChar, minimum) - 72usize];
    ["Offset of field: _GParamSpecUChar::maximum"]
        [::std::mem::offset_of!(_GParamSpecUChar, maximum) - 73usize];
    ["Offset of field: _GParamSpecUChar::default_value"]
        [::std::mem::offset_of!(_GParamSpecUChar, default_value) - 74usize];
};
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecBoolean"][::std::mem::size_of::<_GParamSpecBoolean>() - 80usize];
    ["Alignment of _GParamSpecBoolean"][::std::mem::align_of::<_GParamSpecBoolean>() - 8usize];
    ["Offset of field: _GParamSpecBoolean::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecBoolean, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecBoolean::default_value"]
        [::std::mem::offset_of!(_GParamSpecBoolean, default_value) - 72usize];
};
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecInt"][::std::mem::size_of::<_GParamSpecInt>() - 88usize];
    ["Alignment of _GParamSpecInt"][::std::mem::align_of::<_GParamSpecInt>() - 8usize];
    ["Offset of field: _GParamSpecInt::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecInt, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecInt::minimum"]
        [::std::mem::offset_of!(_GParamSpecInt, minimum) - 72usize];
    ["Offset of field: _GParamSpecInt::maximum"]
        [::std::mem::offset_of!(_GParamSpecInt, maximum) - 76usize];
    ["Offset of field: _GParamSpecInt::default_value"]
        [::std::mem::offset_of!(_GParamSpecInt, default_value) - 80usize];
};
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUInt"][::std::mem::size_of::<_GParamSpecUInt>() - 88usize];
    ["Alignment of _GParamSpecUInt"][::std::mem::align_of::<_GParamSpecUInt>() - 8usize];
    ["Offset of field: _GParamSpecUInt::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUInt, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUInt::minimum"]
        [::std::mem::offset_of!(_GParamSpecUInt, minimum) - 72usize];
    ["Offset of field: _GParamSpecUInt::maximum"]
        [::std::mem::offset_of!(_GParamSpecUInt, maximum) - 76usize];
    ["Offset of field: _GParamSpecUInt::default_value"]
        [::std::mem::offset_of!(_GParamSpecUInt, default_value) - 80usize];
};
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecLong"][::std::mem::size_of::<_GParamSpecLong>() - 96usize];
    ["Alignment of _GParamSpecLong"][::std::mem::align_of::<_GParamSpecLong>() - 8usize];
    ["Offset of field: _GParamSpecLong::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecLong, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecLong::minimum"]
        [::std::mem::offset_of!(_GParamSpecLong, minimum) - 72usize];
    ["Offset of field: _GParamSpecLong::maximum"]
        [::std::mem::offset_of!(_GParamSpecLong, maximum) - 80usize];
    ["Offset of field: _GParamSpecLong::default_value"]
        [::std::mem::offset_of!(_GParamSpecLong, default_value) - 88usize];
};
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecULong"][::std::mem::size_of::<_GParamSpecULong>() - 96usize];
    ["Alignment of _GParamSpecULong"][::std::mem::align_of::<_GParamSpecULong>() - 8usize];
    ["Offset of field: _GParamSpecULong::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecULong, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecULong::minimum"]
        [::std::mem::offset_of!(_GParamSpecULong, minimum) - 72usize];
    ["Offset of field: _GParamSpecULong::maximum"]
        [::std::mem::offset_of!(_GParamSpecULong, maximum) - 80usize];
    ["Offset of field: _GParamSpecULong::default_value"]
        [::std::mem::offset_of!(_GParamSpecULong, default_value) - 88usize];
};
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecInt64"][::std::mem::size_of::<_GParamSpecInt64>() - 96usize];
    ["Alignment of _GParamSpecInt64"][::std::mem::align_of::<_GParamSpecInt64>() - 8usize];
    ["Offset of field: _GParamSpecInt64::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecInt64, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecInt64::minimum"]
        [::std::mem::offset_of!(_GParamSpecInt64, minimum) - 72usize];
    ["Offset of field: _GParamSpecInt64::maximum"]
        [::std::mem::offset_of!(_GParamSpecInt64, maximum) - 80usize];
    ["Offset of field: _GParamSpecInt64::default_value"]
        [::std::mem::offset_of!(_GParamSpecInt64, default_value) - 88usize];
};
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUInt64"][::std::mem::size_of::<_GParamSpecUInt64>() - 96usize];
    ["Alignment of _GParamSpecUInt64"][::std::mem::align_of::<_GParamSpecUInt64>() - 8usize];
    ["Offset of field: _GParamSpecUInt64::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUInt64, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUInt64::minimum"]
        [::std::mem::offset_of!(_GParamSpecUInt64, minimum) - 72usize];
    ["Offset of field: _GParamSpecUInt64::maximum"]
        [::std::mem::offset_of!(_GParamSpecUInt64, maximum) - 80usize];
    ["Offset of field: _GParamSpecUInt64::default_value"]
        [::std::mem::offset_of!(_GParamSpecUInt64, default_value) - 88usize];
};
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUnichar"][::std::mem::size_of::<_GParamSpecUnichar>() - 80usize];
    ["Alignment of _GParamSpecUnichar"][::std::mem::align_of::<_GParamSpecUnichar>() - 8usize];
    ["Offset of field: _GParamSpecUnichar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUnichar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUnichar::default_value"]
        [::std::mem::offset_of!(_GParamSpecUnichar, default_value) - 72usize];
};
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecEnum"][::std::mem::size_of::<_GParamSpecEnum>() - 88usize];
    ["Alignment of _GParamSpecEnum"][::std::mem::align_of::<_GParamSpecEnum>() - 8usize];
    ["Offset of field: _GParamSpecEnum::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecEnum, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecEnum::enum_class"]
        [::std::mem::offset_of!(_GParamSpecEnum, enum_class) - 72usize];
    ["Offset of field: _GParamSpecEnum::default_value"]
        [::std::mem::offset_of!(_GParamSpecEnum, default_value) - 80usize];
};
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecFlags"][::std::mem::size_of::<_GParamSpecFlags>() - 88usize];
    ["Alignment of _GParamSpecFlags"][::std::mem::align_of::<_GParamSpecFlags>() - 8usize];
    ["Offset of field: _GParamSpecFlags::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecFlags, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecFlags::flags_class"]
        [::std::mem::offset_of!(_GParamSpecFlags, flags_class) - 72usize];
    ["Offset of field: _GParamSpecFlags::default_value"]
        [::std::mem::offset_of!(_GParamSpecFlags, default_value) - 80usize];
};
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecFloat"][::std::mem::size_of::<_GParamSpecFloat>() - 88usize];
    ["Alignment of _GParamSpecFloat"][::std::mem::align_of::<_GParamSpecFloat>() - 8usize];
    ["Offset of field: _GParamSpecFloat::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecFloat, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecFloat::minimum"]
        [::std::mem::offset_of!(_GParamSpecFloat, minimum) - 72usize];
    ["Offset of field: _GParamSpecFloat::maximum"]
        [::std::mem::offset_of!(_GParamSpecFloat, maximum) - 76usize];
    ["Offset of field: _GParamSpecFloat::default_value"]
        [::std::mem::offset_of!(_GParamSpecFloat, default_value) - 80usize];
    ["Offset of field: _GParamSpecFloat::epsilon"]
        [::std::mem::offset_of!(_GParamSpecFloat, epsilon) - 84usize];
};
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecDouble"][::std::mem::size_of::<_GParamSpecDouble>() - 104usize];
    ["Alignment of _GParamSpecDouble"][::std::mem::align_of::<_GParamSpecDouble>() - 8usize];
    ["Offset of field: _GParamSpecDouble::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecDouble, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecDouble::minimum"]
        [::std::mem::offset_of!(_GParamSpecDouble, minimum) - 72usize];
    ["Offset of field: _GParamSpecDouble::maximum"]
        [::std::mem::offset_of!(_GParamSpecDouble, maximum) - 80usize];
    ["Offset of field: _GParamSpecDouble::default_value"]
        [::std::mem::offset_of!(_GParamSpecDouble, default_value) - 88usize];
    ["Offset of field: _GParamSpecDouble::epsilon"]
        [::std::mem::offset_of!(_GParamSpecDouble, epsilon) - 96usize];
};
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecString"][::std::mem::size_of::<_GParamSpecString>() - 104usize];
    ["Alignment of _GParamSpecString"][::std::mem::align_of::<_GParamSpecString>() - 8usize];
    ["Offset of field: _GParamSpecString::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecString, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecString::default_value"]
        [::std::mem::offset_of!(_GParamSpecString, default_value) - 72usize];
    ["Offset of field: _GParamSpecString::cset_first"]
        [::std::mem::offset_of!(_GParamSpecString, cset_first) - 80usize];
    ["Offset of field: _GParamSpecString::cset_nth"]
        [::std::mem::offset_of!(_GParamSpecString, cset_nth) - 88usize];
    ["Offset of field: _GParamSpecString::substitutor"]
        [::std::mem::offset_of!(_GParamSpecString, substitutor) - 96usize];
};
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn null_fold_if_empty_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_null_fold_if_empty_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ensure_non_null_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ensure_non_null_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecParam"][::std::mem::size_of::<_GParamSpecParam>() - 72usize];
    ["Alignment of _GParamSpecParam"][::std::mem::align_of::<_GParamSpecParam>() - 8usize];
    ["Offset of field: _GParamSpecParam::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecParam, parent_instance) - 0usize];
};
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecBoxed"][::std::mem::size_of::<_GParamSpecBoxed>() - 72usize];
    ["Alignment of _GParamSpecBoxed"][::std::mem::align_of::<_GParamSpecBoxed>() - 8usize];
    ["Offset of field: _GParamSpecBoxed::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecBoxed, parent_instance) - 0usize];
};
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecPointer"][::std::mem::size_of::<_GParamSpecPointer>() - 72usize];
    ["Alignment of _GParamSpecPointer"][::std::mem::align_of::<_GParamSpecPointer>() - 8usize];
    ["Offset of field: _GParamSpecPointer::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecPointer, parent_instance) - 0usize];
};
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecValueArray"][::std::mem::size_of::<_GParamSpecValueArray>() - 88usize];
    ["Alignment of _GParamSpecValueArray"]
        [::std::mem::align_of::<_GParamSpecValueArray>() - 8usize];
    ["Offset of field: _GParamSpecValueArray::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecValueArray, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecValueArray::element_spec"]
        [::std::mem::offset_of!(_GParamSpecValueArray, element_spec) - 72usize];
    ["Offset of field: _GParamSpecValueArray::fixed_n_elements"]
        [::std::mem::offset_of!(_GParamSpecValueArray, fixed_n_elements) - 80usize];
};
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecObject"][::std::mem::size_of::<_GParamSpecObject>() - 72usize];
    ["Alignment of _GParamSpecObject"][::std::mem::align_of::<_GParamSpecObject>() - 8usize];
    ["Offset of field: _GParamSpecObject::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecObject, parent_instance) - 0usize];
};
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecOverride"][::std::mem::size_of::<_GParamSpecOverride>() - 80usize];
    ["Alignment of _GParamSpecOverride"][::std::mem::align_of::<_GParamSpecOverride>() - 8usize];
    ["Offset of field: _GParamSpecOverride::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecOverride, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecOverride::overridden"]
        [::std::mem::offset_of!(_GParamSpecOverride, overridden) - 72usize];
};
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecGType"][::std::mem::size_of::<_GParamSpecGType>() - 80usize];
    ["Alignment of _GParamSpecGType"][::std::mem::align_of::<_GParamSpecGType>() - 8usize];
    ["Offset of field: _GParamSpecGType::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecGType, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecGType::is_a_type"]
        [::std::mem::offset_of!(_GParamSpecGType, is_a_type) - 72usize];
};
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecVariant"][::std::mem::size_of::<_GParamSpecVariant>() - 120usize];
    ["Alignment of _GParamSpecVariant"][::std::mem::align_of::<_GParamSpecVariant>() - 8usize];
    ["Offset of field: _GParamSpecVariant::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecVariant, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecVariant::type_"]
        [::std::mem::offset_of!(_GParamSpecVariant, type_) - 72usize];
    ["Offset of field: _GParamSpecVariant::default_value"]
        [::std::mem::offset_of!(_GParamSpecVariant, default_value) - 80usize];
    ["Offset of field: _GParamSpecVariant::padding"]
        [::std::mem::offset_of!(_GParamSpecVariant, padding) - 88usize];
};
unsafe extern "C" {
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub static mut g_param_spec_types: *mut GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalGroup {
    _unused: [u8; 0],
}
#[doc = " GSignalGroup:\n\n #GSignalGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GSignalGroup = _GSignalGroup;
unsafe extern "C" {
    pub fn g_signal_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_signal_group_new(target_type: GType) -> *mut GSignalGroup;
}
unsafe extern "C" {
    pub fn g_signal_group_set_target(self_: *mut GSignalGroup, target: gpointer);
}
unsafe extern "C" {
    pub fn g_signal_group_dup_target(self_: *mut GSignalGroup) -> gpointer;
}
unsafe extern "C" {
    pub fn g_signal_group_block(self_: *mut GSignalGroup);
}
unsafe extern "C" {
    pub fn g_signal_group_unblock(self_: *mut GSignalGroup);
}
unsafe extern "C" {
    pub fn g_signal_group_connect_closure(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_object(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        object: gpointer,
        flags: GConnectFlags,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_data(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        notify: GClosureNotify,
        flags: GConnectFlags,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_after(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_swapped(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
pub type GTypeModule = _GTypeModule;
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
pub type GTypeModule_listautoptr = *mut GList;
pub type GTypeModule_slistautoptr = *mut GSList;
pub type GTypeModule_queueautoptr = *mut GQueue;
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeModule"][::std::mem::size_of::<_GTypeModule>() - 56usize];
    ["Alignment of _GTypeModule"][::std::mem::align_of::<_GTypeModule>() - 8usize];
    ["Offset of field: _GTypeModule::parent_instance"]
        [::std::mem::offset_of!(_GTypeModule, parent_instance) - 0usize];
    ["Offset of field: _GTypeModule::use_count"]
        [::std::mem::offset_of!(_GTypeModule, use_count) - 24usize];
    ["Offset of field: _GTypeModule::type_infos"]
        [::std::mem::offset_of!(_GTypeModule, type_infos) - 32usize];
    ["Offset of field: _GTypeModule::interface_infos"]
        [::std::mem::offset_of!(_GTypeModule, interface_infos) - 40usize];
    ["Offset of field: _GTypeModule::name"][::std::mem::offset_of!(_GTypeModule, name) - 48usize];
};
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeModuleClass"][::std::mem::size_of::<_GTypeModuleClass>() - 184usize];
    ["Alignment of _GTypeModuleClass"][::std::mem::align_of::<_GTypeModuleClass>() - 8usize];
    ["Offset of field: _GTypeModuleClass::parent_class"]
        [::std::mem::offset_of!(_GTypeModuleClass, parent_class) - 0usize];
    ["Offset of field: _GTypeModuleClass::load"]
        [::std::mem::offset_of!(_GTypeModuleClass, load) - 136usize];
    ["Offset of field: _GTypeModuleClass::unload"]
        [::std::mem::offset_of!(_GTypeModuleClass, unload) - 144usize];
    ["Offset of field: _GTypeModuleClass::reserved1"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved1) - 152usize];
    ["Offset of field: _GTypeModuleClass::reserved2"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved2) - 160usize];
    ["Offset of field: _GTypeModuleClass::reserved3"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved3) - 168usize];
    ["Offset of field: _GTypeModuleClass::reserved4"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved4) - 176usize];
};
unsafe extern "C" {
    pub fn g_type_module_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
unsafe extern "C" {
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
unsafe extern "C" {
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
unsafe extern "C" {
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
pub type GTypePluginClass = _GTypePluginClass;
#[doc = " GTypePluginUse:\n @plugin: the #GTypePlugin whose use count should be increased\n\n The type of the @use_plugin function of #GTypePluginClass, which gets called\n to increase the use count of @plugin."]
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginUnuse:\n @plugin: the #GTypePlugin whose use count should be decreased\n\n The type of the @unuse_plugin function of #GTypePluginClass."]
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginCompleteTypeInfo:\n @plugin: the #GTypePlugin\n @g_type: the #GType whose info is completed\n @info: the #GTypeInfo struct to fill in\n @value_table: the #GTypeValueTable to fill in\n\n The type of the @complete_type_info function of #GTypePluginClass."]
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
#[doc = " GTypePluginCompleteInterfaceInfo:\n @plugin: the #GTypePlugin\n @instance_type: the #GType of an instantiatable type to which the interface\n  is added\n @interface_type: the #GType of the interface whose info is completed\n @info: the #GInterfaceInfo to fill in\n\n The type of the @complete_interface_info function of #GTypePluginClass."]
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypePluginClass"][::std::mem::size_of::<_GTypePluginClass>() - 48usize];
    ["Alignment of _GTypePluginClass"][::std::mem::align_of::<_GTypePluginClass>() - 8usize];
    ["Offset of field: _GTypePluginClass::base_iface"]
        [::std::mem::offset_of!(_GTypePluginClass, base_iface) - 0usize];
    ["Offset of field: _GTypePluginClass::use_plugin"]
        [::std::mem::offset_of!(_GTypePluginClass, use_plugin) - 16usize];
    ["Offset of field: _GTypePluginClass::unuse_plugin"]
        [::std::mem::offset_of!(_GTypePluginClass, unuse_plugin) - 24usize];
    ["Offset of field: _GTypePluginClass::complete_type_info"]
        [::std::mem::offset_of!(_GTypePluginClass, complete_type_info) - 32usize];
    ["Offset of field: _GTypePluginClass::complete_interface_info"]
        [::std::mem::offset_of!(_GTypePluginClass, complete_interface_info) - 40usize];
};
unsafe extern "C" {
    pub fn g_type_plugin_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
unsafe extern "C" {
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
unsafe extern "C" {
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
unsafe extern "C" {
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
pub type GValueArray = _GValueArray;
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValueArray"][::std::mem::size_of::<_GValueArray>() - 24usize];
    ["Alignment of _GValueArray"][::std::mem::align_of::<_GValueArray>() - 8usize];
    ["Offset of field: _GValueArray::n_values"]
        [::std::mem::offset_of!(_GValueArray, n_values) - 0usize];
    ["Offset of field: _GValueArray::values"]
        [::std::mem::offset_of!(_GValueArray, values) - 8usize];
    ["Offset of field: _GValueArray::n_prealloced"]
        [::std::mem::offset_of!(_GValueArray, n_prealloced) - 16usize];
};
unsafe extern "C" {
    pub fn g_value_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
unsafe extern "C" {
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
unsafe extern "C" {
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
unsafe extern "C" {
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
unsafe extern "C" {
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
unsafe extern "C" {
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
unsafe extern "C" {
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
unsafe extern "C" {
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
unsafe extern "C" {
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
unsafe extern "C" {
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
unsafe extern "C" {
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
unsafe extern "C" {
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
unsafe extern "C" {
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
unsafe extern "C" {
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
unsafe extern "C" {
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
unsafe extern "C" {
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
unsafe extern "C" {
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
unsafe extern "C" {
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
unsafe extern "C" {
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
unsafe extern "C" {
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
unsafe extern "C" {
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
unsafe extern "C" {
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
unsafe extern "C" {
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_set_interned_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
unsafe extern "C" {
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_gtype_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
unsafe extern "C" {
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
unsafe extern "C" {
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
unsafe extern "C" {
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
#[doc = " gchararray:\n\n A C representable type name for %G_TYPE_STRING."]
pub type gchararray = *mut gchar;
pub type GClosure_autoptr = *mut GClosure;
pub type GClosure_listautoptr = *mut GList;
pub type GClosure_slistautoptr = *mut GSList;
pub type GClosure_queueautoptr = *mut GQueue;
pub type GEnumClass_autoptr = *mut GEnumClass;
pub type GEnumClass_listautoptr = *mut GList;
pub type GEnumClass_slistautoptr = *mut GSList;
pub type GEnumClass_queueautoptr = *mut GQueue;
pub type GFlagsClass_autoptr = *mut GFlagsClass;
pub type GFlagsClass_listautoptr = *mut GList;
pub type GFlagsClass_slistautoptr = *mut GSList;
pub type GFlagsClass_queueautoptr = *mut GQueue;
pub type GObject_autoptr = *mut GObject;
pub type GObject_listautoptr = *mut GList;
pub type GObject_slistautoptr = *mut GSList;
pub type GObject_queueautoptr = *mut GQueue;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type GInitiallyUnowned_listautoptr = *mut GList;
pub type GInitiallyUnowned_slistautoptr = *mut GSList;
pub type GInitiallyUnowned_queueautoptr = *mut GQueue;
pub type GParamSpec_autoptr = *mut GParamSpec;
pub type GParamSpec_listautoptr = *mut GList;
pub type GParamSpec_slistautoptr = *mut GSList;
pub type GParamSpec_queueautoptr = *mut GQueue;
pub type GTypeClass_autoptr = *mut GTypeClass;
pub type GTypeClass_listautoptr = *mut GList;
pub type GTypeClass_slistautoptr = *mut GSList;
pub type GTypeClass_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_allocator_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bin_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_copy_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_acquire_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bus_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bus_sync_reply_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_caps_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_caps_intersect_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_clock_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_clock_entry_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_clock_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_debug_graph_details_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_state_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_state_change_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_state_change_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_element_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_core_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_library_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_resource_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_event_type_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_event_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_qos_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_gap_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_debug_level_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_debug_color_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stack_trace_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_debug_color_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_iterator_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_iterator_item_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_memory_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_map_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_message_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_structure_change_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_status_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_progress_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_meta_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_mini_object_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_lock_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_object_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_direction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_link_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_flow_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_link_check_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_probe_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_probe_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_presence_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_template_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_parse_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_parse_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pipeline_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_dependency_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_rank_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_promise_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_query_type_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_query_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffering_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_scheduling_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_seek_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_seek_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_segment_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_serialize_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_clock_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_merge_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_flag_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_scope_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_task_state_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_scope_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_entry_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_loop_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tracer_value_scope_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tracer_value_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_type_find_probability_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_uri_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_uri_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_search_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_api_flags_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAtomicQueue {
    _unused: [u8; 0],
}
#[doc = " GstAtomicQueue:\n\n Opaque atomic data queue.\n\n Use the accessor functions to get the stored values."]
pub type GstAtomicQueue = _GstAtomicQueue;
unsafe extern "C" {
    pub fn gst_atomic_queue_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_atomic_queue_new(initial_size: guint) -> *mut GstAtomicQueue;
}
unsafe extern "C" {
    pub fn gst_atomic_queue_ref(queue: *mut GstAtomicQueue);
}
unsafe extern "C" {
    pub fn gst_atomic_queue_unref(queue: *mut GstAtomicQueue);
}
unsafe extern "C" {
    pub fn gst_atomic_queue_push(queue: *mut GstAtomicQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn gst_atomic_queue_pop(queue: *mut GstAtomicQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_atomic_queue_peek(queue: *mut GstAtomicQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_atomic_queue_length(queue: *mut GstAtomicQueue) -> guint;
}
pub type GstAtomicQueue_autoptr = *mut GstAtomicQueue;
pub type GstAtomicQueue_listautoptr = *mut GList;
pub type GstAtomicQueue_slistautoptr = *mut GSList;
pub type GstAtomicQueue_queueautoptr = *mut GQueue;
#[doc = " GstElement:\n @state_lock: Used to serialize execution of gst_element_set_state()\n @state_cond: Used to signal completion of a state change\n @state_cookie: Used to detect concurrent execution of\n gst_element_set_state() and gst_element_get_state()\n @target_state: the target state of an element as set by the application\n @current_state: the current state of an element\n @next_state: the next state of an element, can be #GST_STATE_VOID_PENDING if\n the element is in the correct state.\n @pending_state: the final state the element should go to, can be\n #GST_STATE_VOID_PENDING if the element is in the correct state\n @last_return: the last return value of an element state change\n @bus: the bus of the element. This bus is provided to the element by the\n parent element or the application. A #GstPipeline has a bus of its own.\n @clock: the clock of the element. This clock is usually provided to the\n element by the toplevel #GstPipeline.\n @base_time: the time of the clock right before the element is set to\n PLAYING. Subtracting @base_time from the current clock time in the PLAYING\n state will yield the running_time against the clock.\n @start_time: the running_time of the last PAUSED state\n @numpads: number of pads of the element, includes both source and sink pads.\n @pads: (element-type Gst.Pad): list of pads\n @numsrcpads: number of source pads of the element.\n @srcpads: (element-type Gst.Pad): list of source pads\n @numsinkpads: number of sink pads of the element.\n @sinkpads: (element-type Gst.Pad): list of sink pads\n @pads_cookie: updated whenever the a pad is added or removed\n @contexts: (element-type Gst.Context): list of contexts\n\n GStreamer element abstract base class."]
pub type GstElement = _GstElement;
#[doc = " GstElementClass:\n @parent_class: the parent class structure\n @metadata: metadata for elements of this class\n @elementfactory: the #GstElementFactory that creates these elements\n @padtemplates: a #GList of #GstPadTemplate\n @numpadtemplates: the number of padtemplates\n @pad_templ_cookie: changed whenever the padtemplates change\n @request_new_pad: called when a new pad is requested\n @release_pad: called when a request pad is to be released\n @get_state: get the state of the element\n @set_state: set a new state on the element\n @change_state: called by @set_state to perform an incremental state change\n @set_bus: set a #GstBus on the element\n @provide_clock: gets the #GstClock provided by the element\n @set_clock: set the #GstClock on the element\n @send_event: send a #GstEvent to the element\n @query: perform a #GstQuery on the element\n @state_changed: called immediately after a new state was set.\n @post_message: called when a message is posted on the element. Chain up to\n                the parent class' handler to have it posted on the bus.\n @set_context: set a #GstContext on the element\n\n GStreamer element class. Override the vmethods to implement the element\n functionality."]
pub type GstElementClass = _GstElementClass;
pub const GstState_GST_STATE_VOID_PENDING: GstState = 0;
pub const GstState_GST_STATE_NULL: GstState = 1;
pub const GstState_GST_STATE_READY: GstState = 2;
pub const GstState_GST_STATE_PAUSED: GstState = 3;
pub const GstState_GST_STATE_PLAYING: GstState = 4;
#[doc = " GstState:\n @GST_STATE_VOID_PENDING: no pending state.\n @GST_STATE_NULL        : the NULL state or initial state of an element.\n @GST_STATE_READY       : the element is ready to go to PAUSED.\n @GST_STATE_PAUSED      : the element is PAUSED, it is ready to accept and\n                          process data. Sink elements however only accept one\n                          buffer and then block.\n @GST_STATE_PLAYING     : the element is PLAYING, the #GstClock is running and\n                          the data is flowing.\n\n The possible states an element can be in. States can be changed using\n gst_element_set_state() and checked using gst_element_get_state()."]
pub type GstState = ::std::os::raw::c_uint;
pub const GstStateChangeReturn_GST_STATE_CHANGE_FAILURE: GstStateChangeReturn = 0;
pub const GstStateChangeReturn_GST_STATE_CHANGE_SUCCESS: GstStateChangeReturn = 1;
pub const GstStateChangeReturn_GST_STATE_CHANGE_ASYNC: GstStateChangeReturn = 2;
pub const GstStateChangeReturn_GST_STATE_CHANGE_NO_PREROLL: GstStateChangeReturn = 3;
#[doc = " GstStateChangeReturn:\n @GST_STATE_CHANGE_FAILURE   : the state change failed\n @GST_STATE_CHANGE_SUCCESS   : the state change succeeded\n @GST_STATE_CHANGE_ASYNC     : the state change will happen asynchronously\n @GST_STATE_CHANGE_NO_PREROLL: the state change succeeded but the element\n                               cannot produce data in %GST_STATE_PAUSED.\n                               This typically happens with live sources.\n\n The possible return values from a state change function such as\n gst_element_set_state(). Only @GST_STATE_CHANGE_FAILURE is a real failure."]
pub type GstStateChangeReturn = ::std::os::raw::c_uint;
pub const GstObjectFlags_GST_OBJECT_FLAG_MAY_BE_LEAKED: GstObjectFlags = 1;
pub const GstObjectFlags_GST_OBJECT_FLAG_LAST: GstObjectFlags = 16;
#[doc = " GstObjectFlags:\n @GST_OBJECT_FLAG_MAY_BE_LEAKED: the object is expected to stay alive even\n after gst_deinit() has been called and so should be ignored by leak\n detection tools. (Since: 1.10)\n @GST_OBJECT_FLAG_LAST: subclasses can add additional flags starting from this flag\n\n The standard flags that an gstobject may have."]
pub type GstObjectFlags = ::std::os::raw::c_uint;
#[doc = " GstObject:\n @lock: object LOCK\n @name: The name of the object\n @parent: this object's parent, weak ref\n @flags: flags for this object\n\n GStreamer base object class."]
pub type GstObject = _GstObject;
#[doc = " GstObjectClass:\n @parent_class: parent\n @path_string_separator: separator used by gst_object_get_path_string()\n @deep_notify: default signal handler\n\n GStreamer base object class."]
pub type GstObjectClass = _GstObjectClass;
#[doc = " GstObject:\n @lock: object LOCK\n @name: The name of the object\n @parent: this object's parent, weak ref\n @flags: flags for this object\n\n GStreamer base object class."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstObject {
    pub object: GInitiallyUnowned,
    pub lock: GMutex,
    pub name: *mut gchar,
    pub parent: *mut GstObject,
    pub flags: guint32,
    pub control_bindings: *mut GList,
    pub control_rate: guint64,
    pub last_sync: guint64,
    pub _gst_reserved: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstObject"][::std::mem::size_of::<_GstObject>() - 88usize];
    ["Alignment of _GstObject"][::std::mem::align_of::<_GstObject>() - 8usize];
    ["Offset of field: _GstObject::object"][::std::mem::offset_of!(_GstObject, object) - 0usize];
    ["Offset of field: _GstObject::lock"][::std::mem::offset_of!(_GstObject, lock) - 24usize];
    ["Offset of field: _GstObject::name"][::std::mem::offset_of!(_GstObject, name) - 32usize];
    ["Offset of field: _GstObject::parent"][::std::mem::offset_of!(_GstObject, parent) - 40usize];
    ["Offset of field: _GstObject::flags"][::std::mem::offset_of!(_GstObject, flags) - 48usize];
    ["Offset of field: _GstObject::control_bindings"]
        [::std::mem::offset_of!(_GstObject, control_bindings) - 56usize];
    ["Offset of field: _GstObject::control_rate"]
        [::std::mem::offset_of!(_GstObject, control_rate) - 64usize];
    ["Offset of field: _GstObject::last_sync"]
        [::std::mem::offset_of!(_GstObject, last_sync) - 72usize];
    ["Offset of field: _GstObject::_gst_reserved"]
        [::std::mem::offset_of!(_GstObject, _gst_reserved) - 80usize];
};
#[doc = " GstObjectClass:\n @parent_class: parent\n @path_string_separator: separator used by gst_object_get_path_string()\n @deep_notify: default signal handler\n\n GStreamer base object class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstObjectClass {
    pub parent_class: GInitiallyUnownedClass,
    pub path_string_separator: *const gchar,
    pub deep_notify: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GstObject, orig: *mut GstObject, pspec: *mut GParamSpec),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstObjectClass"][::std::mem::size_of::<_GstObjectClass>() - 184usize];
    ["Alignment of _GstObjectClass"][::std::mem::align_of::<_GstObjectClass>() - 8usize];
    ["Offset of field: _GstObjectClass::parent_class"]
        [::std::mem::offset_of!(_GstObjectClass, parent_class) - 0usize];
    ["Offset of field: _GstObjectClass::path_string_separator"]
        [::std::mem::offset_of!(_GstObjectClass, path_string_separator) - 136usize];
    ["Offset of field: _GstObjectClass::deep_notify"]
        [::std::mem::offset_of!(_GstObjectClass, deep_notify) - 144usize];
    ["Offset of field: _GstObjectClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstObjectClass, _gst_reserved) - 152usize];
};
unsafe extern "C" {
    pub fn gst_object_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_object_set_name(object: *mut GstObject, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_name(object: *mut GstObject) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_object_set_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_parent(object: *mut GstObject) -> *mut GstObject;
}
unsafe extern "C" {
    pub fn gst_object_unparent(object: *mut GstObject);
}
unsafe extern "C" {
    pub fn gst_object_has_as_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_has_as_ancestor(object: *mut GstObject, ancestor: *mut GstObject)
    -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_has_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_default_deep_notify(
        object: *mut GObject,
        orig: *mut GstObject,
        pspec: *mut GParamSpec,
        excluded_props: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn gst_object_ref(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_object_unref(object: gpointer);
}
unsafe extern "C" {
    pub fn gst_clear_object(object_ptr: *mut *mut GstObject);
}
unsafe extern "C" {
    pub fn gst_object_ref_sink(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_object_replace(oldobj: *mut *mut GstObject, newobj: *mut GstObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_path_string(object: *mut GstObject) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_object_check_uniqueness(list: *mut GList, name: *const gchar) -> gboolean;
}
#[doc = " GstControlBinding:\n @parent: the parent structure\n @name: name of the property of this binding\n @pspec: #GParamSpec for this property\n\n The instance structure of #GstControlBinding."]
pub type GstControlBinding = _GstControlBinding;
#[doc = " GstControlBindingClass:\n @parent_class: Parent class\n\n The class structure of #GstControlBinding."]
pub type GstControlBindingClass = _GstControlBindingClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstControlBindingPrivate {
    _unused: [u8; 0],
}
pub type GstControlBindingPrivate = _GstControlBindingPrivate;
#[doc = " GstClockTime:\n\n A datatype to hold a time, measured in nanoseconds."]
pub type GstClockTime = guint64;
#[doc = " GstClockTimeDiff:\n\n A datatype to hold a time difference, measured in nanoseconds."]
pub type GstClockTimeDiff = gint64;
#[doc = " GstClockID:\n\n A datatype to hold the handle to an outstanding sync or async clock callback."]
pub type GstClockID = gpointer;
#[doc = " GstClockEntry:\n @refcount: reference counter (read-only)\n\n All pending timeouts or periodic notifies are converted into\n an entry.\n Note that GstClockEntry should be treated as an opaque structure. It must\n not be extended or allocated using a custom allocator."]
pub type GstClockEntry = _GstClockEntry;
#[doc = " GstClock:\n @object: the parent structure\n\n #GstClock base structure."]
pub type GstClock = _GstClock;
#[doc = " GstClockClass:\n @parent_class: the parent class structure\n\n GStreamer clock class. Override the vmethods to implement the clock\n functionality."]
pub type GstClockClass = _GstClockClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstClockPrivate {
    _unused: [u8; 0],
}
pub type GstClockPrivate = _GstClockPrivate;
#[doc = " GstClockCallback:\n @clock: The clock that triggered the callback\n @time: The time it was triggered\n @id: The #GstClockID that expired\n @user_data: user data passed in the gst_clock_id_wait_async() function\n\n The function prototype of the callback.\n\n Returns: %TRUE or %FALSE (currently unused)"]
pub type GstClockCallback = ::std::option::Option<
    unsafe extern "C" fn(
        clock: *mut GstClock,
        time: GstClockTime,
        id: GstClockID,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GstClockReturn_GST_CLOCK_OK: GstClockReturn = 0;
pub const GstClockReturn_GST_CLOCK_EARLY: GstClockReturn = 1;
pub const GstClockReturn_GST_CLOCK_UNSCHEDULED: GstClockReturn = 2;
pub const GstClockReturn_GST_CLOCK_BUSY: GstClockReturn = 3;
pub const GstClockReturn_GST_CLOCK_BADTIME: GstClockReturn = 4;
pub const GstClockReturn_GST_CLOCK_ERROR: GstClockReturn = 5;
pub const GstClockReturn_GST_CLOCK_UNSUPPORTED: GstClockReturn = 6;
pub const GstClockReturn_GST_CLOCK_DONE: GstClockReturn = 7;
#[doc = " GstClockReturn:\n @GST_CLOCK_OK: The operation succeeded.\n @GST_CLOCK_EARLY: The operation was scheduled too late.\n @GST_CLOCK_UNSCHEDULED: The clockID was unscheduled\n @GST_CLOCK_BUSY: The ClockID is busy\n @GST_CLOCK_BADTIME: A bad time was provided to a function.\n @GST_CLOCK_ERROR: An error occurred\n @GST_CLOCK_UNSUPPORTED: Operation is not supported\n @GST_CLOCK_DONE: The ClockID is done waiting\n\n The return value of a clock operation."]
pub type GstClockReturn = ::std::os::raw::c_uint;
pub const GstClockEntryType_GST_CLOCK_ENTRY_SINGLE: GstClockEntryType = 0;
pub const GstClockEntryType_GST_CLOCK_ENTRY_PERIODIC: GstClockEntryType = 1;
#[doc = " GstClockEntryType:\n @GST_CLOCK_ENTRY_SINGLE: a single shot timeout\n @GST_CLOCK_ENTRY_PERIODIC: a periodic timeout request\n\n The type of the clock entry"]
pub type GstClockEntryType = ::std::os::raw::c_uint;
#[doc = " GstClockEntry:\n @refcount: reference counter (read-only)\n\n All pending timeouts or periodic notifies are converted into\n an entry.\n Note that GstClockEntry should be treated as an opaque structure. It must\n not be extended or allocated using a custom allocator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstClockEntry {
    pub refcount: gint,
    pub clock: *mut GstClock,
    pub type_: GstClockEntryType,
    pub time: GstClockTime,
    pub interval: GstClockTime,
    pub status: GstClockReturn,
    pub func: GstClockCallback,
    pub user_data: gpointer,
    pub destroy_data: GDestroyNotify,
    pub unscheduled: gboolean,
    pub woken_up: gboolean,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstClockEntry"][::std::mem::size_of::<_GstClockEntry>() - 112usize];
    ["Alignment of _GstClockEntry"][::std::mem::align_of::<_GstClockEntry>() - 8usize];
    ["Offset of field: _GstClockEntry::refcount"]
        [::std::mem::offset_of!(_GstClockEntry, refcount) - 0usize];
    ["Offset of field: _GstClockEntry::clock"]
        [::std::mem::offset_of!(_GstClockEntry, clock) - 8usize];
    ["Offset of field: _GstClockEntry::type_"]
        [::std::mem::offset_of!(_GstClockEntry, type_) - 16usize];
    ["Offset of field: _GstClockEntry::time"]
        [::std::mem::offset_of!(_GstClockEntry, time) - 24usize];
    ["Offset of field: _GstClockEntry::interval"]
        [::std::mem::offset_of!(_GstClockEntry, interval) - 32usize];
    ["Offset of field: _GstClockEntry::status"]
        [::std::mem::offset_of!(_GstClockEntry, status) - 40usize];
    ["Offset of field: _GstClockEntry::func"]
        [::std::mem::offset_of!(_GstClockEntry, func) - 48usize];
    ["Offset of field: _GstClockEntry::user_data"]
        [::std::mem::offset_of!(_GstClockEntry, user_data) - 56usize];
    ["Offset of field: _GstClockEntry::destroy_data"]
        [::std::mem::offset_of!(_GstClockEntry, destroy_data) - 64usize];
    ["Offset of field: _GstClockEntry::unscheduled"]
        [::std::mem::offset_of!(_GstClockEntry, unscheduled) - 72usize];
    ["Offset of field: _GstClockEntry::woken_up"]
        [::std::mem::offset_of!(_GstClockEntry, woken_up) - 76usize];
    ["Offset of field: _GstClockEntry::_gst_reserved"]
        [::std::mem::offset_of!(_GstClockEntry, _gst_reserved) - 80usize];
};
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: GstClockFlags = 16;
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: GstClockFlags = 32;
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: GstClockFlags = 64;
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: GstClockFlags = 128;
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_SET_RESOLUTION: GstClockFlags = 256;
pub const GstClockFlags_GST_CLOCK_FLAG_CAN_SET_MASTER: GstClockFlags = 512;
#[doc = " GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC:\n\n clock needs to be synced before it can be used\n\n Since: 1.6"]
pub const GstClockFlags_GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: GstClockFlags = 1024;
#[doc = " GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC:\n\n clock needs to be synced before it can be used\n\n Since: 1.6"]
pub const GstClockFlags_GST_CLOCK_FLAG_LAST: GstClockFlags = 4096;
#[doc = " GstClockFlags:\n @GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: clock can do a single sync timeout request\n @GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: clock can do a single async timeout request\n @GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: clock can do sync periodic timeout requests\n @GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: clock can do async periodic timeout callbacks\n @GST_CLOCK_FLAG_CAN_SET_RESOLUTION: clock's resolution can be changed\n @GST_CLOCK_FLAG_CAN_SET_MASTER: clock can be slaved to a master clock\n @GST_CLOCK_FLAG_LAST: subclasses can add additional flags starting from this flag\n\n The capabilities of this clock"]
pub type GstClockFlags = ::std::os::raw::c_uint;
#[doc = " GstClock:\n @object: the parent structure\n\n #GstClock base structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstClock {
    pub object: GstObject,
    pub priv_: *mut GstClockPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstClock"][::std::mem::size_of::<_GstClock>() - 128usize];
    ["Alignment of _GstClock"][::std::mem::align_of::<_GstClock>() - 8usize];
    ["Offset of field: _GstClock::object"][::std::mem::offset_of!(_GstClock, object) - 0usize];
    ["Offset of field: _GstClock::priv_"][::std::mem::offset_of!(_GstClock, priv_) - 88usize];
    ["Offset of field: _GstClock::_gst_reserved"]
        [::std::mem::offset_of!(_GstClock, _gst_reserved) - 96usize];
};
#[doc = " GstClockClass:\n @parent_class: the parent class structure\n\n GStreamer clock class. Override the vmethods to implement the clock\n functionality."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstClockClass {
    pub parent_class: GstObjectClass,
    #[doc = " GstClockClass::change_resolution:\n @clock: the #GstClock\n @old_resolution: the previous resolution\n @new_resolution: the new resolution\n\n Change the resolution of the clock. Not all values might\n be acceptable.\n\n Returns: the new resolution"]
    pub change_resolution: ::std::option::Option<
        unsafe extern "C" fn(
            clock: *mut GstClock,
            old_resolution: GstClockTime,
            new_resolution: GstClockTime,
        ) -> GstClockTime,
    >,
    #[doc = " GstClockClass::get_resolution:\n @clock: the #GstClock\n\n Get the resolution of the clock.\n\n Returns: the current resolution"]
    pub get_resolution:
        ::std::option::Option<unsafe extern "C" fn(clock: *mut GstClock) -> GstClockTime>,
    #[doc = " GstClockClass::get_internal_time:\n @clock: the #GstClock\n\n Get the internal unadjusted time of the clock.\n\n Implement #GstClockClass::wait instead.\n\n Returns: the internal time"]
    pub get_internal_time:
        ::std::option::Option<unsafe extern "C" fn(clock: *mut GstClock) -> GstClockTime>,
    #[doc = " GstClockClass::wait:\n @clock: the #GstClock\n @entry: the entry to wait on\n @jitter: (out) (allow-none): a pointer that will contain the jitter\n\n Perform a blocking wait on the given #GstClockEntry and return\n the jitter.\n\n Returns: the result of the blocking wait. #GST_CLOCK_EARLY will be returned\n if the current clock time is past the time of @id, #GST_CLOCK_OK if\n @id was scheduled in time. #GST_CLOCK_UNSCHEDULED if @id was\n unscheduled with gst_clock_id_unschedule()."]
    pub wait: ::std::option::Option<
        unsafe extern "C" fn(
            clock: *mut GstClock,
            entry: *mut GstClockEntry,
            jitter: *mut GstClockTimeDiff,
        ) -> GstClockReturn,
    >,
    #[doc = " GstClockClass::wait_async:\n @clock: the #GstClock\n @entry: the entry to wait on\n\n Perform an asynchronous wait on the given #GstClockEntry.\n\n Returns: the result of the non blocking wait."]
    pub wait_async: ::std::option::Option<
        unsafe extern "C" fn(clock: *mut GstClock, entry: *mut GstClockEntry) -> GstClockReturn,
    >,
    #[doc = " GstClockClass::unschedule:\n @clock: the #GstClock\n @entry: the entry to unschedule\n\n Unblock a blocking or async wait operation."]
    pub unschedule: ::std::option::Option<
        unsafe extern "C" fn(clock: *mut GstClock, entry: *mut GstClockEntry),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstClockClass"][::std::mem::size_of::<_GstClockClass>() - 264usize];
    ["Alignment of _GstClockClass"][::std::mem::align_of::<_GstClockClass>() - 8usize];
    ["Offset of field: _GstClockClass::parent_class"]
        [::std::mem::offset_of!(_GstClockClass, parent_class) - 0usize];
    ["Offset of field: _GstClockClass::change_resolution"]
        [::std::mem::offset_of!(_GstClockClass, change_resolution) - 184usize];
    ["Offset of field: _GstClockClass::get_resolution"]
        [::std::mem::offset_of!(_GstClockClass, get_resolution) - 192usize];
    ["Offset of field: _GstClockClass::get_internal_time"]
        [::std::mem::offset_of!(_GstClockClass, get_internal_time) - 200usize];
    ["Offset of field: _GstClockClass::wait"]
        [::std::mem::offset_of!(_GstClockClass, wait) - 208usize];
    ["Offset of field: _GstClockClass::wait_async"]
        [::std::mem::offset_of!(_GstClockClass, wait_async) - 216usize];
    ["Offset of field: _GstClockClass::unschedule"]
        [::std::mem::offset_of!(_GstClockClass, unschedule) - 224usize];
    ["Offset of field: _GstClockClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstClockClass, _gst_reserved) - 232usize];
};
unsafe extern "C" {
    pub fn gst_clock_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_clock_set_resolution(clock: *mut GstClock, resolution: GstClockTime)
    -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_get_resolution(clock: *mut GstClock) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_get_time(clock: *mut GstClock) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_set_calibration(
        clock: *mut GstClock,
        internal: GstClockTime,
        external: GstClockTime,
        rate_num: GstClockTime,
        rate_denom: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_clock_get_calibration(
        clock: *mut GstClock,
        internal: *mut GstClockTime,
        external: *mut GstClockTime,
        rate_num: *mut GstClockTime,
        rate_denom: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_clock_set_master(clock: *mut GstClock, master: *mut GstClock) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_get_master(clock: *mut GstClock) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_clock_set_timeout(clock: *mut GstClock, timeout: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_clock_get_timeout(clock: *mut GstClock) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_add_observation(
        clock: *mut GstClock,
        slave: GstClockTime,
        master: GstClockTime,
        r_squared: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_add_observation_unapplied(
        clock: *mut GstClock,
        slave: GstClockTime,
        master: GstClockTime,
        r_squared: *mut gdouble,
        internal: *mut GstClockTime,
        external: *mut GstClockTime,
        rate_num: *mut GstClockTime,
        rate_denom: *mut GstClockTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_get_internal_time(clock: *mut GstClock) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_adjust_unlocked(clock: *mut GstClock, internal: GstClockTime) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_adjust_with_calibration(
        clock: *mut GstClock,
        internal_target: GstClockTime,
        cinternal: GstClockTime,
        cexternal: GstClockTime,
        cnum: GstClockTime,
        cdenom: GstClockTime,
    ) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_unadjust_with_calibration(
        clock: *mut GstClock,
        external_target: GstClockTime,
        cinternal: GstClockTime,
        cexternal: GstClockTime,
        cnum: GstClockTime,
        cdenom: GstClockTime,
    ) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_unadjust_unlocked(
        clock: *mut GstClock,
        external: GstClockTime,
    ) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_wait_for_sync(clock: *mut GstClock, timeout: GstClockTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_is_synced(clock: *mut GstClock) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_set_synced(clock: *mut GstClock, synced: gboolean);
}
unsafe extern "C" {
    pub fn gst_clock_new_single_shot_id(clock: *mut GstClock, time: GstClockTime) -> GstClockID;
}
unsafe extern "C" {
    pub fn gst_clock_new_periodic_id(
        clock: *mut GstClock,
        start_time: GstClockTime,
        interval: GstClockTime,
    ) -> GstClockID;
}
unsafe extern "C" {
    pub fn gst_clock_id_ref(id: GstClockID) -> GstClockID;
}
unsafe extern "C" {
    pub fn gst_clock_id_unref(id: GstClockID);
}
unsafe extern "C" {
    pub fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn gst_clock_id_get_clock(id: GstClockID) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_clock_id_uses_clock(id: GstClockID, clock: *mut GstClock) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_id_get_time(id: GstClockID) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_clock_id_wait(id: GstClockID, jitter: *mut GstClockTimeDiff) -> GstClockReturn;
}
unsafe extern "C" {
    pub fn gst_clock_id_wait_async(
        id: GstClockID,
        func: GstClockCallback,
        user_data: gpointer,
        destroy_data: GDestroyNotify,
    ) -> GstClockReturn;
}
unsafe extern "C" {
    pub fn gst_clock_id_unschedule(id: GstClockID);
}
unsafe extern "C" {
    pub fn gst_clock_single_shot_id_reinit(
        clock: *mut GstClock,
        id: GstClockID,
        time: GstClockTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_clock_periodic_id_reinit(
        clock: *mut GstClock,
        id: GstClockID,
        start_time: GstClockTime,
        interval: GstClockTime,
    ) -> gboolean;
}
pub type GstClock_autoptr = *mut GstClock;
pub type GstClock_listautoptr = *mut GList;
pub type GstClock_slistautoptr = *mut GSList;
pub type GstClock_queueautoptr = *mut GQueue;
#[doc = " GstControlSource:\n @parent: the parent structure\n @get_value: Function for returning a value for a given timestamp\n @get_value_array: Function for returning a values array for a given timestamp\n\n The instance structure of #GstControlSource."]
pub type GstControlSource = _GstControlSource;
#[doc = " GstControlSourceClass:\n @parent_class: Parent class\n\n The class structure of #GstControlSource."]
pub type GstControlSourceClass = _GstControlSourceClass;
#[doc = " GstTimedValue:\n @timestamp: timestamp of the value change\n @value: the corresponding value\n\n Structure for storing a timestamp and a value."]
pub type GstTimedValue = _GstTimedValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstValueArray {
    _unused: [u8; 0],
}
pub type GstValueArray = _GstValueArray;
#[doc = " GstTimedValue:\n @timestamp: timestamp of the value change\n @value: the corresponding value\n\n Structure for storing a timestamp and a value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTimedValue {
    pub timestamp: GstClockTime,
    pub value: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTimedValue"][::std::mem::size_of::<_GstTimedValue>() - 16usize];
    ["Alignment of _GstTimedValue"][::std::mem::align_of::<_GstTimedValue>() - 8usize];
    ["Offset of field: _GstTimedValue::timestamp"]
        [::std::mem::offset_of!(_GstTimedValue, timestamp) - 0usize];
    ["Offset of field: _GstTimedValue::value"]
        [::std::mem::offset_of!(_GstTimedValue, value) - 8usize];
};
#[doc = " GstControlSourceGetValue:\n @self: the #GstControlSource instance\n @timestamp: timestamp for which a value should be calculated\n @value: a value which will be set to the result.\n\n Function for returning a value for a given timestamp.\n\n Returns: %TRUE if the value was successfully calculated.\n"]
pub type GstControlSourceGetValue = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        value: *mut gdouble,
    ) -> gboolean,
>;
#[doc = " GstControlSourceGetValueArray:\n @self: the #GstControlSource instance\n @timestamp: timestamp for which a value should be calculated\n @interval: the time spacing between subsequent values\n @n_values: the number of values\n @values: array to put control-values in\n\n Function for returning an array of values starting at a given timestamp.\n\n Returns: %TRUE if the values were successfully calculated.\n"]
pub type GstControlSourceGetValueArray = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: *mut gdouble,
    ) -> gboolean,
>;
#[doc = " GstControlSource:\n @parent: the parent structure\n @get_value: Function for returning a value for a given timestamp\n @get_value_array: Function for returning a values array for a given timestamp\n\n The instance structure of #GstControlSource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstControlSource {
    pub parent: GstObject,
    pub get_value: GstControlSourceGetValue,
    pub get_value_array: GstControlSourceGetValueArray,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlSource"][::std::mem::size_of::<_GstControlSource>() - 136usize];
    ["Alignment of _GstControlSource"][::std::mem::align_of::<_GstControlSource>() - 8usize];
    ["Offset of field: _GstControlSource::parent"]
        [::std::mem::offset_of!(_GstControlSource, parent) - 0usize];
    ["Offset of field: _GstControlSource::get_value"]
        [::std::mem::offset_of!(_GstControlSource, get_value) - 88usize];
    ["Offset of field: _GstControlSource::get_value_array"]
        [::std::mem::offset_of!(_GstControlSource, get_value_array) - 96usize];
    ["Offset of field: _GstControlSource::_gst_reserved"]
        [::std::mem::offset_of!(_GstControlSource, _gst_reserved) - 104usize];
};
#[doc = " GstControlSourceClass:\n @parent_class: Parent class\n\n The class structure of #GstControlSource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstControlSourceClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlSourceClass"][::std::mem::size_of::<_GstControlSourceClass>() - 216usize];
    ["Alignment of _GstControlSourceClass"]
        [::std::mem::align_of::<_GstControlSourceClass>() - 8usize];
    ["Offset of field: _GstControlSourceClass::parent_class"]
        [::std::mem::offset_of!(_GstControlSourceClass, parent_class) - 0usize];
    ["Offset of field: _GstControlSourceClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstControlSourceClass, _gst_reserved) - 184usize];
};
unsafe extern "C" {
    pub fn gst_control_source_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_control_source_get_value(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        value: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_control_source_get_value_array(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: *mut gdouble,
    ) -> gboolean;
}
pub type GstControlSource_autoptr = *mut GstControlSource;
pub type GstControlSource_listautoptr = *mut GList;
pub type GstControlSource_slistautoptr = *mut GSList;
pub type GstControlSource_queueautoptr = *mut GQueue;
pub type GstValueArray_autoptr = *mut GstValueArray;
pub type GstValueArray_listautoptr = *mut GList;
pub type GstValueArray_slistautoptr = *mut GSList;
pub type GstValueArray_queueautoptr = *mut GQueue;
#[doc = " GstControlBindingConvert: (attributes doc.skip=true)\n FIXME(2.0): remove, this is unused"]
pub type GstControlBindingConvert = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GstControlBinding,
        src_value: gdouble,
        dest_value: *mut GValue,
    ),
>;
#[doc = " GstControlBinding:\n @parent: the parent structure\n @name: name of the property of this binding\n @pspec: #GParamSpec for this property\n\n The instance structure of #GstControlBinding."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstControlBinding {
    pub parent: GstObject,
    pub name: *mut gchar,
    pub pspec: *mut GParamSpec,
    pub object: *mut GstObject,
    pub disabled: gboolean,
    pub ABI: _GstControlBinding__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstControlBinding__bindgen_ty_1 {
    pub abi: _GstControlBinding__bindgen_ty_1__bindgen_ty_1,
    pub _gst_reserved: [gpointer; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstControlBinding__bindgen_ty_1__bindgen_ty_1 {
    pub priv_: *mut GstControlBindingPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlBinding__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstControlBinding__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of _GstControlBinding__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstControlBinding__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstControlBinding__bindgen_ty_1__bindgen_ty_1::priv_"]
        [::std::mem::offset_of!(_GstControlBinding__bindgen_ty_1__bindgen_ty_1, priv_) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlBinding__bindgen_ty_1"]
        [::std::mem::size_of::<_GstControlBinding__bindgen_ty_1>() - 32usize];
    ["Alignment of _GstControlBinding__bindgen_ty_1"]
        [::std::mem::align_of::<_GstControlBinding__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstControlBinding__bindgen_ty_1::abi"]
        [::std::mem::offset_of!(_GstControlBinding__bindgen_ty_1, abi) - 0usize];
    ["Offset of field: _GstControlBinding__bindgen_ty_1::_gst_reserved"]
        [::std::mem::offset_of!(_GstControlBinding__bindgen_ty_1, _gst_reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlBinding"][::std::mem::size_of::<_GstControlBinding>() - 152usize];
    ["Alignment of _GstControlBinding"][::std::mem::align_of::<_GstControlBinding>() - 8usize];
    ["Offset of field: _GstControlBinding::parent"]
        [::std::mem::offset_of!(_GstControlBinding, parent) - 0usize];
    ["Offset of field: _GstControlBinding::name"]
        [::std::mem::offset_of!(_GstControlBinding, name) - 88usize];
    ["Offset of field: _GstControlBinding::pspec"]
        [::std::mem::offset_of!(_GstControlBinding, pspec) - 96usize];
    ["Offset of field: _GstControlBinding::object"]
        [::std::mem::offset_of!(_GstControlBinding, object) - 104usize];
    ["Offset of field: _GstControlBinding::disabled"]
        [::std::mem::offset_of!(_GstControlBinding, disabled) - 112usize];
    ["Offset of field: _GstControlBinding::ABI"]
        [::std::mem::offset_of!(_GstControlBinding, ABI) - 120usize];
};
#[doc = " GstControlBindingClass:\n @parent_class: Parent class\n\n The class structure of #GstControlBinding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstControlBindingClass {
    pub parent_class: GstObjectClass,
    #[doc = " GstControlBindingClass::sync_values:\n @binding: the control binding\n @object: the object that has controlled properties\n @timestamp: the time that should be processed\n @last_sync: the last time this was called\n\n Update the target values\n\n Returns: %TRUE if the controller value could be applied to the object\n property, %FALSE otherwise"]
    pub sync_values: ::std::option::Option<
        unsafe extern "C" fn(
            binding: *mut GstControlBinding,
            object: *mut GstObject,
            timestamp: GstClockTime,
            last_sync: GstClockTime,
        ) -> gboolean,
    >,
    #[doc = " GstControlBindingClass::get_value:\n @binding: the control binding\n @timestamp: the time the control-change should be read from\n\n Fetch a single control-value\n\n Returns: (nullable): the GValue of the property at the given time,\n or %NULL if the property isn't controlled."]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            binding: *mut GstControlBinding,
            timestamp: GstClockTime,
        ) -> *mut GValue,
    >,
    #[doc = " GstControlBindingClass::get_value_array:\n @binding: the control binding\n @timestamp: the time that should be processed\n @interval: the time spacing between subsequent values\n @n_values: the number of values\n @values: (array length=n_values): array to put control-values in\n\n Fetch a series of control-values\n\n Returns: %TRUE if the given array could be filled, %FALSE otherwise"]
    pub get_value_array: ::std::option::Option<
        unsafe extern "C" fn(
            binding: *mut GstControlBinding,
            timestamp: GstClockTime,
            interval: GstClockTime,
            n_values: guint,
            values: gpointer,
        ) -> gboolean,
    >,
    #[doc = " GstControlBindingClass::get_g_value_array:\n @binding: the control binding\n @timestamp: the time that should be processed\n @interval: the time spacing between subsequent values\n @n_values: the number of values\n @values: (array length=n_values): array to put control-values in\n\n Fetch a series of control-values as g_values\n\n Returns: %TRUE if the given array could be filled, %FALSE otherwise"]
    pub get_g_value_array: ::std::option::Option<
        unsafe extern "C" fn(
            binding: *mut GstControlBinding,
            timestamp: GstClockTime,
            interval: GstClockTime,
            n_values: guint,
            values: *mut GValue,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstControlBindingClass"]
        [::std::mem::size_of::<_GstControlBindingClass>() - 248usize];
    ["Alignment of _GstControlBindingClass"]
        [::std::mem::align_of::<_GstControlBindingClass>() - 8usize];
    ["Offset of field: _GstControlBindingClass::parent_class"]
        [::std::mem::offset_of!(_GstControlBindingClass, parent_class) - 0usize];
    ["Offset of field: _GstControlBindingClass::sync_values"]
        [::std::mem::offset_of!(_GstControlBindingClass, sync_values) - 184usize];
    ["Offset of field: _GstControlBindingClass::get_value"]
        [::std::mem::offset_of!(_GstControlBindingClass, get_value) - 192usize];
    ["Offset of field: _GstControlBindingClass::get_value_array"]
        [::std::mem::offset_of!(_GstControlBindingClass, get_value_array) - 200usize];
    ["Offset of field: _GstControlBindingClass::get_g_value_array"]
        [::std::mem::offset_of!(_GstControlBindingClass, get_g_value_array) - 208usize];
    ["Offset of field: _GstControlBindingClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstControlBindingClass, _gst_reserved) - 216usize];
};
unsafe extern "C" {
    pub fn gst_control_binding_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_control_binding_sync_values(
        binding: *mut GstControlBinding,
        object: *mut GstObject,
        timestamp: GstClockTime,
        last_sync: GstClockTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_control_binding_get_value(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
    ) -> *mut GValue;
}
unsafe extern "C" {
    pub fn gst_control_binding_get_value_array(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_control_binding_get_g_value_array(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: *mut GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_control_binding_set_disabled(binding: *mut GstControlBinding, disabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_control_binding_is_disabled(binding: *mut GstControlBinding) -> gboolean;
}
pub type GstControlBinding_autoptr = *mut GstControlBinding;
pub type GstControlBinding_listautoptr = *mut GList;
pub type GstControlBinding_slistautoptr = *mut GSList;
pub type GstControlBinding_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_object_suggest_next_sync(object: *mut GstObject) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_object_sync_values(object: *mut GstObject, timestamp: GstClockTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_has_active_control_bindings(object: *mut GstObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_set_control_bindings_disabled(object: *mut GstObject, disabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_object_set_control_binding_disabled(
        object: *mut GstObject,
        property_name: *const gchar,
        disabled: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_object_add_control_binding(
        object: *mut GstObject,
        binding: *mut GstControlBinding,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_control_binding(
        object: *mut GstObject,
        property_name: *const gchar,
    ) -> *mut GstControlBinding;
}
unsafe extern "C" {
    pub fn gst_object_remove_control_binding(
        object: *mut GstObject,
        binding: *mut GstControlBinding,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_value(
        object: *mut GstObject,
        property_name: *const gchar,
        timestamp: GstClockTime,
    ) -> *mut GValue;
}
unsafe extern "C" {
    pub fn gst_object_get_value_array(
        object: *mut GstObject,
        property_name: *const gchar,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_g_value_array(
        object: *mut GstObject,
        property_name: *const gchar,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: guint,
        values: *mut GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_object_get_control_rate(object: *mut GstObject) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_object_set_control_rate(object: *mut GstObject, control_rate: GstClockTime);
}
pub type GstObject_autoptr = *mut GstObject;
pub type GstObject_listautoptr = *mut GList;
pub type GstObject_slistautoptr = *mut GSList;
pub type GstObject_queueautoptr = *mut GQueue;
#[doc = " GstPad:\n @element_private: private data owned by the parent element\n @padtemplate: padtemplate for this pad\n @direction: the direction of the pad, cannot change after creating\n             the pad.\n\n The #GstPad structure. Use the functions to update the variables."]
pub type GstPad = _GstPad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPadPrivate {
    _unused: [u8; 0],
}
pub type GstPadPrivate = _GstPadPrivate;
pub type GstPadClass = _GstPadClass;
#[doc = " GstPadProbeInfo:\n @type: the current probe type\n @id: the id of the probe\n @data: (allow-none): type specific data, check the @type field to know the\n    datatype.  This field can be %NULL.\n @offset: offset of pull probe, this field is valid when @type contains\n    #GST_PAD_PROBE_TYPE_PULL\n @size: size of pull probe, this field is valid when @type contains\n    #GST_PAD_PROBE_TYPE_PULL\n\n Info passed in the #GstPadProbeCallback."]
pub type GstPadProbeInfo = _GstPadProbeInfo;
pub const GstPadDirection_GST_PAD_UNKNOWN: GstPadDirection = 0;
pub const GstPadDirection_GST_PAD_SRC: GstPadDirection = 1;
pub const GstPadDirection_GST_PAD_SINK: GstPadDirection = 2;
#[doc = " GstPadDirection:\n @GST_PAD_UNKNOWN: direction is unknown.\n @GST_PAD_SRC: the pad is a source pad.\n @GST_PAD_SINK: the pad is a sink pad.\n\n The direction of a pad."]
pub type GstPadDirection = ::std::os::raw::c_uint;
pub const GstPadMode_GST_PAD_MODE_NONE: GstPadMode = 0;
pub const GstPadMode_GST_PAD_MODE_PUSH: GstPadMode = 1;
pub const GstPadMode_GST_PAD_MODE_PULL: GstPadMode = 2;
#[doc = " GstPadMode:\n @GST_PAD_MODE_NONE: Pad will not handle dataflow\n @GST_PAD_MODE_PUSH: Pad handles dataflow in downstream push mode\n @GST_PAD_MODE_PULL: Pad handles dataflow in upstream pull mode\n\n The status of a GstPad. After activating a pad, which usually happens when the\n parent element goes from READY to PAUSED, the GstPadMode defines if the\n pad operates in push or pull mode."]
pub type GstPadMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_pad_mode_get_name(mode: GstPadMode) -> *const gchar;
}
unsafe extern "C" {
    pub static mut _gst_mini_object_type: GType;
}
#[doc = " GstMiniObject: (ref-func gst_mini_object_ref) (unref-func gst_mini_object_unref) (set-value-func g_value_set_boxed) (get-value-func g_value_get_boxed)\n @type: the GType of the object\n @refcount: atomic refcount\n @lockstate: atomic state of the locks\n @flags: extra flags.\n @copy: a copy function\n @dispose: a dispose function\n @free: the free function\n\n Base class for refcounted lightweight objects."]
pub type GstMiniObject = _GstMiniObject;
unsafe extern "C" {
    pub fn gst_mini_object_get_type() -> GType;
}
#[doc = " GstMiniObjectCopyFunction:\n @obj: MiniObject to copy\n\n Function prototype for methods to create copies of instances.\n\n Returns: reference to cloned instance."]
pub type GstMiniObjectCopyFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *const GstMiniObject) -> *mut GstMiniObject>;
#[doc = " GstMiniObjectDisposeFunction:\n @obj: MiniObject to dispose\n\n Function prototype for when a miniobject has lost its last refcount.\n Implementation of the mini object are allowed to revive the\n passed object by doing a gst_mini_object_ref(). If the object is not\n revived after the dispose function, the function should return %TRUE\n and the memory associated with the object is freed.\n\n Returns: %TRUE if the object should be cleaned up."]
pub type GstMiniObjectDisposeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject) -> gboolean>;
#[doc = " GstMiniObjectFreeFunction:\n @obj: MiniObject to free\n\n Virtual function prototype for methods to free resources used by\n mini-objects."]
pub type GstMiniObjectFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject)>;
#[doc = " GstMiniObjectNotify:\n @user_data: data that was provided when the notify was added\n @obj: the mini object\n\n A #GstMiniObjectNotify function can be added to a mini object as a\n callback that gets triggered when gst_mini_object_unref() drops the\n last ref and @obj is about to be freed."]
pub type GstMiniObjectNotify =
    ::std::option::Option<unsafe extern "C" fn(user_data: gpointer, obj: *mut GstMiniObject)>;
pub const GstMiniObjectFlags_GST_MINI_OBJECT_FLAG_LOCKABLE: GstMiniObjectFlags = 1;
pub const GstMiniObjectFlags_GST_MINI_OBJECT_FLAG_LOCK_READONLY: GstMiniObjectFlags = 2;
pub const GstMiniObjectFlags_GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED: GstMiniObjectFlags = 4;
pub const GstMiniObjectFlags_GST_MINI_OBJECT_FLAG_LAST: GstMiniObjectFlags = 16;
#[doc = " GstMiniObjectFlags:\n @GST_MINI_OBJECT_FLAG_LOCKABLE: the object can be locked and unlocked with\n gst_mini_object_lock() and gst_mini_object_unlock().\n @GST_MINI_OBJECT_FLAG_LOCK_READONLY: the object is permanently locked in\n READONLY mode. Only read locks can be performed on the object.\n @GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED: the object is expected to stay alive\n even after gst_deinit() has been called and so should be ignored by leak\n detection tools. (Since: 1.10)\n @GST_MINI_OBJECT_FLAG_LAST: first flag that can be used by subclasses.\n\n Flags for the mini object"]
pub type GstMiniObjectFlags = ::std::os::raw::c_uint;
pub const GstLockFlags_GST_LOCK_FLAG_READ: GstLockFlags = 1;
pub const GstLockFlags_GST_LOCK_FLAG_WRITE: GstLockFlags = 2;
pub const GstLockFlags_GST_LOCK_FLAG_EXCLUSIVE: GstLockFlags = 4;
pub const GstLockFlags_GST_LOCK_FLAG_LAST: GstLockFlags = 256;
#[doc = " GstLockFlags:\n @GST_LOCK_FLAG_READ: lock for read access\n @GST_LOCK_FLAG_WRITE: lock for write access\n @GST_LOCK_FLAG_EXCLUSIVE: lock for exclusive access\n @GST_LOCK_FLAG_LAST: first flag that can be used for custom purposes\n\n Flags used when locking miniobjects"]
pub type GstLockFlags = ::std::os::raw::c_uint;
#[doc = " GstMiniObject: (ref-func gst_mini_object_ref) (unref-func gst_mini_object_unref) (set-value-func g_value_set_boxed) (get-value-func g_value_get_boxed)\n @type: the GType of the object\n @refcount: atomic refcount\n @lockstate: atomic state of the locks\n @flags: extra flags.\n @copy: a copy function\n @dispose: a dispose function\n @free: the free function\n\n Base class for refcounted lightweight objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMiniObject {
    pub type_: GType,
    pub refcount: gint,
    pub lockstate: gint,
    pub flags: guint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub priv_uint: guint,
    pub priv_pointer: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstMiniObject"][::std::mem::size_of::<_GstMiniObject>() - 64usize];
    ["Alignment of _GstMiniObject"][::std::mem::align_of::<_GstMiniObject>() - 8usize];
    ["Offset of field: _GstMiniObject::type_"]
        [::std::mem::offset_of!(_GstMiniObject, type_) - 0usize];
    ["Offset of field: _GstMiniObject::refcount"]
        [::std::mem::offset_of!(_GstMiniObject, refcount) - 8usize];
    ["Offset of field: _GstMiniObject::lockstate"]
        [::std::mem::offset_of!(_GstMiniObject, lockstate) - 12usize];
    ["Offset of field: _GstMiniObject::flags"]
        [::std::mem::offset_of!(_GstMiniObject, flags) - 16usize];
    ["Offset of field: _GstMiniObject::copy"]
        [::std::mem::offset_of!(_GstMiniObject, copy) - 24usize];
    ["Offset of field: _GstMiniObject::dispose"]
        [::std::mem::offset_of!(_GstMiniObject, dispose) - 32usize];
    ["Offset of field: _GstMiniObject::free"]
        [::std::mem::offset_of!(_GstMiniObject, free) - 40usize];
    ["Offset of field: _GstMiniObject::priv_uint"]
        [::std::mem::offset_of!(_GstMiniObject, priv_uint) - 48usize];
    ["Offset of field: _GstMiniObject::priv_pointer"]
        [::std::mem::offset_of!(_GstMiniObject, priv_pointer) - 56usize];
};
unsafe extern "C" {
    pub fn gst_mini_object_init(
        mini_object: *mut GstMiniObject,
        flags: guint,
        type_: GType,
        copy_func: GstMiniObjectCopyFunction,
        dispose_func: GstMiniObjectDisposeFunction,
        free_func: GstMiniObjectFreeFunction,
    );
}
unsafe extern "C" {
    pub fn gst_mini_object_ref(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
}
unsafe extern "C" {
    pub fn gst_mini_object_unref(mini_object: *mut GstMiniObject);
}
unsafe extern "C" {
    pub fn gst_clear_mini_object(object_ptr: *mut *mut GstMiniObject);
}
unsafe extern "C" {
    pub fn gst_mini_object_weak_ref(
        object: *mut GstMiniObject,
        notify: GstMiniObjectNotify,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_mini_object_weak_unref(
        object: *mut GstMiniObject,
        notify: GstMiniObjectNotify,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_mini_object_lock(object: *mut GstMiniObject, flags: GstLockFlags) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_mini_object_unlock(object: *mut GstMiniObject, flags: GstLockFlags);
}
unsafe extern "C" {
    pub fn gst_mini_object_is_writable(mini_object: *const GstMiniObject) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_mini_object_make_writable(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
}
unsafe extern "C" {
    pub fn gst_mini_object_copy(mini_object: *const GstMiniObject) -> *mut GstMiniObject;
}
unsafe extern "C" {
    pub fn gst_mini_object_set_qdata(
        object: *mut GstMiniObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_mini_object_get_qdata(object: *mut GstMiniObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_mini_object_steal_qdata(object: *mut GstMiniObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_mini_object_add_parent(object: *mut GstMiniObject, parent: *mut GstMiniObject);
}
unsafe extern "C" {
    pub fn gst_mini_object_remove_parent(object: *mut GstMiniObject, parent: *mut GstMiniObject);
}
unsafe extern "C" {
    pub fn gst_mini_object_replace(
        olddata: *mut *mut GstMiniObject,
        newdata: *mut GstMiniObject,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_mini_object_take(
        olddata: *mut *mut GstMiniObject,
        newdata: *mut GstMiniObject,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_mini_object_steal(olddata: *mut *mut GstMiniObject) -> *mut GstMiniObject;
}
unsafe extern "C" {
    pub static mut _gst_memory_type: GType;
}
unsafe extern "C" {
    pub fn gst_memory_get_type() -> GType;
}
#[doc = " GstMemory:\n @mini_object: parent structure\n @allocator: pointer to the #GstAllocator\n @parent: parent memory block\n @maxsize: the maximum size allocated\n @align: the alignment of the memory\n @offset: the offset where valid data starts\n @size: the size of valid data\n\n Base structure for memory implementations. Custom memory will put this structure\n as the first member of their structure."]
pub type GstMemory = _GstMemory;
#[doc = " GstAllocator:\n @mem_map: the implementation of the GstMemoryMapFunction\n @mem_unmap: the implementation of the GstMemoryUnmapFunction\n @mem_copy: the implementation of the GstMemoryCopyFunction\n @mem_share: the implementation of the GstMemoryShareFunction\n @mem_is_span: the implementation of the GstMemoryIsSpanFunction\n @mem_map_full: the implementation of the GstMemoryMapFullFunction.\n      Will be used instead of @mem_map if present. (Since: 1.6)\n @mem_unmap_full: the implementation of the GstMemoryUnmapFullFunction.\n      Will be used instead of @mem_unmap if present. (Since: 1.6)\n\n The #GstAllocator is used to create new memory."]
pub type GstAllocator = _GstAllocator;
pub const GstMemoryFlags_GST_MEMORY_FLAG_READONLY: GstMemoryFlags = 2;
pub const GstMemoryFlags_GST_MEMORY_FLAG_NO_SHARE: GstMemoryFlags = 16;
pub const GstMemoryFlags_GST_MEMORY_FLAG_ZERO_PREFIXED: GstMemoryFlags = 32;
pub const GstMemoryFlags_GST_MEMORY_FLAG_ZERO_PADDED: GstMemoryFlags = 64;
pub const GstMemoryFlags_GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: GstMemoryFlags = 128;
pub const GstMemoryFlags_GST_MEMORY_FLAG_NOT_MAPPABLE: GstMemoryFlags = 256;
pub const GstMemoryFlags_GST_MEMORY_FLAG_LAST: GstMemoryFlags = 1048576;
#[doc = " GstMemoryFlags:\n @GST_MEMORY_FLAG_READONLY: memory is readonly. It is not allowed to map the\n memory with #GST_MAP_WRITE.\n @GST_MEMORY_FLAG_NO_SHARE: memory must not be shared. Copies will have to be\n made when this memory needs to be shared between buffers. (DEPRECATED:\n do not use in new code, instead you should create a custom GstAllocator for\n memory pooling instead of relying on the GstBuffer they were originally\n attached to.)\n @GST_MEMORY_FLAG_ZERO_PREFIXED: the memory prefix is filled with 0 bytes\n @GST_MEMORY_FLAG_ZERO_PADDED: the memory padding is filled with 0 bytes\n @GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: the memory is physically\n contiguous. (Since: 1.2)\n @GST_MEMORY_FLAG_NOT_MAPPABLE: the memory can't be mapped via\n gst_memory_map() without any preconditions. (Since: 1.2)\n @GST_MEMORY_FLAG_LAST: first flag that can be used for custom purposes\n\n Flags for wrapped memory."]
pub type GstMemoryFlags = ::std::os::raw::c_uint;
#[doc = " GstMemory:\n @mini_object: parent structure\n @allocator: pointer to the #GstAllocator\n @parent: parent memory block\n @maxsize: the maximum size allocated\n @align: the alignment of the memory\n @offset: the offset where valid data starts\n @size: the size of valid data\n\n Base structure for memory implementations. Custom memory will put this structure\n as the first member of their structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMemory {
    pub mini_object: GstMiniObject,
    pub allocator: *mut GstAllocator,
    pub parent: *mut GstMemory,
    pub maxsize: gsize,
    pub align: gsize,
    pub offset: gsize,
    pub size: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstMemory"][::std::mem::size_of::<_GstMemory>() - 112usize];
    ["Alignment of _GstMemory"][::std::mem::align_of::<_GstMemory>() - 8usize];
    ["Offset of field: _GstMemory::mini_object"]
        [::std::mem::offset_of!(_GstMemory, mini_object) - 0usize];
    ["Offset of field: _GstMemory::allocator"]
        [::std::mem::offset_of!(_GstMemory, allocator) - 64usize];
    ["Offset of field: _GstMemory::parent"][::std::mem::offset_of!(_GstMemory, parent) - 72usize];
    ["Offset of field: _GstMemory::maxsize"][::std::mem::offset_of!(_GstMemory, maxsize) - 80usize];
    ["Offset of field: _GstMemory::align"][::std::mem::offset_of!(_GstMemory, align) - 88usize];
    ["Offset of field: _GstMemory::offset"][::std::mem::offset_of!(_GstMemory, offset) - 96usize];
    ["Offset of field: _GstMemory::size"][::std::mem::offset_of!(_GstMemory, size) - 104usize];
};
pub const GstMapFlags_GST_MAP_READ: GstMapFlags = 1;
pub const GstMapFlags_GST_MAP_WRITE: GstMapFlags = 2;
pub const GstMapFlags_GST_MAP_FLAG_LAST: GstMapFlags = 65536;
#[doc = " GstMapFlags:\n @GST_MAP_READ: map for read access\n @GST_MAP_WRITE: map for write access\n @GST_MAP_FLAG_LAST: first flag that can be used for custom purposes\n\n Flags used when mapping memory"]
pub type GstMapFlags = ::std::os::raw::c_uint;
#[doc = " GstMapInfo:\n @memory: a pointer to the mapped memory\n @flags: flags used when mapping the memory\n @data: (array length=size): a pointer to the mapped data\n @size: the valid size in @data\n @maxsize: the maximum bytes in @data\n @user_data: extra private user_data that the implementation of the memory\n             can use to store extra info.\n\n A structure containing the result of a map operation such as\n gst_memory_map(). It contains the data and size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstMapInfo {
    pub memory: *mut GstMemory,
    pub flags: GstMapFlags,
    pub data: *mut guint8,
    pub size: gsize,
    pub maxsize: gsize,
    pub user_data: [gpointer; 4usize],
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstMapInfo"][::std::mem::size_of::<GstMapInfo>() - 104usize];
    ["Alignment of GstMapInfo"][::std::mem::align_of::<GstMapInfo>() - 8usize];
    ["Offset of field: GstMapInfo::memory"][::std::mem::offset_of!(GstMapInfo, memory) - 0usize];
    ["Offset of field: GstMapInfo::flags"][::std::mem::offset_of!(GstMapInfo, flags) - 8usize];
    ["Offset of field: GstMapInfo::data"][::std::mem::offset_of!(GstMapInfo, data) - 16usize];
    ["Offset of field: GstMapInfo::size"][::std::mem::offset_of!(GstMapInfo, size) - 24usize];
    ["Offset of field: GstMapInfo::maxsize"][::std::mem::offset_of!(GstMapInfo, maxsize) - 32usize];
    ["Offset of field: GstMapInfo::user_data"]
        [::std::mem::offset_of!(GstMapInfo, user_data) - 40usize];
    ["Offset of field: GstMapInfo::_gst_reserved"]
        [::std::mem::offset_of!(GstMapInfo, _gst_reserved) - 72usize];
};
#[doc = " GstMemoryMapFunction:\n @mem: a #GstMemory\n @maxsize: size to map\n @flags: access mode for the memory\n\n Get the memory of @mem that can be accessed according to the mode specified\n in @flags. The function should return a pointer that contains at least\n @maxsize bytes.\n\n Returns: a pointer to memory of which at least @maxsize bytes can be\n accessed according to the access pattern in @flags."]
pub type GstMemoryMapFunction = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut GstMemory, maxsize: gsize, flags: GstMapFlags) -> gpointer,
>;
#[doc = " GstMemoryMapFullFunction:\n @mem: a #GstMemory\n @info: the #GstMapInfo to map with\n @maxsize: size to map\n\n Get the memory of @mem that can be accessed according to the mode specified\n in @info's flags. The function should return a pointer that contains at least\n @maxsize bytes.\n\n Returns: a pointer to memory of which at least @maxsize bytes can be\n accessed according to the access pattern in @info's flags."]
pub type GstMemoryMapFullFunction = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut GstMemory, info: *mut GstMapInfo, maxsize: gsize) -> gpointer,
>;
#[doc = " GstMemoryUnmapFunction:\n @mem: a #GstMemory\n\n Release the pointer previously retrieved with gst_memory_map()."]
pub type GstMemoryUnmapFunction = ::std::option::Option<unsafe extern "C" fn(mem: *mut GstMemory)>;
#[doc = " GstMemoryUnmapFullFunction:\n @mem: a #GstMemory\n @info: a #GstMapInfo\n\n Release the pointer previously retrieved with gst_memory_map() with @info."]
pub type GstMemoryUnmapFullFunction =
    ::std::option::Option<unsafe extern "C" fn(mem: *mut GstMemory, info: *mut GstMapInfo)>;
#[doc = " GstMemoryCopyFunction:\n @mem: a #GstMemory\n @offset: an offset\n @size: a size or -1\n\n Copy @size bytes from @mem starting at @offset and return them wrapped in a\n new GstMemory object.\n If @size is set to -1, all bytes starting at @offset are copied.\n\n Returns: a new #GstMemory object wrapping a copy of the requested region in\n @mem."]
pub type GstMemoryCopyFunction = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut GstMemory, offset: gssize, size: gssize) -> *mut GstMemory,
>;
#[doc = " GstMemoryShareFunction:\n @mem: a #GstMemory\n @offset: an offset\n @size: a size or -1\n\n Share @size bytes from @mem starting at @offset and return them wrapped in a\n new GstMemory object. If @size is set to -1, all bytes starting at @offset are\n shared. This function does not make a copy of the bytes in @mem.\n\n Returns: a new #GstMemory object sharing the requested region in @mem."]
pub type GstMemoryShareFunction = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut GstMemory, offset: gssize, size: gssize) -> *mut GstMemory,
>;
#[doc = " GstMemoryIsSpanFunction:\n @mem1: a #GstMemory\n @mem2: a #GstMemory\n @offset: a result offset\n\n Check if @mem1 and @mem2 occupy contiguous memory and return the offset of\n @mem1 in the parent buffer in @offset.\n\n Returns: %TRUE if @mem1 and @mem2 are in contiguous memory."]
pub type GstMemoryIsSpanFunction = ::std::option::Option<
    unsafe extern "C" fn(
        mem1: *mut GstMemory,
        mem2: *mut GstMemory,
        offset: *mut gsize,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_memory_init(
        mem: *mut GstMemory,
        flags: GstMemoryFlags,
        allocator: *mut GstAllocator,
        parent: *mut GstMemory,
        maxsize: gsize,
        align: gsize,
        offset: gsize,
        size: gsize,
    );
}
unsafe extern "C" {
    pub fn gst_memory_is_type(mem: *mut GstMemory, mem_type: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_memory_get_sizes(
        mem: *mut GstMemory,
        offset: *mut gsize,
        maxsize: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_memory_resize(mem: *mut GstMemory, offset: gssize, size: gsize);
}
unsafe extern "C" {
    pub fn gst_memory_make_mapped(
        mem: *mut GstMemory,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_memory_map(
        mem: *mut GstMemory,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_memory_unmap(mem: *mut GstMemory, info: *mut GstMapInfo);
}
unsafe extern "C" {
    pub fn gst_memory_copy(mem: *mut GstMemory, offset: gssize, size: gssize) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_memory_share(mem: *mut GstMemory, offset: gssize, size: gssize) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_memory_is_span(
        mem1: *mut GstMemory,
        mem2: *mut GstMemory,
        offset: *mut gsize,
    ) -> gboolean;
}
pub type GstMemory_autoptr = *mut GstMemory;
pub type GstMemory_listautoptr = *mut GList;
pub type GstMemory_slistautoptr = *mut GSList;
pub type GstMemory_queueautoptr = *mut GQueue;
pub type GstAllocator_autoptr = *mut GstAllocator;
pub type GstAllocator_listautoptr = *mut GList;
pub type GstAllocator_slistautoptr = *mut GSList;
pub type GstAllocator_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAllocatorPrivate {
    _unused: [u8; 0],
}
pub type GstAllocatorPrivate = _GstAllocatorPrivate;
#[doc = " GstAllocatorClass:\n @object_class:  Object parent class\n @alloc: implementation that acquires memory\n @free: implementation that releases memory\n\n The #GstAllocator is used to create new memory."]
pub type GstAllocatorClass = _GstAllocatorClass;
unsafe extern "C" {
    pub fn gst_allocation_params_get_type() -> GType;
}
#[doc = " GstAllocationParams:\n @flags: flags to control allocation\n @align: the desired alignment of the memory\n @prefix: the desired prefix\n @padding: the desired padding\n\n Parameters to control the allocation of memory"]
pub type GstAllocationParams = _GstAllocationParams;
unsafe extern "C" {
    #[doc = " gst_memory_alignment:\n\n The default memory alignment in bytes - 1\n an alignment of 7 would be the same as what malloc() guarantees."]
    pub static mut gst_memory_alignment: gsize;
}
#[doc = " GstAllocationParams:\n @flags: flags to control allocation\n @align: the desired alignment of the memory\n @prefix: the desired prefix\n @padding: the desired padding\n\n Parameters to control the allocation of memory"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAllocationParams {
    pub flags: GstMemoryFlags,
    pub align: gsize,
    pub prefix: gsize,
    pub padding: gsize,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAllocationParams"][::std::mem::size_of::<_GstAllocationParams>() - 64usize];
    ["Alignment of _GstAllocationParams"][::std::mem::align_of::<_GstAllocationParams>() - 8usize];
    ["Offset of field: _GstAllocationParams::flags"]
        [::std::mem::offset_of!(_GstAllocationParams, flags) - 0usize];
    ["Offset of field: _GstAllocationParams::align"]
        [::std::mem::offset_of!(_GstAllocationParams, align) - 8usize];
    ["Offset of field: _GstAllocationParams::prefix"]
        [::std::mem::offset_of!(_GstAllocationParams, prefix) - 16usize];
    ["Offset of field: _GstAllocationParams::padding"]
        [::std::mem::offset_of!(_GstAllocationParams, padding) - 24usize];
    ["Offset of field: _GstAllocationParams::_gst_reserved"]
        [::std::mem::offset_of!(_GstAllocationParams, _gst_reserved) - 32usize];
};
pub const GstAllocatorFlags_GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: GstAllocatorFlags = 16;
pub const GstAllocatorFlags_GST_ALLOCATOR_FLAG_LAST: GstAllocatorFlags = 1048576;
#[doc = " GstAllocatorFlags:\n @GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: The allocator has a custom alloc function.\n @GST_ALLOCATOR_FLAG_LAST: first flag that can be used for custom purposes\n\n Flags for allocators."]
pub type GstAllocatorFlags = ::std::os::raw::c_uint;
#[doc = " GstAllocator:\n @mem_map: the implementation of the GstMemoryMapFunction\n @mem_unmap: the implementation of the GstMemoryUnmapFunction\n @mem_copy: the implementation of the GstMemoryCopyFunction\n @mem_share: the implementation of the GstMemoryShareFunction\n @mem_is_span: the implementation of the GstMemoryIsSpanFunction\n @mem_map_full: the implementation of the GstMemoryMapFullFunction.\n      Will be used instead of @mem_map if present. (Since: 1.6)\n @mem_unmap_full: the implementation of the GstMemoryUnmapFullFunction.\n      Will be used instead of @mem_unmap if present. (Since: 1.6)\n\n The #GstAllocator is used to create new memory."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstAllocator {
    pub object: GstObject,
    pub mem_type: *const gchar,
    pub mem_map: GstMemoryMapFunction,
    pub mem_unmap: GstMemoryUnmapFunction,
    pub mem_copy: GstMemoryCopyFunction,
    pub mem_share: GstMemoryShareFunction,
    pub mem_is_span: GstMemoryIsSpanFunction,
    pub mem_map_full: GstMemoryMapFullFunction,
    pub mem_unmap_full: GstMemoryUnmapFullFunction,
    pub _gst_reserved: [gpointer; 2usize],
    pub priv_: *mut GstAllocatorPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAllocator"][::std::mem::size_of::<_GstAllocator>() - 176usize];
    ["Alignment of _GstAllocator"][::std::mem::align_of::<_GstAllocator>() - 8usize];
    ["Offset of field: _GstAllocator::object"]
        [::std::mem::offset_of!(_GstAllocator, object) - 0usize];
    ["Offset of field: _GstAllocator::mem_type"]
        [::std::mem::offset_of!(_GstAllocator, mem_type) - 88usize];
    ["Offset of field: _GstAllocator::mem_map"]
        [::std::mem::offset_of!(_GstAllocator, mem_map) - 96usize];
    ["Offset of field: _GstAllocator::mem_unmap"]
        [::std::mem::offset_of!(_GstAllocator, mem_unmap) - 104usize];
    ["Offset of field: _GstAllocator::mem_copy"]
        [::std::mem::offset_of!(_GstAllocator, mem_copy) - 112usize];
    ["Offset of field: _GstAllocator::mem_share"]
        [::std::mem::offset_of!(_GstAllocator, mem_share) - 120usize];
    ["Offset of field: _GstAllocator::mem_is_span"]
        [::std::mem::offset_of!(_GstAllocator, mem_is_span) - 128usize];
    ["Offset of field: _GstAllocator::mem_map_full"]
        [::std::mem::offset_of!(_GstAllocator, mem_map_full) - 136usize];
    ["Offset of field: _GstAllocator::mem_unmap_full"]
        [::std::mem::offset_of!(_GstAllocator, mem_unmap_full) - 144usize];
    ["Offset of field: _GstAllocator::_gst_reserved"]
        [::std::mem::offset_of!(_GstAllocator, _gst_reserved) - 152usize];
    ["Offset of field: _GstAllocator::priv_"]
        [::std::mem::offset_of!(_GstAllocator, priv_) - 168usize];
};
#[doc = " GstAllocatorClass:\n @object_class:  Object parent class\n @alloc: implementation that acquires memory\n @free: implementation that releases memory\n\n The #GstAllocator is used to create new memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAllocatorClass {
    pub object_class: GstObjectClass,
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut GstAllocator,
            size: gsize,
            params: *mut GstAllocationParams,
        ) -> *mut GstMemory,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(allocator: *mut GstAllocator, memory: *mut GstMemory),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAllocatorClass"][::std::mem::size_of::<_GstAllocatorClass>() - 232usize];
    ["Alignment of _GstAllocatorClass"][::std::mem::align_of::<_GstAllocatorClass>() - 8usize];
    ["Offset of field: _GstAllocatorClass::object_class"]
        [::std::mem::offset_of!(_GstAllocatorClass, object_class) - 0usize];
    ["Offset of field: _GstAllocatorClass::alloc"]
        [::std::mem::offset_of!(_GstAllocatorClass, alloc) - 184usize];
    ["Offset of field: _GstAllocatorClass::free"]
        [::std::mem::offset_of!(_GstAllocatorClass, free) - 192usize];
    ["Offset of field: _GstAllocatorClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstAllocatorClass, _gst_reserved) - 200usize];
};
unsafe extern "C" {
    pub fn gst_allocator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_allocator_register(name: *const gchar, allocator: *mut GstAllocator);
}
unsafe extern "C" {
    pub fn gst_allocator_find(name: *const gchar) -> *mut GstAllocator;
}
unsafe extern "C" {
    pub fn gst_allocator_set_default(allocator: *mut GstAllocator);
}
unsafe extern "C" {
    pub fn gst_allocation_params_new() -> *mut GstAllocationParams;
}
unsafe extern "C" {
    pub fn gst_allocation_params_init(params: *mut GstAllocationParams);
}
unsafe extern "C" {
    pub fn gst_allocation_params_copy(
        params: *const GstAllocationParams,
    ) -> *mut GstAllocationParams;
}
unsafe extern "C" {
    pub fn gst_allocation_params_free(params: *mut GstAllocationParams);
}
unsafe extern "C" {
    pub fn gst_allocator_alloc(
        allocator: *mut GstAllocator,
        size: gsize,
        params: *mut GstAllocationParams,
    ) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_allocator_free(allocator: *mut GstAllocator, memory: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_memory_new_wrapped(
        flags: GstMemoryFlags,
        data: gpointer,
        maxsize: gsize,
        offset: gsize,
        size: gsize,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GstMemory;
}
pub type GstAllocationParams_autoptr = *mut GstAllocationParams;
pub type GstAllocationParams_listautoptr = *mut GList;
pub type GstAllocationParams_slistautoptr = *mut GSList;
pub type GstAllocationParams_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDateTime {
    _unused: [u8; 0],
}
#[doc = " GstDateTime:\n\n Opaque, immutable, refcounted struct that stores date, time and timezone\n information. It currently supports ranges from `0001-01-01` to\n `9999-12-31` in the Gregorian proleptic calendar.\n\n Use the accessor functions to get the stored values."]
pub type GstDateTime = _GstDateTime;
unsafe extern "C" {
    pub static mut _gst_date_time_type: GType;
}
unsafe extern "C" {
    pub fn gst_date_time_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_date_time_has_year(datetime: *const GstDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_date_time_has_month(datetime: *const GstDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_date_time_has_day(datetime: *const GstDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_date_time_has_time(datetime: *const GstDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_date_time_has_second(datetime: *const GstDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_date_time_get_year(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_month(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_day(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_hour(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_minute(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_second(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_microsecond(datetime: *const GstDateTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_date_time_get_time_zone_offset(datetime: *const GstDateTime) -> gfloat;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_unix_epoch_local_time(secs: gint64) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_unix_epoch_utc(secs: gint64) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_unix_epoch_local_time_usecs(usecs: gint64) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_unix_epoch_utc_usecs(usecs: gint64) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_local_time(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_y(year: gint) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_ym(year: gint, month: gint) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_ymd(year: gint, month: gint, day: gint) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new(
        tzoffset: gfloat,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_now_local_time() -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_now_utc() -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_to_iso8601_string(datetime: *mut GstDateTime) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_iso8601_string(string: *const gchar) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_to_g_date_time(datetime: *mut GstDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_new_from_g_date_time(dt: *mut GDateTime) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_ref(datetime: *mut GstDateTime) -> *mut GstDateTime;
}
unsafe extern "C" {
    pub fn gst_date_time_unref(datetime: *mut GstDateTime);
}
pub type GstDateTime_autoptr = *mut GstDateTime;
pub type GstDateTime_listautoptr = *mut GList;
pub type GstDateTime_slistautoptr = *mut GSList;
pub type GstDateTime_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_structure_type: GType;
}
#[doc = " GstStructure:\n @type: the GType of a structure\n\n The GstStructure object. Most fields are private."]
pub type GstStructure = _GstStructure;
pub const GstSerializeFlags_GST_SERIALIZE_FLAG_NONE: GstSerializeFlags = 0;
pub const GstSerializeFlags_GST_SERIALIZE_FLAG_BACKWARD_COMPAT: GstSerializeFlags = 1;
#[doc = " GstSerializeFlags:\n @GST_SERIALIZE_FLAG_NONE: No special flags specified.\n @GST_SERIALIZE_FLAG_BACKWARD_COMPAT: Serialize using the old format for\n                                      nested structures.\n\n Since: 1.20"]
pub type GstSerializeFlags = ::std::os::raw::c_uint;
#[doc = " GstStructureForeachFunc:\n @field_id: the #GQuark of the field name\n @value: the #GValue of the field\n @user_data: user data\n\n A function that will be called in gst_structure_foreach(). The function may\n not modify @value.\n\n Returns: %TRUE if the foreach operation should continue, %FALSE if\n the foreach operation should stop with %FALSE."]
pub type GstStructureForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(field_id: GQuark, value: *const GValue, user_data: gpointer) -> gboolean,
>;
#[doc = " GstStructureMapFunc:\n @field_id: the #GQuark of the field name\n @value: the #GValue of the field\n @user_data: user data\n\n A function that will be called in gst_structure_map_in_place(). The function\n may modify @value.\n\n Returns: %TRUE if the map operation should continue, %FALSE if\n the map operation should stop with %FALSE."]
pub type GstStructureMapFunc = ::std::option::Option<
    unsafe extern "C" fn(field_id: GQuark, value: *mut GValue, user_data: gpointer) -> gboolean,
>;
#[doc = " GstStructureFilterMapFunc:\n @field_id: the #GQuark of the field name\n @value: the #GValue of the field\n @user_data: user data\n\n A function that will be called in gst_structure_filter_and_map_in_place().\n The function may modify @value, and the value will be removed from\n the structure if %FALSE is returned.\n\n Returns: %TRUE if the field should be preserved, %FALSE if it\n should be removed."]
pub type GstStructureFilterMapFunc = ::std::option::Option<
    unsafe extern "C" fn(field_id: GQuark, value: *mut GValue, user_data: gpointer) -> gboolean,
>;
#[doc = " GstStructure:\n @type: the GType of a structure\n\n The GstStructure object. Most fields are private."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStructure {
    pub type_: GType,
    pub name: GQuark,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStructure"][::std::mem::size_of::<_GstStructure>() - 16usize];
    ["Alignment of _GstStructure"][::std::mem::align_of::<_GstStructure>() - 8usize];
    ["Offset of field: _GstStructure::type_"]
        [::std::mem::offset_of!(_GstStructure, type_) - 0usize];
    ["Offset of field: _GstStructure::name"][::std::mem::offset_of!(_GstStructure, name) - 8usize];
};
unsafe extern "C" {
    pub fn gst_structure_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_structure_new_empty(name: *const gchar) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_new_id_empty(quark: GQuark) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_new(
        name: *const gchar,
        firstfield: *const gchar,
        ...
    ) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_new_valist(
        name: *const gchar,
        firstfield: *const gchar,
        varargs: *mut __va_list_tag,
    ) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_new_id(name_quark: GQuark, field_quark: GQuark, ...) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_new_from_string(string: *const gchar) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_copy(structure: *const GstStructure) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_set_parent_refcount(
        structure: *mut GstStructure,
        refcount: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_free(structure: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_clear_structure(structure_ptr: *mut *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_structure_take(
        oldstr_ptr: *mut *mut GstStructure,
        newstr: *mut GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_name(structure: *const GstStructure) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_structure_get_name_id(structure: *const GstStructure) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_structure_has_name(structure: *const GstStructure, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_set_name(structure: *mut GstStructure, name: *const gchar);
}
unsafe extern "C" {
    pub fn gst_structure_id_set_value(
        structure: *mut GstStructure,
        field: GQuark,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_structure_set_value(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_structure_set_array(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        array: *const GValueArray,
    );
}
unsafe extern "C" {
    pub fn gst_structure_set_list(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        array: *const GValueArray,
    );
}
unsafe extern "C" {
    pub fn gst_structure_id_take_value(
        structure: *mut GstStructure,
        field: GQuark,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn gst_structure_take_value(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn gst_structure_set(structure: *mut GstStructure, fieldname: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_structure_set_valist(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        varargs: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_structure_id_set(structure: *mut GstStructure, fieldname: GQuark, ...);
}
unsafe extern "C" {
    pub fn gst_structure_id_set_valist(
        structure: *mut GstStructure,
        fieldname: GQuark,
        varargs: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_structure_get_valist(
        structure: *const GstStructure,
        first_fieldname: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get(
        structure: *const GstStructure,
        first_fieldname: *const ::std::os::raw::c_char,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_id_get_valist(
        structure: *const GstStructure,
        first_field_id: GQuark,
        args: *mut __va_list_tag,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_id_get(
        structure: *const GstStructure,
        first_field_id: GQuark,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_id_get_value(
        structure: *const GstStructure,
        field: GQuark,
    ) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_structure_get_value(
        structure: *const GstStructure,
        fieldname: *const gchar,
    ) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_structure_remove_field(structure: *mut GstStructure, fieldname: *const gchar);
}
unsafe extern "C" {
    pub fn gst_structure_remove_fields(structure: *mut GstStructure, fieldname: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_structure_remove_fields_valist(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        varargs: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_structure_remove_all_fields(structure: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_structure_get_field_type(
        structure: *const GstStructure,
        fieldname: *const gchar,
    ) -> GType;
}
unsafe extern "C" {
    pub fn gst_structure_foreach(
        structure: *const GstStructure,
        func: GstStructureForeachFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_map_in_place(
        structure: *mut GstStructure,
        func: GstStructureMapFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_filter_and_map_in_place(
        structure: *mut GstStructure,
        func: GstStructureFilterMapFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_structure_n_fields(structure: *const GstStructure) -> gint;
}
unsafe extern "C" {
    pub fn gst_structure_nth_field_name(
        structure: *const GstStructure,
        index: guint,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_structure_id_has_field(structure: *const GstStructure, field: GQuark) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_id_has_field_typed(
        structure: *const GstStructure,
        field: GQuark,
        type_: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_has_field(
        structure: *const GstStructure,
        fieldname: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_has_field_typed(
        structure: *const GstStructure,
        fieldname: *const gchar,
        type_: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_boolean(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_int(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_uint(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_int64(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_uint64(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_double(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_date(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut *mut GDate,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_date_time(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_clock_time(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value: *mut GstClockTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_string(
        structure: *const GstStructure,
        fieldname: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_structure_get_enum(
        structure: *const GstStructure,
        fieldname: *const gchar,
        enumtype: GType,
        value: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_fraction(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value_numerator: *mut gint,
        value_denominator: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_flagset(
        structure: *const GstStructure,
        fieldname: *const gchar,
        value_flags: *mut guint,
        value_mask: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_array(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        array: *mut *mut GValueArray,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_get_list(
        structure: *mut GstStructure,
        fieldname: *const gchar,
        array: *mut *mut GValueArray,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_to_string(structure: *const GstStructure) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_structure_serialize(
        structure: *const GstStructure,
        flags: GstSerializeFlags,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_structure_from_string(
        string: *const gchar,
        end: *mut *mut gchar,
    ) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field_nearest_int(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
        target: ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field_nearest_double(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
        target: f64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field_boolean(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
        target: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field_string(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
        target: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field_nearest_fraction(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
        target_numerator: gint,
        target_denominator: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate_field(
        structure: *mut GstStructure,
        field_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_fixate(structure: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_structure_is_equal(
        structure1: *const GstStructure,
        structure2: *const GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_is_subset(
        subset: *const GstStructure,
        superset: *const GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_can_intersect(
        struct1: *const GstStructure,
        struct2: *const GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_structure_intersect(
        struct1: *const GstStructure,
        struct2: *const GstStructure,
    ) -> *mut GstStructure;
}
pub type GstStructure_autoptr = *mut GstStructure;
pub type GstStructure_listautoptr = *mut GList;
pub type GstStructure_slistautoptr = *mut GSList;
pub type GstStructure_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstCapsFeatures {
    _unused: [u8; 0],
}
pub type GstCapsFeatures = _GstCapsFeatures;
unsafe extern "C" {
    pub static mut _gst_caps_features_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_caps_features_any: *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub static mut _gst_caps_features_memory_system_memory: *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_is_caps_features(obj: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_empty() -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_any() -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_single(feature: *const gchar) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new(feature1: *const gchar, ...) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_valist(
        feature1: *const gchar,
        varargs: *mut __va_list_tag,
    ) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_id(feature1: GQuark, ...) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_new_id_valist(
        feature1: GQuark,
        varargs: *mut __va_list_tag,
    ) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_set_parent_refcount(
        features: *mut GstCapsFeatures,
        refcount: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_copy(features: *const GstCapsFeatures) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_free(features: *mut GstCapsFeatures);
}
unsafe extern "C" {
    pub fn gst_caps_features_to_string(features: *const GstCapsFeatures) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_caps_features_from_string(features: *const gchar) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_features_get_size(features: *const GstCapsFeatures) -> guint;
}
unsafe extern "C" {
    pub fn gst_caps_features_get_nth(features: *const GstCapsFeatures, i: guint) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_caps_features_get_nth_id(features: *const GstCapsFeatures, i: guint) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_caps_features_contains(
        features: *const GstCapsFeatures,
        feature: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_contains_id(
        features: *const GstCapsFeatures,
        feature: GQuark,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_is_equal(
        features1: *const GstCapsFeatures,
        features2: *const GstCapsFeatures,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_is_any(features: *const GstCapsFeatures) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_features_add(features: *mut GstCapsFeatures, feature: *const gchar);
}
unsafe extern "C" {
    pub fn gst_caps_features_add_id(features: *mut GstCapsFeatures, feature: GQuark);
}
unsafe extern "C" {
    pub fn gst_caps_features_remove(features: *mut GstCapsFeatures, feature: *const gchar);
}
unsafe extern "C" {
    pub fn gst_caps_features_remove_id(features: *mut GstCapsFeatures, feature: GQuark);
}
pub type GstCapsFeatures_autoptr = *mut GstCapsFeatures;
pub type GstCapsFeatures_listautoptr = *mut GList;
pub type GstCapsFeatures_slistautoptr = *mut GSList;
pub type GstCapsFeatures_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_caps_type: GType;
}
pub const GstCapsFlags_GST_CAPS_FLAG_ANY: GstCapsFlags = 16;
#[doc = " GstCapsFlags:\n @GST_CAPS_FLAG_ANY: Caps has no specific content, but can contain\n    anything.\n\n Extra flags for a caps."]
pub type GstCapsFlags = ::std::os::raw::c_uint;
pub const GstCapsIntersectMode_GST_CAPS_INTERSECT_ZIG_ZAG: GstCapsIntersectMode = 0;
pub const GstCapsIntersectMode_GST_CAPS_INTERSECT_FIRST: GstCapsIntersectMode = 1;
#[doc = " GstCapsIntersectMode:\n @GST_CAPS_INTERSECT_ZIG_ZAG  : Zig-zags over both caps.\n @GST_CAPS_INTERSECT_FIRST    : Keeps the first caps order.\n\n Modes of caps intersection\n\n %GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps\n by iterating on the caps' structures as the following matrix shows:\n\n ```\n          caps1\n       +-------------\n       | 1  2  4  7\n caps2 | 3  5  8 10\n       | 6  9 11 12\n ```\n\n Used when there is no explicit precedence of one caps over the other. e.g.\n tee's sink pad getcaps function, it will probe its src pad peers' for their\n caps and intersect them with this mode.\n\n %GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve\n another element's caps priority order when intersecting with its own caps.\n Example: If caps1 is `[A, B, C]` and caps2 is `[E, B, D, A]`, the result\n would be `[A, B]`, maintaining the first caps priority on the intersection."]
pub type GstCapsIntersectMode = ::std::os::raw::c_uint;
#[doc = " GstCaps:\n @mini_object: the parent type\n\n Object describing media types."]
pub type GstCaps = _GstCaps;
#[doc = " GstStaticCaps:\n @caps: the cached #GstCaps\n @string: a string describing a caps\n\n Data structure to initialize #GstCaps from a string description usually\n used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get() to\n instantiate a #GstCaps."]
pub type GstStaticCaps = _GstStaticCaps;
unsafe extern "C" {
    pub static mut _gst_caps_any: *mut GstCaps;
}
unsafe extern "C" {
    pub static mut _gst_caps_none: *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_copy(caps: *const GstCaps) -> *mut GstCaps;
}
#[doc = " GstCaps:\n @mini_object: the parent type\n\n Object describing media types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstCaps {
    pub mini_object: GstMiniObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstCaps"][::std::mem::size_of::<_GstCaps>() - 64usize];
    ["Alignment of _GstCaps"][::std::mem::align_of::<_GstCaps>() - 8usize];
    ["Offset of field: _GstCaps::mini_object"]
        [::std::mem::offset_of!(_GstCaps, mini_object) - 0usize];
};
#[doc = " GstStaticCaps:\n @caps: the cached #GstCaps\n @string: a string describing a caps\n\n Data structure to initialize #GstCaps from a string description usually\n used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get() to\n instantiate a #GstCaps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStaticCaps {
    pub caps: *mut GstCaps,
    pub string: *const ::std::os::raw::c_char,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStaticCaps"][::std::mem::size_of::<_GstStaticCaps>() - 48usize];
    ["Alignment of _GstStaticCaps"][::std::mem::align_of::<_GstStaticCaps>() - 8usize];
    ["Offset of field: _GstStaticCaps::caps"]
        [::std::mem::offset_of!(_GstStaticCaps, caps) - 0usize];
    ["Offset of field: _GstStaticCaps::string"]
        [::std::mem::offset_of!(_GstStaticCaps, string) - 8usize];
    ["Offset of field: _GstStaticCaps::_gst_reserved"]
        [::std::mem::offset_of!(_GstStaticCaps, _gst_reserved) - 16usize];
};
#[doc = " GstCapsForeachFunc:\n @features: the #GstCapsFeatures\n @structure: the #GstStructure\n @user_data: user data\n\n A function that will be called in gst_caps_foreach(). The function may\n not modify @features or @structure.\n\n Returns: %TRUE if the foreach operation should continue, %FALSE if\n the foreach operation should stop with %FALSE.\n\n Since: 1.6"]
pub type GstCapsForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(
        features: *mut GstCapsFeatures,
        structure: *mut GstStructure,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstCapsMapFunc:\n @features: the #GstCapsFeatures\n @structure: the #GstStructure\n @user_data: user data\n\n A function that will be called in gst_caps_map_in_place(). The function\n may modify @features and @structure.\n\n Returns: %TRUE if the map operation should continue, %FALSE if\n the map operation should stop with %FALSE."]
pub type GstCapsMapFunc = ::std::option::Option<
    unsafe extern "C" fn(
        features: *mut GstCapsFeatures,
        structure: *mut GstStructure,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstCapsFilterMapFunc:\n @features: the #GstCapsFeatures\n @structure: the #GstStructure\n @user_data: user data\n\n A function that will be called in gst_caps_filter_and_map_in_place().\n The function may modify @features and @structure, and both will be\n removed from the caps if %FALSE is returned.\n\n Returns: %TRUE if the features and structure should be preserved,\n %FALSE if it should be removed."]
pub type GstCapsFilterMapFunc = ::std::option::Option<
    unsafe extern "C" fn(
        features: *mut GstCapsFeatures,
        structure: *mut GstStructure,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_caps_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_caps_new_empty() -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_new_any() -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_new_empty_simple(media_type: *const ::std::os::raw::c_char) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_new_simple(
        media_type: *const ::std::os::raw::c_char,
        fieldname: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_new_full(struct1: *mut GstStructure, ...) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_new_full_valist(
        structure: *mut GstStructure,
        var_args: *mut __va_list_tag,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    #[doc = " gst_static_caps_get_type: (attributes doc.skip=true)"]
    pub fn gst_static_caps_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_static_caps_get(static_caps: *mut GstStaticCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_static_caps_cleanup(static_caps: *mut GstStaticCaps);
}
unsafe extern "C" {
    pub fn gst_caps_append(caps1: *mut GstCaps, caps2: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_caps_append_structure(caps: *mut GstCaps, structure: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_caps_append_structure_full(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
        features: *mut GstCapsFeatures,
    );
}
unsafe extern "C" {
    pub fn gst_caps_remove_structure(caps: *mut GstCaps, idx: guint);
}
unsafe extern "C" {
    pub fn gst_caps_merge(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_merge_structure(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_merge_structure_full(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
        features: *mut GstCapsFeatures,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_get_size(caps: *const GstCaps) -> guint;
}
unsafe extern "C" {
    pub fn gst_caps_get_structure(caps: *const GstCaps, index: guint) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_caps_steal_structure(caps: *mut GstCaps, index: guint) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_caps_set_features(caps: *mut GstCaps, index: guint, features: *mut GstCapsFeatures);
}
unsafe extern "C" {
    pub fn gst_caps_set_features_simple(caps: *mut GstCaps, features: *mut GstCapsFeatures);
}
unsafe extern "C" {
    pub fn gst_caps_get_features(caps: *const GstCaps, index: guint) -> *mut GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_caps_copy_nth(caps: *const GstCaps, nth: guint) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_truncate(caps: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_set_value(
        caps: *mut GstCaps,
        field: *const ::std::os::raw::c_char,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_caps_set_simple(caps: *mut GstCaps, field: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn gst_caps_set_simple_valist(
        caps: *mut GstCaps,
        field: *const ::std::os::raw::c_char,
        varargs: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_caps_foreach(
        caps: *const GstCaps,
        func: GstCapsForeachFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_map_in_place(
        caps: *mut GstCaps,
        func: GstCapsMapFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_filter_and_map_in_place(
        caps: *mut GstCaps,
        func: GstCapsFilterMapFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_caps_is_any(caps: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_empty(caps: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_fixed(caps: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_always_compatible(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_subset(subset: *const GstCaps, superset: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_subset_structure(
        caps: *const GstCaps,
        structure: *const GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_subset_structure_full(
        caps: *const GstCaps,
        structure: *const GstStructure,
        features: *const GstCapsFeatures,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_equal_fixed(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_can_intersect(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_is_strictly_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_caps_intersect(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_intersect_full(
        caps1: *mut GstCaps,
        caps2: *mut GstCaps,
        mode: GstCapsIntersectMode,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_subtract(minuend: *mut GstCaps, subtrahend: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_normalize(caps: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_simplify(caps: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_fixate(caps: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_caps_to_string(caps: *const GstCaps) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_caps_serialize(caps: *const GstCaps, flags: GstSerializeFlags) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_caps_from_string(string: *const gchar) -> *mut GstCaps;
}
pub type GstCaps_autoptr = *mut GstCaps;
pub type GstCaps_listautoptr = *mut GList;
pub type GstCaps_slistautoptr = *mut GSList;
pub type GstCaps_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_buffer_type: GType;
}
#[doc = " GstBuffer:\n @mini_object: the parent structure\n @pool: pointer to the pool owner of the buffer\n @pts: presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     pts is not known or relevant. The pts contains the timestamp when the\n     media should be presented to the user.\n @dts: decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     dts is not known or relevant. The dts contains the timestamp when the\n     media should be processed.\n @duration: duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE\n     when the duration is not known or relevant.\n @offset: a media specific offset for the buffer data.\n     For video frames, this is the frame number of this buffer.\n     For audio samples, this is the offset of the first sample in this buffer.\n     For file data or compressed data this is the byte offset of the first\n       byte in this buffer.\n @offset_end: the last offset contained in this buffer. It has the same\n     format as @offset.\n\n The structure of a #GstBuffer. Use the associated macros to access the public\n variables."]
pub type GstBuffer = _GstBuffer;
#[doc = " GstBufferPool:\n @object: the parent structure\n @flushing: whether the pool is currently gathering back outstanding buffers\n\n The structure of a #GstBufferPool. Use the associated macros to access the public\n variables."]
pub type GstBufferPool = _GstBufferPool;
#[doc = " GstMeta:\n @flags: extra flags for the metadata\n @info: pointer to the #GstMetaInfo\n\n Base structure for metadata. Custom metadata will put this structure\n as the first member of their structure."]
pub type GstMeta = _GstMeta;
#[doc = " GstMetaInfo:\n @api: tag identifying the metadata structure and api\n @type: type identifying the implementor of the api\n @size: size of the metadata\n @init_func: function for initializing the metadata\n @free_func: function for freeing the metadata\n @transform_func: function for transforming the metadata\n\n The #GstMetaInfo provides information about a specific metadata\n structure."]
pub type GstMetaInfo = _GstMetaInfo;
pub const GstMetaFlags_GST_META_FLAG_NONE: GstMetaFlags = 0;
pub const GstMetaFlags_GST_META_FLAG_READONLY: GstMetaFlags = 1;
pub const GstMetaFlags_GST_META_FLAG_POOLED: GstMetaFlags = 2;
pub const GstMetaFlags_GST_META_FLAG_LOCKED: GstMetaFlags = 4;
pub const GstMetaFlags_GST_META_FLAG_LAST: GstMetaFlags = 65536;
#[doc = " GstMetaFlags:\n @GST_META_FLAG_NONE: no flags\n @GST_META_FLAG_READONLY: metadata should not be modified\n @GST_META_FLAG_POOLED: metadata is managed by a bufferpool\n @GST_META_FLAG_LOCKED: metadata should not be removed\n @GST_META_FLAG_LAST: additional flags can be added starting from this flag.\n\n Extra metadata flags."]
pub type GstMetaFlags = ::std::os::raw::c_uint;
#[doc = " GstMeta:\n @flags: extra flags for the metadata\n @info: pointer to the #GstMetaInfo\n\n Base structure for metadata. Custom metadata will put this structure\n as the first member of their structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstMeta"][::std::mem::size_of::<_GstMeta>() - 16usize];
    ["Alignment of _GstMeta"][::std::mem::align_of::<_GstMeta>() - 8usize];
    ["Offset of field: _GstMeta::flags"][::std::mem::offset_of!(_GstMeta, flags) - 0usize];
    ["Offset of field: _GstMeta::info"][::std::mem::offset_of!(_GstMeta, info) - 8usize];
};
#[doc = " GstCustomMeta:\n\n Simple typing wrapper around #GstMeta\n\n Since: 1.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstCustomMeta {
    pub meta: GstMeta,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstCustomMeta"][::std::mem::size_of::<GstCustomMeta>() - 16usize];
    ["Alignment of GstCustomMeta"][::std::mem::align_of::<GstCustomMeta>() - 8usize];
    ["Offset of field: GstCustomMeta::meta"][::std::mem::offset_of!(GstCustomMeta, meta) - 0usize];
};
#[doc = " GstMetaInitFunction:\n @meta: a #GstMeta\n @params: parameters passed to the init function\n @buffer: a #GstBuffer\n\n Function called when @meta is initialized in @buffer."]
pub type GstMetaInitFunction = ::std::option::Option<
    unsafe extern "C" fn(meta: *mut GstMeta, params: gpointer, buffer: *mut GstBuffer) -> gboolean,
>;
#[doc = " GstMetaFreeFunction:\n @meta: a #GstMeta\n @buffer: a #GstBuffer\n\n Function called when @meta is freed in @buffer."]
pub type GstMetaFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(meta: *mut GstMeta, buffer: *mut GstBuffer)>;
unsafe extern "C" {
    #[doc = " gst_meta_transform_copy:\n\n GQuark for the \"gst-copy\" transform."]
    pub static mut _gst_meta_transform_copy: GQuark;
}
#[doc = " GstMetaTransformCopy:\n @region: %TRUE if only region is copied\n @offset: the offset to copy, 0 if @region is %FALSE, otherwise > 0\n @size: the size to copy, -1 or the buffer size when @region is %FALSE\n\n Extra data passed to a \"gst-copy\" transform #GstMetaTransformFunction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstMetaTransformCopy {
    pub region: gboolean,
    pub offset: gsize,
    pub size: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstMetaTransformCopy"][::std::mem::size_of::<GstMetaTransformCopy>() - 24usize];
    ["Alignment of GstMetaTransformCopy"][::std::mem::align_of::<GstMetaTransformCopy>() - 8usize];
    ["Offset of field: GstMetaTransformCopy::region"]
        [::std::mem::offset_of!(GstMetaTransformCopy, region) - 0usize];
    ["Offset of field: GstMetaTransformCopy::offset"]
        [::std::mem::offset_of!(GstMetaTransformCopy, offset) - 8usize];
    ["Offset of field: GstMetaTransformCopy::size"]
        [::std::mem::offset_of!(GstMetaTransformCopy, size) - 16usize];
};
#[doc = " GstMetaTransformFunction:\n @transbuf: a #GstBuffer\n @meta: a #GstMeta\n @buffer: a #GstBuffer\n @type: the transform type\n @data: transform specific data.\n\n Function called for each @meta in @buffer as a result of performing a\n transformation on @transbuf. Additional @type specific transform data\n is passed to the function as @data.\n\n Implementations should check the @type of the transform and parse\n additional type specific fields in @data that should be used to update\n the metadata on @transbuf.\n\n Returns: %TRUE if the transform could be performed"]
pub type GstMetaTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        transbuf: *mut GstBuffer,
        meta: *mut GstMeta,
        buffer: *mut GstBuffer,
        type_: GQuark,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstCustomMetaTransformFunction:\n @transbuf: a #GstBuffer\n @meta: a #GstCustomMeta\n @buffer: a #GstBuffer\n @type: the transform type\n @data: transform specific data.\n @user_data: user data passed when registering the meta\n\n Function called for each @meta in @buffer as a result of performing a\n transformation on @transbuf. Additional @type specific transform data\n is passed to the function as @data.\n\n Implementations should check the @type of the transform and parse\n additional type specific fields in @data that should be used to update\n the metadata on @transbuf.\n\n Returns: %TRUE if the transform could be performed\n Since: 1.20"]
pub type GstCustomMetaTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        transbuf: *mut GstBuffer,
        meta: *mut GstCustomMeta,
        buffer: *mut GstBuffer,
        type_: GQuark,
        data: gpointer,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstMetaInfo:\n @api: tag identifying the metadata structure and api\n @type: type identifying the implementor of the api\n @size: size of the metadata\n @init_func: function for initializing the metadata\n @free_func: function for freeing the metadata\n @transform_func: function for transforming the metadata\n\n The #GstMetaInfo provides information about a specific metadata\n structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: gsize,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstMetaInfo"][::std::mem::size_of::<_GstMetaInfo>() - 48usize];
    ["Alignment of _GstMetaInfo"][::std::mem::align_of::<_GstMetaInfo>() - 8usize];
    ["Offset of field: _GstMetaInfo::api"][::std::mem::offset_of!(_GstMetaInfo, api) - 0usize];
    ["Offset of field: _GstMetaInfo::type_"][::std::mem::offset_of!(_GstMetaInfo, type_) - 8usize];
    ["Offset of field: _GstMetaInfo::size"][::std::mem::offset_of!(_GstMetaInfo, size) - 16usize];
    ["Offset of field: _GstMetaInfo::init_func"]
        [::std::mem::offset_of!(_GstMetaInfo, init_func) - 24usize];
    ["Offset of field: _GstMetaInfo::free_func"]
        [::std::mem::offset_of!(_GstMetaInfo, free_func) - 32usize];
    ["Offset of field: _GstMetaInfo::transform_func"]
        [::std::mem::offset_of!(_GstMetaInfo, transform_func) - 40usize];
};
unsafe extern "C" {
    pub fn gst_meta_api_type_register(api: *const gchar, tags: *mut *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn gst_meta_api_type_has_tag(api: GType, tag: GQuark) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_meta_register(
        api: GType,
        impl_: *const gchar,
        size: gsize,
        init_func: GstMetaInitFunction,
        free_func: GstMetaFreeFunction,
        transform_func: GstMetaTransformFunction,
    ) -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_meta_register_custom(
        name: *const gchar,
        tags: *mut *const gchar,
        transform_func: GstCustomMetaTransformFunction,
        user_data: gpointer,
        destroy_data: GDestroyNotify,
    ) -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_meta_info_is_custom(info: *const GstMetaInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_custom_meta_get_structure(meta: *mut GstCustomMeta) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_custom_meta_has_name(meta: *mut GstCustomMeta, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_meta_get_info(impl_: *const gchar) -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_meta_api_type_get_tags(api: GType) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn gst_meta_get_seqnum(meta: *const GstMeta) -> guint64;
}
unsafe extern "C" {
    pub fn gst_meta_compare_seqnum(meta1: *const GstMeta, meta2: *const GstMeta) -> gint;
}
unsafe extern "C" {
    pub static mut _gst_meta_tag_memory: GQuark;
}
pub const GstBufferFlags_GST_BUFFER_FLAG_LIVE: GstBufferFlags = 16;
pub const GstBufferFlags_GST_BUFFER_FLAG_DECODE_ONLY: GstBufferFlags = 32;
pub const GstBufferFlags_GST_BUFFER_FLAG_DISCONT: GstBufferFlags = 64;
pub const GstBufferFlags_GST_BUFFER_FLAG_RESYNC: GstBufferFlags = 128;
pub const GstBufferFlags_GST_BUFFER_FLAG_CORRUPTED: GstBufferFlags = 256;
pub const GstBufferFlags_GST_BUFFER_FLAG_MARKER: GstBufferFlags = 512;
pub const GstBufferFlags_GST_BUFFER_FLAG_HEADER: GstBufferFlags = 1024;
pub const GstBufferFlags_GST_BUFFER_FLAG_GAP: GstBufferFlags = 2048;
pub const GstBufferFlags_GST_BUFFER_FLAG_DROPPABLE: GstBufferFlags = 4096;
pub const GstBufferFlags_GST_BUFFER_FLAG_DELTA_UNIT: GstBufferFlags = 8192;
pub const GstBufferFlags_GST_BUFFER_FLAG_TAG_MEMORY: GstBufferFlags = 16384;
#[doc = " GST_BUFFER_FLAG_SYNC_AFTER:\n\n Elements which write to disk or permanent storage should ensure the data\n is synced after writing the contents of this buffer.\n\n Since: 1.6"]
pub const GstBufferFlags_GST_BUFFER_FLAG_SYNC_AFTER: GstBufferFlags = 32768;
#[doc = " GST_BUFFER_FLAG_NON_DROPPABLE:\n\n This buffer is important and should not be dropped.\n\n This can be used to mark important buffers, e.g. to flag RTP packets\n carrying keyframes or codec setup data for RTP Forward Error Correction\n purposes, or to prevent still video frames from being dropped by elements\n due to QoS.\n\n Since: 1.14"]
pub const GstBufferFlags_GST_BUFFER_FLAG_NON_DROPPABLE: GstBufferFlags = 65536;
#[doc = " GST_BUFFER_FLAG_NON_DROPPABLE:\n\n This buffer is important and should not be dropped.\n\n This can be used to mark important buffers, e.g. to flag RTP packets\n carrying keyframes or codec setup data for RTP Forward Error Correction\n purposes, or to prevent still video frames from being dropped by elements\n due to QoS.\n\n Since: 1.14"]
pub const GstBufferFlags_GST_BUFFER_FLAG_LAST: GstBufferFlags = 1048576;
#[doc = " GstBufferFlags:\n @GST_BUFFER_FLAG_LIVE:          the buffer is live data and should be discarded in\n                                 the PAUSED state.\n @GST_BUFFER_FLAG_DECODE_ONLY:   the buffer contains data that should be dropped\n                                 because it will be clipped against the segment\n                                 boundaries or because it does not contain data\n                                 that should be shown to the user.\n @GST_BUFFER_FLAG_DISCONT:       the buffer marks a data discontinuity in the stream.\n                                 This typically occurs after a seek or a dropped buffer\n                                 from a live or network source.\n @GST_BUFFER_FLAG_RESYNC:        the buffer timestamps might have a discontinuity\n                                 and this buffer is a good point to resynchronize.\n @GST_BUFFER_FLAG_CORRUPTED:     the buffer data is corrupted.\n @GST_BUFFER_FLAG_MARKER:        the buffer contains a media specific marker. for\n                                 video this is the end of a frame boundary, for audio\n                                 this is the start of a talkspurt.\n @GST_BUFFER_FLAG_HEADER:        the buffer contains header information that is\n                                 needed to decode the following data.\n @GST_BUFFER_FLAG_GAP:           the buffer has been created to fill a gap in the\n                                 stream and contains media neutral data (elements can\n                                 switch to optimized code path that ignores the buffer\n                                 content).\n @GST_BUFFER_FLAG_DROPPABLE:     the buffer can be dropped without breaking the\n                                 stream, for example to reduce bandwidth.\n @GST_BUFFER_FLAG_DELTA_UNIT:    this unit cannot be decoded independently.\n @GST_BUFFER_FLAG_TAG_MEMORY:    this flag is set when memory of the buffer\n                                 is added/removed\n @GST_BUFFER_FLAG_LAST:          additional media specific flags can be added starting from\n                                 this flag.\n\n A set of buffer flags used to describe properties of a #GstBuffer."]
pub type GstBufferFlags = ::std::os::raw::c_uint;
#[doc = " GstBuffer:\n @mini_object: the parent structure\n @pool: pointer to the pool owner of the buffer\n @pts: presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     pts is not known or relevant. The pts contains the timestamp when the\n     media should be presented to the user.\n @dts: decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     dts is not known or relevant. The dts contains the timestamp when the\n     media should be processed.\n @duration: duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE\n     when the duration is not known or relevant.\n @offset: a media specific offset for the buffer data.\n     For video frames, this is the frame number of this buffer.\n     For audio samples, this is the offset of the first sample in this buffer.\n     For file data or compressed data this is the byte offset of the first\n       byte in this buffer.\n @offset_end: the last offset contained in this buffer. It has the same\n     format as @offset.\n\n The structure of a #GstBuffer. Use the associated macros to access the public\n variables."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: guint64,
    pub offset_end: guint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBuffer"][::std::mem::size_of::<_GstBuffer>() - 112usize];
    ["Alignment of _GstBuffer"][::std::mem::align_of::<_GstBuffer>() - 8usize];
    ["Offset of field: _GstBuffer::mini_object"]
        [::std::mem::offset_of!(_GstBuffer, mini_object) - 0usize];
    ["Offset of field: _GstBuffer::pool"][::std::mem::offset_of!(_GstBuffer, pool) - 64usize];
    ["Offset of field: _GstBuffer::pts"][::std::mem::offset_of!(_GstBuffer, pts) - 72usize];
    ["Offset of field: _GstBuffer::dts"][::std::mem::offset_of!(_GstBuffer, dts) - 80usize];
    ["Offset of field: _GstBuffer::duration"]
        [::std::mem::offset_of!(_GstBuffer, duration) - 88usize];
    ["Offset of field: _GstBuffer::offset"][::std::mem::offset_of!(_GstBuffer, offset) - 96usize];
    ["Offset of field: _GstBuffer::offset_end"]
        [::std::mem::offset_of!(_GstBuffer, offset_end) - 104usize];
};
unsafe extern "C" {
    pub fn gst_buffer_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_get_max_memory() -> guint;
}
unsafe extern "C" {
    pub fn gst_buffer_new() -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_new_allocate(
        allocator: *mut GstAllocator,
        size: gsize,
        params: *mut GstAllocationParams,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_new_wrapped_full(
        flags: GstMemoryFlags,
        data: gpointer,
        maxsize: gsize,
        offset: gsize,
        size: gsize,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_new_wrapped(data: gpointer, size: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_new_wrapped_bytes(bytes: *mut GBytes) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_new_memdup(data: gconstpointer, size: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_n_memory(buffer: *mut GstBuffer) -> guint;
}
unsafe extern "C" {
    pub fn gst_buffer_insert_memory(buffer: *mut GstBuffer, idx: gint, mem: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_buffer_replace_memory_range(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
        mem: *mut GstMemory,
    );
}
unsafe extern "C" {
    pub fn gst_buffer_peek_memory(buffer: *mut GstBuffer, idx: guint) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_buffer_get_memory_range(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
    ) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_buffer_remove_memory_range(buffer: *mut GstBuffer, idx: guint, length: gint);
}
unsafe extern "C" {
    pub fn gst_buffer_prepend_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_buffer_append_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_buffer_replace_memory(buffer: *mut GstBuffer, idx: guint, mem: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_buffer_replace_all_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
}
unsafe extern "C" {
    pub fn gst_buffer_get_memory(buffer: *mut GstBuffer, idx: guint) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_buffer_get_all_memory(buffer: *mut GstBuffer) -> *mut GstMemory;
}
unsafe extern "C" {
    pub fn gst_buffer_remove_memory(buffer: *mut GstBuffer, idx: guint);
}
unsafe extern "C" {
    pub fn gst_buffer_remove_all_memory(buffer: *mut GstBuffer);
}
unsafe extern "C" {
    pub fn gst_buffer_find_memory(
        buffer: *mut GstBuffer,
        offset: gsize,
        size: gsize,
        idx: *mut guint,
        length: *mut guint,
        skip: *mut gsize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_is_memory_range_writable(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_is_all_memory_writable(buffer: *mut GstBuffer) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_fill(
        buffer: *mut GstBuffer,
        offset: gsize,
        src: gconstpointer,
        size: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_extract(
        buffer: *mut GstBuffer,
        offset: gsize,
        dest: gpointer,
        size: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_memcmp(
        buffer: *mut GstBuffer,
        offset: gsize,
        mem: gconstpointer,
        size: gsize,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_buffer_memset(
        buffer: *mut GstBuffer,
        offset: gsize,
        val: guint8,
        size: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_get_sizes_range(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
        offset: *mut gsize,
        maxsize: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_resize_range(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
        offset: gssize,
        size: gssize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_get_sizes(
        buffer: *mut GstBuffer,
        offset: *mut gsize,
        maxsize: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_get_size(buffer: *mut GstBuffer) -> gsize;
}
unsafe extern "C" {
    pub fn gst_buffer_resize(buffer: *mut GstBuffer, offset: gssize, size: gssize);
}
unsafe extern "C" {
    pub fn gst_buffer_set_size(buffer: *mut GstBuffer, size: gssize);
}
unsafe extern "C" {
    pub fn gst_buffer_map_range(
        buffer: *mut GstBuffer,
        idx: guint,
        length: gint,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_map(
        buffer: *mut GstBuffer,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_unmap(buffer: *mut GstBuffer, info: *mut GstMapInfo);
}
unsafe extern "C" {
    pub fn gst_buffer_extract_dup(
        buffer: *mut GstBuffer,
        offset: gsize,
        size: gsize,
        dest: *mut gpointer,
        dest_size: *mut gsize,
    );
}
unsafe extern "C" {
    pub fn gst_buffer_get_flags(buffer: *mut GstBuffer) -> GstBufferFlags;
}
unsafe extern "C" {
    pub fn gst_buffer_has_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_set_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_unset_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_copy_deep(buf: *const GstBuffer) -> *mut GstBuffer;
}
pub const GstBufferCopyFlags_GST_BUFFER_COPY_NONE: GstBufferCopyFlags = 0;
pub const GstBufferCopyFlags_GST_BUFFER_COPY_FLAGS: GstBufferCopyFlags = 1;
pub const GstBufferCopyFlags_GST_BUFFER_COPY_TIMESTAMPS: GstBufferCopyFlags = 2;
pub const GstBufferCopyFlags_GST_BUFFER_COPY_META: GstBufferCopyFlags = 4;
pub const GstBufferCopyFlags_GST_BUFFER_COPY_MEMORY: GstBufferCopyFlags = 8;
pub const GstBufferCopyFlags_GST_BUFFER_COPY_MERGE: GstBufferCopyFlags = 16;
#[doc = " GST_BUFFER_COPY_DEEP:\n\n flag indicating that memory should always be copied instead of reffed\n\n Since: 1.2"]
pub const GstBufferCopyFlags_GST_BUFFER_COPY_DEEP: GstBufferCopyFlags = 32;
#[doc = " GstBufferCopyFlags:\n @GST_BUFFER_COPY_NONE: copy nothing\n @GST_BUFFER_COPY_FLAGS: flag indicating that buffer flags should be copied\n @GST_BUFFER_COPY_TIMESTAMPS: flag indicating that buffer pts, dts,\n   duration, offset and offset_end should be copied\n @GST_BUFFER_COPY_MEMORY: flag indicating that buffer memory should be reffed\n   and appended to already existing memory. Unless the memory is marked as\n   NO_SHARE, no actual copy of the memory is made but it is simply reffed.\n   Add @GST_BUFFER_COPY_DEEP to force a real copy.\n @GST_BUFFER_COPY_MERGE: flag indicating that buffer memory should be\n   merged\n @GST_BUFFER_COPY_META: flag indicating that buffer meta should be\n   copied\n\n A set of flags that can be provided to the gst_buffer_copy_into()\n function to specify which items should be copied."]
pub type GstBufferCopyFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_buffer_copy_into(
        dest: *mut GstBuffer,
        src: *mut GstBuffer,
        flags: GstBufferCopyFlags,
        offset: gsize,
        size: gsize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_copy_region(
        parent: *mut GstBuffer,
        flags: GstBufferCopyFlags,
        offset: gsize,
        size: gsize,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_append_region(
        buf1: *mut GstBuffer,
        buf2: *mut GstBuffer,
        offset: gssize,
        size: gssize,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_append(buf1: *mut GstBuffer, buf2: *mut GstBuffer) -> *mut GstBuffer;
}
#[doc = " GstBufferForeachMetaFunc:\n @buffer: a #GstBuffer\n @meta: (out) (nullable): a pointer to a #GstMeta\n @user_data: user data passed to gst_buffer_foreach_meta()\n\n A function that will be called from gst_buffer_foreach_meta(). The @meta\n field will point to a the reference of the meta.\n\n @buffer should not be modified from this callback.\n\n When this function returns %TRUE, the next meta will be\n returned. When %FALSE is returned, gst_buffer_foreach_meta() will return.\n\n When @meta is set to %NULL, the item will be removed from the buffer.\n\n Returns: %FALSE when gst_buffer_foreach_meta() should stop"]
pub type GstBufferForeachMetaFunc = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut GstBuffer,
        meta: *mut *mut GstMeta,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_buffer_get_meta(buffer: *mut GstBuffer, api: GType) -> *mut GstMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_get_n_meta(buffer: *mut GstBuffer, api_type: GType) -> guint;
}
unsafe extern "C" {
    pub fn gst_buffer_add_meta(
        buffer: *mut GstBuffer,
        info: *const GstMetaInfo,
        params: gpointer,
    ) -> *mut GstMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_remove_meta(buffer: *mut GstBuffer, meta: *mut GstMeta) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_iterate_meta(buffer: *mut GstBuffer, state: *mut gpointer) -> *mut GstMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_iterate_meta_filtered(
        buffer: *mut GstBuffer,
        state: *mut gpointer,
        meta_api_type: GType,
    ) -> *mut GstMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_foreach_meta(
        buffer: *mut GstBuffer,
        func: GstBufferForeachMetaFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_add_custom_meta(
        buffer: *mut GstBuffer,
        name: *const gchar,
    ) -> *mut GstCustomMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_get_custom_meta(
        buffer: *mut GstBuffer,
        name: *const gchar,
    ) -> *mut GstCustomMeta;
}
#[doc = " GstParentBufferMeta:\n @parent: the parent #GstMeta structure\n @buffer: the #GstBuffer on which a reference is being held.\n\n The #GstParentBufferMeta is a #GstMeta which can be attached to a #GstBuffer\n to hold a reference to another buffer that is only released when the child\n #GstBuffer is released.\n\n Typically, #GstParentBufferMeta is used when the child buffer is directly\n using the #GstMemory of the parent buffer, and wants to prevent the parent\n buffer from being returned to a buffer pool until the #GstMemory is available\n for re-use.\n\n Since: 1.6"]
pub type GstParentBufferMeta = _GstParentBufferMeta;
#[doc = " GstParentBufferMeta:\n @parent: the parent #GstMeta structure\n @buffer: the #GstBuffer on which a reference is being held.\n\n The #GstParentBufferMeta is a #GstMeta which can be attached to a #GstBuffer\n to hold a reference to another buffer that is only released when the child\n #GstBuffer is released.\n\n Typically, #GstParentBufferMeta is used when the child buffer is directly\n using the #GstMemory of the parent buffer, and wants to prevent the parent\n buffer from being returned to a buffer pool until the #GstMemory is available\n for re-use.\n\n Since: 1.6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstParentBufferMeta {
    pub parent: GstMeta,
    pub buffer: *mut GstBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstParentBufferMeta"][::std::mem::size_of::<_GstParentBufferMeta>() - 24usize];
    ["Alignment of _GstParentBufferMeta"][::std::mem::align_of::<_GstParentBufferMeta>() - 8usize];
    ["Offset of field: _GstParentBufferMeta::parent"]
        [::std::mem::offset_of!(_GstParentBufferMeta, parent) - 0usize];
    ["Offset of field: _GstParentBufferMeta::buffer"]
        [::std::mem::offset_of!(_GstParentBufferMeta, buffer) - 16usize];
};
unsafe extern "C" {
    pub fn gst_parent_buffer_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_parent_buffer_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_parent_buffer_meta(
        buffer: *mut GstBuffer,
        ref_: *mut GstBuffer,
    ) -> *mut GstParentBufferMeta;
}
#[doc = " GstReferenceTimestampMeta:\n @parent: the parent #GstMeta structure\n @reference: identifier for the timestamp reference.\n @timestamp: timestamp\n @duration: duration, or %GST_CLOCK_TIME_NONE\n\n #GstReferenceTimestampMeta can be used to attach alternative timestamps and\n possibly durations to a #GstBuffer. These are generally not according to\n the pipeline clock and could be e.g. the NTP timestamp when the media was\n captured.\n\n The reference is stored as a #GstCaps in @reference. Examples of valid\n references would be `timestamp/x-drivername-stream` for timestamps that are locally\n generated by some driver named `drivername` when generating the stream,\n e.g. based on a frame counter, or `timestamp/x-ntp, host=pool.ntp.org,\n port=123` for timestamps based on a specific NTP server.\n\n Since: 1.14"]
pub type GstReferenceTimestampMeta = _GstReferenceTimestampMeta;
#[doc = " GstReferenceTimestampMeta:\n @parent: the parent #GstMeta structure\n @reference: identifier for the timestamp reference.\n @timestamp: timestamp\n @duration: duration, or %GST_CLOCK_TIME_NONE\n\n #GstReferenceTimestampMeta can be used to attach alternative timestamps and\n possibly durations to a #GstBuffer. These are generally not according to\n the pipeline clock and could be e.g. the NTP timestamp when the media was\n captured.\n\n The reference is stored as a #GstCaps in @reference. Examples of valid\n references would be `timestamp/x-drivername-stream` for timestamps that are locally\n generated by some driver named `drivername` when generating the stream,\n e.g. based on a frame counter, or `timestamp/x-ntp, host=pool.ntp.org,\n port=123` for timestamps based on a specific NTP server.\n\n Since: 1.14"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstReferenceTimestampMeta {
    pub parent: GstMeta,
    pub reference: *mut GstCaps,
    pub timestamp: GstClockTime,
    pub duration: GstClockTime,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstReferenceTimestampMeta"]
        [::std::mem::size_of::<_GstReferenceTimestampMeta>() - 40usize];
    ["Alignment of _GstReferenceTimestampMeta"]
        [::std::mem::align_of::<_GstReferenceTimestampMeta>() - 8usize];
    ["Offset of field: _GstReferenceTimestampMeta::parent"]
        [::std::mem::offset_of!(_GstReferenceTimestampMeta, parent) - 0usize];
    ["Offset of field: _GstReferenceTimestampMeta::reference"]
        [::std::mem::offset_of!(_GstReferenceTimestampMeta, reference) - 16usize];
    ["Offset of field: _GstReferenceTimestampMeta::timestamp"]
        [::std::mem::offset_of!(_GstReferenceTimestampMeta, timestamp) - 24usize];
    ["Offset of field: _GstReferenceTimestampMeta::duration"]
        [::std::mem::offset_of!(_GstReferenceTimestampMeta, duration) - 32usize];
};
unsafe extern "C" {
    pub fn gst_reference_timestamp_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_reference_timestamp_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        reference: *mut GstCaps,
        timestamp: GstClockTime,
        duration: GstClockTime,
    ) -> *mut GstReferenceTimestampMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_get_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        reference: *mut GstCaps,
    ) -> *mut GstReferenceTimestampMeta;
}
pub type GstBuffer_autoptr = *mut GstBuffer;
pub type GstBuffer_listautoptr = *mut GList;
pub type GstBuffer_slistautoptr = *mut GSList;
pub type GstBuffer_queueautoptr = *mut GQueue;
pub type GstBufferPool_autoptr = *mut GstBufferPool;
pub type GstBufferPool_listautoptr = *mut GList;
pub type GstBufferPool_slistautoptr = *mut GSList;
pub type GstBufferPool_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_buffer_list_type: GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferList {
    _unused: [u8; 0],
}
pub type GstBufferList = _GstBufferList;
#[doc = " GstBufferListFunc:\n @buffer: (out) (nullable): pointer to the buffer\n @idx: the index of @buffer\n @user_data: user data passed to gst_buffer_list_foreach()\n\n A function that will be called from gst_buffer_list_foreach(). The @buffer\n field will point to a the reference of the buffer at @idx.\n\n When this function returns %TRUE, the next buffer will be\n returned. When %FALSE is returned, gst_buffer_list_foreach() will return.\n\n When @buffer is set to %NULL, the item will be removed from the bufferlist.\n When @buffer has been made writable, the new buffer reference can be assigned\n to @buffer. This function is responsible for unreffing the old buffer when\n removing or modifying.\n\n Returns: %FALSE when gst_buffer_list_foreach() should stop"]
pub type GstBufferListFunc = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut *mut GstBuffer, idx: guint, user_data: gpointer) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_buffer_list_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_list_new() -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_buffer_list_new_sized(size: guint) -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_buffer_list_length(list: *mut GstBufferList) -> guint;
}
unsafe extern "C" {
    pub fn gst_buffer_list_get(list: *mut GstBufferList, idx: guint) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_list_get_writable(list: *mut GstBufferList, idx: guint) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_buffer_list_insert(list: *mut GstBufferList, idx: gint, buffer: *mut GstBuffer);
}
unsafe extern "C" {
    pub fn gst_buffer_list_remove(list: *mut GstBufferList, idx: guint, length: guint);
}
unsafe extern "C" {
    pub fn gst_buffer_list_foreach(
        list: *mut GstBufferList,
        func: GstBufferListFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_list_copy_deep(list: *const GstBufferList) -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_buffer_list_calculate_size(list: *mut GstBufferList) -> gsize;
}
pub type GstBufferList_autoptr = *mut GstBufferList;
pub type GstBufferList_listautoptr = *mut GList;
pub type GstBufferList_slistautoptr = *mut GSList;
pub type GstBufferList_queueautoptr = *mut GQueue;
#[doc = " GstPadTemplate:\n\n The padtemplate object."]
pub type GstPadTemplate = _GstPadTemplate;
pub type GstPadTemplateClass = _GstPadTemplateClass;
#[doc = " GstStaticPadTemplate:\n @name_template: the name of the template\n @direction: the direction of the template\n @presence: the presence of the template\n @static_caps: the caps of the template.\n\n Structure describing the #GstStaticPadTemplate."]
pub type GstStaticPadTemplate = _GstStaticPadTemplate;
#[doc = " GstEvent:\n @mini_object: the parent structure\n @type: the #GstEventType of the event\n @timestamp: the timestamp of the event\n @seqnum: the sequence number of the event\n\n A #GstEvent."]
pub type GstEvent = _GstEvent;
pub const GstEventTypeFlags_GST_EVENT_TYPE_UPSTREAM: GstEventTypeFlags = 1;
pub const GstEventTypeFlags_GST_EVENT_TYPE_DOWNSTREAM: GstEventTypeFlags = 2;
pub const GstEventTypeFlags_GST_EVENT_TYPE_SERIALIZED: GstEventTypeFlags = 4;
pub const GstEventTypeFlags_GST_EVENT_TYPE_STICKY: GstEventTypeFlags = 8;
pub const GstEventTypeFlags_GST_EVENT_TYPE_STICKY_MULTI: GstEventTypeFlags = 16;
#[doc = " GstEventTypeFlags:\n @GST_EVENT_TYPE_UPSTREAM:     Set if the event can travel upstream.\n @GST_EVENT_TYPE_DOWNSTREAM:   Set if the event can travel downstream.\n @GST_EVENT_TYPE_SERIALIZED:   Set if the event should be serialized with data\n                               flow.\n @GST_EVENT_TYPE_STICKY:       Set if the event is sticky on the pads.\n @GST_EVENT_TYPE_STICKY_MULTI: Multiple sticky events can be on a pad, each\n                               identified by the event name.\n\n #GstEventTypeFlags indicate the aspects of the different #GstEventType\n values. You can get the type flags of a #GstEventType with the\n gst_event_type_get_flags() function."]
pub type GstEventTypeFlags = ::std::os::raw::c_uint;
pub const GstEventType_GST_EVENT_UNKNOWN: GstEventType = 0;
pub const GstEventType_GST_EVENT_FLUSH_START: GstEventType = 2563;
pub const GstEventType_GST_EVENT_FLUSH_STOP: GstEventType = 5127;
pub const GstEventType_GST_EVENT_STREAM_START: GstEventType = 10254;
pub const GstEventType_GST_EVENT_CAPS: GstEventType = 12814;
pub const GstEventType_GST_EVENT_SEGMENT: GstEventType = 17934;
pub const GstEventType_GST_EVENT_STREAM_COLLECTION: GstEventType = 19230;
pub const GstEventType_GST_EVENT_TAG: GstEventType = 20510;
pub const GstEventType_GST_EVENT_BUFFERSIZE: GstEventType = 23054;
pub const GstEventType_GST_EVENT_SINK_MESSAGE: GstEventType = 25630;
pub const GstEventType_GST_EVENT_STREAM_GROUP_DONE: GstEventType = 26894;
pub const GstEventType_GST_EVENT_EOS: GstEventType = 28174;
pub const GstEventType_GST_EVENT_TOC: GstEventType = 30750;
pub const GstEventType_GST_EVENT_PROTECTION: GstEventType = 33310;
pub const GstEventType_GST_EVENT_SEGMENT_DONE: GstEventType = 38406;
pub const GstEventType_GST_EVENT_GAP: GstEventType = 40966;
pub const GstEventType_GST_EVENT_INSTANT_RATE_CHANGE: GstEventType = 46090;
pub const GstEventType_GST_EVENT_QOS: GstEventType = 48641;
pub const GstEventType_GST_EVENT_SEEK: GstEventType = 51201;
pub const GstEventType_GST_EVENT_NAVIGATION: GstEventType = 53761;
pub const GstEventType_GST_EVENT_LATENCY: GstEventType = 56321;
pub const GstEventType_GST_EVENT_STEP: GstEventType = 58881;
pub const GstEventType_GST_EVENT_RECONFIGURE: GstEventType = 61441;
pub const GstEventType_GST_EVENT_TOC_SELECT: GstEventType = 64001;
pub const GstEventType_GST_EVENT_SELECT_STREAMS: GstEventType = 66561;
pub const GstEventType_GST_EVENT_INSTANT_RATE_SYNC_TIME: GstEventType = 66817;
pub const GstEventType_GST_EVENT_CUSTOM_UPSTREAM: GstEventType = 69121;
pub const GstEventType_GST_EVENT_CUSTOM_DOWNSTREAM: GstEventType = 71686;
pub const GstEventType_GST_EVENT_CUSTOM_DOWNSTREAM_OOB: GstEventType = 74242;
pub const GstEventType_GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: GstEventType = 76830;
pub const GstEventType_GST_EVENT_CUSTOM_BOTH: GstEventType = 79367;
pub const GstEventType_GST_EVENT_CUSTOM_BOTH_OOB: GstEventType = 81923;
#[doc = " GstEventType:\n @GST_EVENT_UNKNOWN: unknown event.\n @GST_EVENT_FLUSH_START: Start a flush operation. This event clears all data\n                 from the pipeline and unblock all streaming threads.\n @GST_EVENT_FLUSH_STOP: Stop a flush operation. This event resets the\n                 running-time of the pipeline.\n @GST_EVENT_SELECT_STREAMS: A request to select one or more streams (Since: 1.10)\n @GST_EVENT_STREAM_START: Event to mark the start of a new stream. Sent before any\n                 other serialized event and only sent at the start of a new stream,\n                 not after flushing seeks.\n @GST_EVENT_CAPS: #GstCaps event. Notify the pad of a new media type.\n @GST_EVENT_SEGMENT: A new media segment follows in the dataflow. The\n                 segment events contains information for clipping buffers and\n                 converting buffer timestamps to running-time and\n                 stream-time.\n @GST_EVENT_STREAM_COLLECTION: A new #GstStreamCollection is available (Since: 1.10)\n @GST_EVENT_TAG: A new set of metadata tags has been found in the stream.\n @GST_EVENT_BUFFERSIZE: Notification of buffering requirements. Currently not\n                 used yet.\n @GST_EVENT_SINK_MESSAGE: An event that sinks turn into a message. Used to\n                          send messages that should be emitted in sync with\n                          rendering.\n @GST_EVENT_STREAM_GROUP_DONE: Indicates that there is no more data for\n                 the stream group ID in the message. Sent before EOS\n                 in some instances and should be handled mostly the same. (Since: 1.10)\n @GST_EVENT_EOS: End-Of-Stream. No more data is to be expected to follow\n                 without either a STREAM_START event, or a FLUSH_STOP and a SEGMENT\n                 event.\n @GST_EVENT_SEGMENT_DONE: Marks the end of a segment playback.\n @GST_EVENT_GAP: Marks a gap in the datastream.\n @GST_EVENT_TOC: An event which indicates that a new table of contents (TOC)\n                 was found or updated.\n @GST_EVENT_PROTECTION: An event which indicates that new or updated\n                 encryption information has been found in the stream.\n @GST_EVENT_QOS: A quality message. Used to indicate to upstream elements\n                 that the downstream elements should adjust their processing\n                 rate.\n @GST_EVENT_SEEK: A request for a new playback position and rate.\n @GST_EVENT_NAVIGATION: Navigation events are usually used for communicating\n                        user requests, such as mouse or keyboard movements,\n                        to upstream elements.\n @GST_EVENT_LATENCY: Notification of new latency adjustment. Sinks will use\n                     the latency information to adjust their synchronisation.\n @GST_EVENT_STEP: A request for stepping through the media. Sinks will usually\n                  execute the step operation.\n @GST_EVENT_RECONFIGURE: A request for upstream renegotiating caps and reconfiguring.\n @GST_EVENT_TOC_SELECT: A request for a new playback position based on TOC\n                        entry's UID.\n @GST_EVENT_INSTANT_RATE_CHANGE: Notify downstream that a playback rate override\n                                 should be applied as soon as possible. (Since: 1.18)\n @GST_EVENT_INSTANT_RATE_SYNC_TIME: Sent by the pipeline to notify elements that handle the\n                                    instant-rate-change event about the running-time when\n                                    the rate multiplier should be applied (or was applied). (Since: 1.18)\n @GST_EVENT_CUSTOM_UPSTREAM: Upstream custom event\n @GST_EVENT_CUSTOM_DOWNSTREAM: Downstream custom event that travels in the\n                        data flow.\n @GST_EVENT_CUSTOM_DOWNSTREAM_OOB: Custom out-of-band downstream event.\n @GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: Custom sticky downstream event.\n @GST_EVENT_CUSTOM_BOTH: Custom upstream or downstream event.\n                         In-band when travelling downstream.\n @GST_EVENT_CUSTOM_BOTH_OOB: Custom upstream or downstream out-of-band event.\n\n #GstEventType lists the standard event types that can be sent in a pipeline.\n\n The custom event types can be used for private messages between elements\n that can't be expressed using normal\n GStreamer buffer passing semantics. Custom events carry an arbitrary\n #GstStructure.\n Specific custom events are distinguished by the name of the structure."]
pub type GstEventType = ::std::os::raw::c_uint;
pub const GstStreamFlags_GST_STREAM_FLAG_NONE: GstStreamFlags = 0;
pub const GstStreamFlags_GST_STREAM_FLAG_SPARSE: GstStreamFlags = 1;
pub const GstStreamFlags_GST_STREAM_FLAG_SELECT: GstStreamFlags = 2;
pub const GstStreamFlags_GST_STREAM_FLAG_UNSELECT: GstStreamFlags = 4;
#[doc = " GstStreamFlags:\n @GST_STREAM_FLAG_NONE: This stream has no special attributes\n @GST_STREAM_FLAG_SPARSE: This stream is a sparse stream (e.g. a subtitle\n    stream), data may flow only in irregular intervals with large gaps in\n    between.\n @GST_STREAM_FLAG_SELECT: This stream should be selected by default. This\n    flag may be used by demuxers to signal that a stream should be selected\n    by default in a playback scenario.\n @GST_STREAM_FLAG_UNSELECT: This stream should not be selected by default.\n    This flag may be used by demuxers to signal that a stream should not\n    be selected by default in a playback scenario, but only if explicitly\n    selected by the user (e.g. an audio track for the hard of hearing or\n    a director's commentary track).\n\n Since: 1.2"]
pub type GstStreamFlags = ::std::os::raw::c_uint;
pub const GstIteratorResult_GST_ITERATOR_DONE: GstIteratorResult = 0;
pub const GstIteratorResult_GST_ITERATOR_OK: GstIteratorResult = 1;
pub const GstIteratorResult_GST_ITERATOR_RESYNC: GstIteratorResult = 2;
pub const GstIteratorResult_GST_ITERATOR_ERROR: GstIteratorResult = 3;
#[doc = " GstIteratorResult:\n @GST_ITERATOR_DONE:   No more items in the iterator\n @GST_ITERATOR_OK:     An item was retrieved\n @GST_ITERATOR_RESYNC: Datastructure changed while iterating\n @GST_ITERATOR_ERROR:  An error happened\n\n The result of gst_iterator_next()."]
pub type GstIteratorResult = ::std::os::raw::c_uint;
#[doc = " GstIterator:\n @copy: The function to copy the iterator\n @next: The function to get the next item in the iterator\n @item: The function to be called for each item retrieved\n @resync: The function to call when a resync is needed.\n @free: The function to call when the iterator is freed\n @pushed: The iterator that is currently pushed with gst_iterator_push()\n @type: The type of the object that this iterator will return\n @lock: The lock protecting the data structure and the cookie.\n @cookie: The cookie; the value of the master_cookie when this iterator was\n          created.\n @master_cookie: A pointer to the master cookie.\n @size: the size of the iterator\n\n #GstIterator base structure. The values of this structure are\n protected for subclasses, use the methods to use the #GstIterator."]
pub type GstIterator = _GstIterator;
pub const GstIteratorItem_GST_ITERATOR_ITEM_SKIP: GstIteratorItem = 0;
pub const GstIteratorItem_GST_ITERATOR_ITEM_PASS: GstIteratorItem = 1;
pub const GstIteratorItem_GST_ITERATOR_ITEM_END: GstIteratorItem = 2;
#[doc = " GstIteratorItem:\n @GST_ITERATOR_ITEM_SKIP:  Skip this item\n @GST_ITERATOR_ITEM_PASS:  Return item\n @GST_ITERATOR_ITEM_END:   Stop after this item.\n\n The result of a #GstIteratorItemFunction."]
pub type GstIteratorItem = ::std::os::raw::c_uint;
#[doc = " GstIteratorCopyFunction:\n @it: The original iterator\n @copy: The copied iterator\n\n This function will be called when creating a copy of @it and should\n create a copy of all custom iterator fields or increase their\n reference counts."]
pub type GstIteratorCopyFunction =
    ::std::option::Option<unsafe extern "C" fn(it: *const GstIterator, copy: *mut GstIterator)>;
#[doc = " GstIteratorItemFunction:\n @it: the iterator\n @item: the item being retrieved.\n\n The function that will be called after the next item of the iterator\n has been retrieved. This function can be used to skip items or stop\n the iterator.\n\n The function will be called with the iterator lock held.\n\n Returns: the result of the operation."]
pub type GstIteratorItemFunction = ::std::option::Option<
    unsafe extern "C" fn(it: *mut GstIterator, item: *const GValue) -> GstIteratorItem,
>;
#[doc = " GstIteratorNextFunction:\n @it: the iterator\n @result: a pointer to hold the next item\n\n The function that will be called when the next element of the iterator\n should be retrieved.\n\n Implementors of a #GstIterator should implement this\n function and pass it to the constructor of the custom iterator.\n The function will be called with the iterator lock held.\n\n Returns: the result of the operation."]
pub type GstIteratorNextFunction = ::std::option::Option<
    unsafe extern "C" fn(it: *mut GstIterator, result: *mut GValue) -> GstIteratorResult,
>;
#[doc = " GstIteratorResyncFunction:\n @it: the iterator\n\n This function will be called whenever a concurrent update happened\n to the iterated datastructure. The implementor of the iterator should\n restart the iterator from the beginning and clean up any state it might\n have.\n\n Implementors of a #GstIterator should implement this\n function and pass it to the constructor of the custom iterator.\n The function will be called with the iterator lock held."]
pub type GstIteratorResyncFunction =
    ::std::option::Option<unsafe extern "C" fn(it: *mut GstIterator)>;
#[doc = " GstIteratorFreeFunction:\n @it: the iterator\n\n This function will be called when the iterator is freed.\n\n Implementors of a #GstIterator should implement this\n function and pass it to the constructor of the custom iterator.\n The function will be called with the iterator lock held."]
pub type GstIteratorFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(it: *mut GstIterator)>;
#[doc = " GstIteratorForeachFunction:\n @item: The item\n @user_data: User data\n\n A function that is called by gst_iterator_foreach() for every element."]
pub type GstIteratorForeachFunction =
    ::std::option::Option<unsafe extern "C" fn(item: *const GValue, user_data: gpointer)>;
#[doc = " GstIteratorFoldFunction:\n @item: the item to fold\n @ret: a #GValue collecting the result\n @user_data: data passed to gst_iterator_fold()\n\n A function to be passed to gst_iterator_fold().\n\n Returns: %TRUE if the fold should continue, %FALSE if it should stop."]
pub type GstIteratorFoldFunction = ::std::option::Option<
    unsafe extern "C" fn(item: *const GValue, ret: *mut GValue, user_data: gpointer) -> gboolean,
>;
#[doc = " GstIterator:\n @copy: The function to copy the iterator\n @next: The function to get the next item in the iterator\n @item: The function to be called for each item retrieved\n @resync: The function to call when a resync is needed.\n @free: The function to call when the iterator is freed\n @pushed: The iterator that is currently pushed with gst_iterator_push()\n @type: The type of the object that this iterator will return\n @lock: The lock protecting the data structure and the cookie.\n @cookie: The cookie; the value of the master_cookie when this iterator was\n          created.\n @master_cookie: A pointer to the master cookie.\n @size: the size of the iterator\n\n #GstIterator base structure. The values of this structure are\n protected for subclasses, use the methods to use the #GstIterator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstIterator {
    pub copy: GstIteratorCopyFunction,
    pub next: GstIteratorNextFunction,
    pub item: GstIteratorItemFunction,
    pub resync: GstIteratorResyncFunction,
    pub free: GstIteratorFreeFunction,
    pub pushed: *mut GstIterator,
    pub type_: GType,
    pub lock: *mut GMutex,
    pub cookie: guint32,
    pub master_cookie: *mut guint32,
    pub size: guint,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstIterator"][::std::mem::size_of::<_GstIterator>() - 120usize];
    ["Alignment of _GstIterator"][::std::mem::align_of::<_GstIterator>() - 8usize];
    ["Offset of field: _GstIterator::copy"][::std::mem::offset_of!(_GstIterator, copy) - 0usize];
    ["Offset of field: _GstIterator::next"][::std::mem::offset_of!(_GstIterator, next) - 8usize];
    ["Offset of field: _GstIterator::item"][::std::mem::offset_of!(_GstIterator, item) - 16usize];
    ["Offset of field: _GstIterator::resync"]
        [::std::mem::offset_of!(_GstIterator, resync) - 24usize];
    ["Offset of field: _GstIterator::free"][::std::mem::offset_of!(_GstIterator, free) - 32usize];
    ["Offset of field: _GstIterator::pushed"]
        [::std::mem::offset_of!(_GstIterator, pushed) - 40usize];
    ["Offset of field: _GstIterator::type_"][::std::mem::offset_of!(_GstIterator, type_) - 48usize];
    ["Offset of field: _GstIterator::lock"][::std::mem::offset_of!(_GstIterator, lock) - 56usize];
    ["Offset of field: _GstIterator::cookie"]
        [::std::mem::offset_of!(_GstIterator, cookie) - 64usize];
    ["Offset of field: _GstIterator::master_cookie"]
        [::std::mem::offset_of!(_GstIterator, master_cookie) - 72usize];
    ["Offset of field: _GstIterator::size"][::std::mem::offset_of!(_GstIterator, size) - 80usize];
    ["Offset of field: _GstIterator::_gst_reserved"]
        [::std::mem::offset_of!(_GstIterator, _gst_reserved) - 88usize];
};
unsafe extern "C" {
    pub fn gst_iterator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_iterator_new(
        size: guint,
        type_: GType,
        lock: *mut GMutex,
        master_cookie: *mut guint32,
        copy: GstIteratorCopyFunction,
        next: GstIteratorNextFunction,
        item: GstIteratorItemFunction,
        resync: GstIteratorResyncFunction,
        free: GstIteratorFreeFunction,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_iterator_new_list(
        type_: GType,
        lock: *mut GMutex,
        master_cookie: *mut guint32,
        list: *mut *mut GList,
        owner: *mut GObject,
        item: GstIteratorItemFunction,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_iterator_new_single(type_: GType, object: *const GValue) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_iterator_copy(it: *const GstIterator) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_iterator_next(it: *mut GstIterator, elem: *mut GValue) -> GstIteratorResult;
}
unsafe extern "C" {
    pub fn gst_iterator_resync(it: *mut GstIterator);
}
unsafe extern "C" {
    pub fn gst_iterator_free(it: *mut GstIterator);
}
unsafe extern "C" {
    pub fn gst_iterator_push(it: *mut GstIterator, other: *mut GstIterator);
}
unsafe extern "C" {
    pub fn gst_iterator_filter(
        it: *mut GstIterator,
        func: GCompareFunc,
        user_data: *const GValue,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_iterator_fold(
        it: *mut GstIterator,
        func: GstIteratorFoldFunction,
        ret: *mut GValue,
        user_data: gpointer,
    ) -> GstIteratorResult;
}
unsafe extern "C" {
    pub fn gst_iterator_foreach(
        it: *mut GstIterator,
        func: GstIteratorForeachFunction,
        user_data: gpointer,
    ) -> GstIteratorResult;
}
unsafe extern "C" {
    pub fn gst_iterator_find_custom(
        it: *mut GstIterator,
        func: GCompareFunc,
        elem: *mut GValue,
        user_data: gpointer,
    ) -> gboolean;
}
pub type GstIterator_autoptr = *mut GstIterator;
pub type GstIterator_listautoptr = *mut GList;
pub type GstIterator_slistautoptr = *mut GSList;
pub type GstIterator_queueautoptr = *mut GQueue;
pub const GstFormat_GST_FORMAT_UNDEFINED: GstFormat = 0;
pub const GstFormat_GST_FORMAT_DEFAULT: GstFormat = 1;
pub const GstFormat_GST_FORMAT_BYTES: GstFormat = 2;
pub const GstFormat_GST_FORMAT_TIME: GstFormat = 3;
pub const GstFormat_GST_FORMAT_BUFFERS: GstFormat = 4;
pub const GstFormat_GST_FORMAT_PERCENT: GstFormat = 5;
#[doc = " GstFormat:\n @GST_FORMAT_UNDEFINED: undefined format\n @GST_FORMAT_DEFAULT: the default format of the pad/element. This can be\n    samples for raw audio, frames/fields for raw video (some, but not all,\n    elements support this; use @GST_FORMAT_TIME if you don't have a good\n    reason to query for samples/frames)\n @GST_FORMAT_BYTES: bytes\n @GST_FORMAT_TIME: time in nanoseconds\n @GST_FORMAT_BUFFERS: buffers (few, if any, elements implement this as of\n     May 2009)\n @GST_FORMAT_PERCENT: percentage of stream (few, if any, elements implement\n     this as of May 2009)\n\n Standard predefined formats"]
pub type GstFormat = ::std::os::raw::c_uint;
#[doc = " GstFormatDefinition:\n @value: The unique id of this format\n @nick: A short nick of the format\n @description: A longer description of the format\n @quark: A quark for the nick\n\n A format definition"]
pub type GstFormatDefinition = _GstFormatDefinition;
#[doc = " GstFormatDefinition:\n @value: The unique id of this format\n @nick: A short nick of the format\n @description: A longer description of the format\n @quark: A quark for the nick\n\n A format definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstFormatDefinition {
    pub value: GstFormat,
    pub nick: *const gchar,
    pub description: *const gchar,
    pub quark: GQuark,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstFormatDefinition"][::std::mem::size_of::<_GstFormatDefinition>() - 32usize];
    ["Alignment of _GstFormatDefinition"][::std::mem::align_of::<_GstFormatDefinition>() - 8usize];
    ["Offset of field: _GstFormatDefinition::value"]
        [::std::mem::offset_of!(_GstFormatDefinition, value) - 0usize];
    ["Offset of field: _GstFormatDefinition::nick"]
        [::std::mem::offset_of!(_GstFormatDefinition, nick) - 8usize];
    ["Offset of field: _GstFormatDefinition::description"]
        [::std::mem::offset_of!(_GstFormatDefinition, description) - 16usize];
    ["Offset of field: _GstFormatDefinition::quark"]
        [::std::mem::offset_of!(_GstFormatDefinition, quark) - 24usize];
};
unsafe extern "C" {
    pub fn gst_format_get_name(format: GstFormat) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_format_to_quark(format: GstFormat) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_format_register(nick: *const gchar, description: *const gchar) -> GstFormat;
}
unsafe extern "C" {
    pub fn gst_format_get_by_nick(nick: *const gchar) -> GstFormat;
}
unsafe extern "C" {
    pub fn gst_formats_contains(formats: *const GstFormat, format: GstFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_format_get_details(format: GstFormat) -> *const GstFormatDefinition;
}
unsafe extern "C" {
    pub fn gst_format_iterate_definitions() -> *mut GstIterator;
}
#[doc = " GstSegment:\n @flags:        flags for this segment\n @rate:         the playback rate of the segment is set in response to a seek\n                event and, without any seek, the value should be `1.0`. This\n                value is used by elements that synchronize buffer [running\n                times](additional/design/synchronisation.md#running-time) on\n                the clock (usually the sink elements), leading to consuming\n                buffers faster (for a value `> 1.0`) or slower (for `0.0 <\n                value < 1.0`) than normal playback speed. The rate also\n                defines the playback direction, meaning that when the value is\n                lower than `0.0`, the playback happens in reverse, and the\n                [stream-time](additional/design/synchronisation.md#stream-time)\n                is going backward. The `rate` value should never be `0.0`.\n @applied_rate: The applied rate is the rate that has been applied to the stream.\n                The effective/resulting playback rate of a stream is\n                `rate * applied_rate`.\n                The applied rate can be set by source elements when a server is\n                sending the stream with an already modified playback speed\n                rate. Filter elements that modify the stream in a way that\n                modifies the playback speed should also modify the applied\n                rate. For example the #videorate element when its\n                #videorate:rate property is set will set the applied rate of\n                the segment it pushed downstream. Also #scaletempo applies the\n                input segment rate to the stream and outputs a segment with\n                rate=1.0 and applied_rate=<inputsegment.rate>.\n @format:       the unit used for all of the segment's values.\n @base:         the running time (plus elapsed time, see offset) of the\n                segment [start](GstSegment.start) ([stop](GstSegment.stop) if\n                rate < 0.0).\n @offset:       the offset expresses the elapsed time (in buffer timestamps)\n                before a seek with its start (stop if rate < 0.0) seek type\n                set to #GST_SEEK_TYPE_NONE, the value is set to the position\n                of the segment at the time of the seek.\n @start:        the start time of the segment (in buffer timestamps)\n                [(PTS)](GstBuffer.pts), that is the timestamp of the first\n                buffer to output inside the segment (last one during\n                reverse playback). For example decoders will\n                [clip](gst_segment_clip) out the buffers before the start\n                time.\n @stop:         the stop time of the segment (in buffer timestamps)\n                [(PTS)](GstBuffer.pts), that is the timestamp of the last\n                buffer to output inside the segment (first one during\n                reverse playback). For example decoders will\n                [clip](gst_segment_clip) out buffers after the stop time.\n @time:         the stream time of the segment [start](GstSegment.start)\n                ([stop](GstSegment.stop) if rate < 0.0).\n @position:     the buffer timestamp position in the segment is supposed to be\n                updated by elements such as sources, demuxers or parsers to\n                track progress by setting it to the last pushed buffer' end time\n                ([timestamp](GstBuffer.pts) + #GstBuffer.duration) for that\n                specific segment. The position is used when reconfiguring the\n                segment with #gst_segment_do_seek when the seek is only\n                updating the segment (see [offset](GstSegment.offset)).\n @duration:     the duration of the segment is the maximum absolute difference\n                between #GstSegment.start and #GstSegment.stop if stop is not\n                set, otherwise it should be the difference between those\n                two values. This should be set by elements that know the\n                overall stream duration (like demuxers) and will be used when\n                seeking with #GST_SEEK_TYPE_END.\n\n The structure that holds the configured region of interest in a media file."]
pub type GstSegment = _GstSegment;
pub const GstSeekType_GST_SEEK_TYPE_NONE: GstSeekType = 0;
pub const GstSeekType_GST_SEEK_TYPE_SET: GstSeekType = 1;
pub const GstSeekType_GST_SEEK_TYPE_END: GstSeekType = 2;
#[doc = " GstSeekType:\n @GST_SEEK_TYPE_NONE: no change in position is required\n @GST_SEEK_TYPE_SET: absolute position is requested\n @GST_SEEK_TYPE_END: relative position to duration is requested\n\n The different types of seek events. When constructing a seek event with\n gst_event_new_seek() or when doing gst_segment_do_seek ()."]
pub type GstSeekType = ::std::os::raw::c_uint;
pub const GstSeekFlags_GST_SEEK_FLAG_NONE: GstSeekFlags = 0;
pub const GstSeekFlags_GST_SEEK_FLAG_FLUSH: GstSeekFlags = 1;
pub const GstSeekFlags_GST_SEEK_FLAG_ACCURATE: GstSeekFlags = 2;
pub const GstSeekFlags_GST_SEEK_FLAG_KEY_UNIT: GstSeekFlags = 4;
pub const GstSeekFlags_GST_SEEK_FLAG_SEGMENT: GstSeekFlags = 8;
pub const GstSeekFlags_GST_SEEK_FLAG_TRICKMODE: GstSeekFlags = 16;
pub const GstSeekFlags_GST_SEEK_FLAG_SKIP: GstSeekFlags = 16;
pub const GstSeekFlags_GST_SEEK_FLAG_SNAP_BEFORE: GstSeekFlags = 32;
pub const GstSeekFlags_GST_SEEK_FLAG_SNAP_AFTER: GstSeekFlags = 64;
pub const GstSeekFlags_GST_SEEK_FLAG_SNAP_NEAREST: GstSeekFlags = 96;
pub const GstSeekFlags_GST_SEEK_FLAG_TRICKMODE_KEY_UNITS: GstSeekFlags = 128;
pub const GstSeekFlags_GST_SEEK_FLAG_TRICKMODE_NO_AUDIO: GstSeekFlags = 256;
pub const GstSeekFlags_GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED: GstSeekFlags = 512;
pub const GstSeekFlags_GST_SEEK_FLAG_INSTANT_RATE_CHANGE: GstSeekFlags = 1024;
#[doc = " GstSeekFlags:\n @GST_SEEK_FLAG_NONE: no flag\n @GST_SEEK_FLAG_FLUSH: flush pipeline\n @GST_SEEK_FLAG_ACCURATE: accurate position is requested, this might\n                     be considerably slower for some formats.\n @GST_SEEK_FLAG_KEY_UNIT: seek to the nearest keyframe. This might be\n                     faster but less accurate.\n @GST_SEEK_FLAG_SEGMENT: perform a segment seek.\n @GST_SEEK_FLAG_TRICKMODE: when doing fast forward or fast reverse playback, allow\n                     elements to skip frames instead of generating all\n                     frames. (Since: 1.6)\n @GST_SEEK_FLAG_SNAP_BEFORE: go to a location before the requested position,\n                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at or before\n                     the requested position the one at or before the seek target.\n @GST_SEEK_FLAG_SNAP_AFTER: go to a location after the requested position,\n                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at of after the\n                     requested position.\n @GST_SEEK_FLAG_SNAP_NEAREST: go to a position near the requested position,\n                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe closest\n                     to the requested position, if both keyframes are at an equal\n                     distance, behaves like %GST_SEEK_FLAG_SNAP_BEFORE.\n @GST_SEEK_FLAG_TRICKMODE_KEY_UNITS: when doing fast forward or fast reverse\n                     playback, request that elements only decode keyframes\n                     and skip all other content, for formats that have\n                     keyframes. (Since: 1.6)\n @GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED: When doing fast forward or fast reverse\n                     playback, request that elements only decode keyframes and\n                     forward predicted frames and skip all other content (for example\n                     B-Frames), for formats that have keyframes and forward predicted\n                     frames. (Since: 1.18)\n @GST_SEEK_FLAG_TRICKMODE_NO_AUDIO: when doing fast forward or fast reverse\n                     playback, request that audio decoder elements skip\n                     decoding and output only gap events or silence. (Since: 1.6)\n @GST_SEEK_FLAG_INSTANT_RATE_CHANGE: Signals that a rate change should be\n                     applied immediately. Only valid if start/stop position\n                     are GST_CLOCK_TIME_NONE, the playback direction does not change\n                     and the seek is not flushing. (Since: 1.18)\n @GST_SEEK_FLAG_SKIP: Deprecated backward compatibility flag, replaced\n                     by %GST_SEEK_FLAG_TRICKMODE\n\n Flags to be used with gst_element_seek() or gst_event_new_seek(). All flags\n can be used together.\n\n A non flushing seek might take some time to perform as the currently\n playing data in the pipeline will not be cleared.\n\n An accurate seek might be slower for formats that don't have any indexes\n or timestamp markers in the stream. Specifying this flag might require a\n complete scan of the file in those cases.\n\n When performing a segment seek: after the playback of the segment completes,\n no EOS will be emitted by the element that performed the seek, but a\n %GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.\n When this message is posted, it is possible to send a new seek event to\n continue playback. With this seek method it is possible to perform seamless\n looping or simple linear editing.\n\n When only changing the playback rate and not the direction, the\n %GST_SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing seek\n to signal that the rate change should be applied immediately. This requires\n special support in the seek handlers (e.g. demuxers) and any elements\n synchronizing to the clock, and in general can't work in all cases (for example\n UDP streaming where the delivery rate is controlled by a remote server). The\n instant-rate-change mode supports changing the trickmode-related GST_SEEK_ flags,\n but can't be used in conjunction with other seek flags that affect the new\n playback position - as the playback position will not be changing.\n\n When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode\n playback, the %GST_SEEK_FLAG_TRICKMODE flag can be used to instruct decoders\n and demuxers to adjust the playback rate by skipping frames. This can improve\n performance and decrease CPU usage because not all frames need to be decoded.\n\n Beyond that, the %GST_SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be used to\n request that decoders skip all frames except key units, and\n %GST_SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio\n decoders do no decoding at all, and simple output silence.\n\n The %GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous\n relevant location, and the %GST_SEEK_FLAG_SNAP_AFTER flag can be used to\n select the next relevant location. If %GST_SEEK_FLAG_KEY_UNIT is specified,\n the relevant location is a keyframe. If both flags are specified, the nearest\n of these locations will be selected. If none are specified, the implementation is\n free to select whichever it wants.\n\n The before and after here are in running time, so when playing backwards,\n the next location refers to the one that will played in next, and not the\n one that is located after in the actual source stream.\n\n Also see part-seeking.txt in the GStreamer design documentation for more\n details on the meaning of these flags and the behaviour expected of\n elements that handle them."]
pub type GstSeekFlags = ::std::os::raw::c_uint;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_NONE: GstSegmentFlags = 0;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_RESET: GstSegmentFlags = 1;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_TRICKMODE: GstSegmentFlags = 16;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_SKIP: GstSegmentFlags = 16;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_SEGMENT: GstSegmentFlags = 8;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS: GstSegmentFlags = 128;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED: GstSegmentFlags = 512;
pub const GstSegmentFlags_GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO: GstSegmentFlags = 256;
#[doc = " GstSegmentFlags:\n @GST_SEGMENT_FLAG_NONE: no flags\n @GST_SEGMENT_FLAG_RESET: reset the pipeline running_time to the segment\n                          running_time\n @GST_SEGMENT_FLAG_TRICKMODE: perform skip playback (Since: 1.6)\n @GST_SEGMENT_FLAG_SEGMENT: send SEGMENT_DONE instead of EOS\n @GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS: Decode only keyframes, where\n                                        possible (Since: 1.6)\n @GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED: Decode only keyframes or forward\n                                        predicted frames, where possible (Since: 1.18)\n @GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO: Do not decode any audio, where\n                                        possible (Since: 1.6)\n @GST_SEGMENT_FLAG_SKIP: Deprecated backward compatibility flag, replaced\n                         by @GST_SEGMENT_FLAG_TRICKMODE\n\n Flags for the GstSegment structure. Currently mapped to the corresponding\n values of the seek flags."]
pub type GstSegmentFlags = ::std::os::raw::c_uint;
#[doc = " GstSegment:\n @flags:        flags for this segment\n @rate:         the playback rate of the segment is set in response to a seek\n                event and, without any seek, the value should be `1.0`. This\n                value is used by elements that synchronize buffer [running\n                times](additional/design/synchronisation.md#running-time) on\n                the clock (usually the sink elements), leading to consuming\n                buffers faster (for a value `> 1.0`) or slower (for `0.0 <\n                value < 1.0`) than normal playback speed. The rate also\n                defines the playback direction, meaning that when the value is\n                lower than `0.0`, the playback happens in reverse, and the\n                [stream-time](additional/design/synchronisation.md#stream-time)\n                is going backward. The `rate` value should never be `0.0`.\n @applied_rate: The applied rate is the rate that has been applied to the stream.\n                The effective/resulting playback rate of a stream is\n                `rate * applied_rate`.\n                The applied rate can be set by source elements when a server is\n                sending the stream with an already modified playback speed\n                rate. Filter elements that modify the stream in a way that\n                modifies the playback speed should also modify the applied\n                rate. For example the #videorate element when its\n                #videorate:rate property is set will set the applied rate of\n                the segment it pushed downstream. Also #scaletempo applies the\n                input segment rate to the stream and outputs a segment with\n                rate=1.0 and applied_rate=<inputsegment.rate>.\n @format:       the unit used for all of the segment's values.\n @base:         the running time (plus elapsed time, see offset) of the\n                segment [start](GstSegment.start) ([stop](GstSegment.stop) if\n                rate < 0.0).\n @offset:       the offset expresses the elapsed time (in buffer timestamps)\n                before a seek with its start (stop if rate < 0.0) seek type\n                set to #GST_SEEK_TYPE_NONE, the value is set to the position\n                of the segment at the time of the seek.\n @start:        the start time of the segment (in buffer timestamps)\n                [(PTS)](GstBuffer.pts), that is the timestamp of the first\n                buffer to output inside the segment (last one during\n                reverse playback). For example decoders will\n                [clip](gst_segment_clip) out the buffers before the start\n                time.\n @stop:         the stop time of the segment (in buffer timestamps)\n                [(PTS)](GstBuffer.pts), that is the timestamp of the last\n                buffer to output inside the segment (first one during\n                reverse playback). For example decoders will\n                [clip](gst_segment_clip) out buffers after the stop time.\n @time:         the stream time of the segment [start](GstSegment.start)\n                ([stop](GstSegment.stop) if rate < 0.0).\n @position:     the buffer timestamp position in the segment is supposed to be\n                updated by elements such as sources, demuxers or parsers to\n                track progress by setting it to the last pushed buffer' end time\n                ([timestamp](GstBuffer.pts) + #GstBuffer.duration) for that\n                specific segment. The position is used when reconfiguring the\n                segment with #gst_segment_do_seek when the seek is only\n                updating the segment (see [offset](GstSegment.offset)).\n @duration:     the duration of the segment is the maximum absolute difference\n                between #GstSegment.start and #GstSegment.stop if stop is not\n                set, otherwise it should be the difference between those\n                two values. This should be set by elements that know the\n                overall stream duration (like demuxers) and will be used when\n                seeking with #GST_SEEK_TYPE_END.\n\n The structure that holds the configured region of interest in a media file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSegment {
    pub flags: GstSegmentFlags,
    pub rate: gdouble,
    pub applied_rate: gdouble,
    pub format: GstFormat,
    pub base: guint64,
    pub offset: guint64,
    pub start: guint64,
    pub stop: guint64,
    pub time: guint64,
    pub position: guint64,
    pub duration: guint64,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstSegment"][::std::mem::size_of::<_GstSegment>() - 120usize];
    ["Alignment of _GstSegment"][::std::mem::align_of::<_GstSegment>() - 8usize];
    ["Offset of field: _GstSegment::flags"][::std::mem::offset_of!(_GstSegment, flags) - 0usize];
    ["Offset of field: _GstSegment::rate"][::std::mem::offset_of!(_GstSegment, rate) - 8usize];
    ["Offset of field: _GstSegment::applied_rate"]
        [::std::mem::offset_of!(_GstSegment, applied_rate) - 16usize];
    ["Offset of field: _GstSegment::format"][::std::mem::offset_of!(_GstSegment, format) - 24usize];
    ["Offset of field: _GstSegment::base"][::std::mem::offset_of!(_GstSegment, base) - 32usize];
    ["Offset of field: _GstSegment::offset"][::std::mem::offset_of!(_GstSegment, offset) - 40usize];
    ["Offset of field: _GstSegment::start"][::std::mem::offset_of!(_GstSegment, start) - 48usize];
    ["Offset of field: _GstSegment::stop"][::std::mem::offset_of!(_GstSegment, stop) - 56usize];
    ["Offset of field: _GstSegment::time"][::std::mem::offset_of!(_GstSegment, time) - 64usize];
    ["Offset of field: _GstSegment::position"]
        [::std::mem::offset_of!(_GstSegment, position) - 72usize];
    ["Offset of field: _GstSegment::duration"]
        [::std::mem::offset_of!(_GstSegment, duration) - 80usize];
    ["Offset of field: _GstSegment::_gst_reserved"]
        [::std::mem::offset_of!(_GstSegment, _gst_reserved) - 88usize];
};
unsafe extern "C" {
    pub fn gst_segment_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_segment_new() -> *mut GstSegment;
}
unsafe extern "C" {
    pub fn gst_segment_copy(segment: *const GstSegment) -> *mut GstSegment;
}
unsafe extern "C" {
    pub fn gst_segment_copy_into(src: *const GstSegment, dest: *mut GstSegment);
}
unsafe extern "C" {
    pub fn gst_segment_free(segment: *mut GstSegment);
}
unsafe extern "C" {
    pub fn gst_segment_init(segment: *mut GstSegment, format: GstFormat);
}
unsafe extern "C" {
    pub fn gst_segment_to_stream_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        position: guint64,
        stream_time: *mut guint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_segment_to_stream_time(
        segment: *const GstSegment,
        format: GstFormat,
        position: guint64,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn gst_segment_position_from_stream_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        stream_time: guint64,
        position: *mut guint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_segment_position_from_stream_time(
        segment: *const GstSegment,
        format: GstFormat,
        stream_time: guint64,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn gst_segment_to_running_time(
        segment: *const GstSegment,
        format: GstFormat,
        position: guint64,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn gst_segment_to_running_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        position: guint64,
        running_time: *mut guint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_segment_to_position(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: guint64,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn gst_segment_position_from_running_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: guint64,
        position: *mut guint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_segment_position_from_running_time(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: guint64,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn gst_segment_set_running_time(
        segment: *mut GstSegment,
        format: GstFormat,
        running_time: guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_segment_offset_running_time(
        segment: *mut GstSegment,
        format: GstFormat,
        offset: gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_segment_clip(
        segment: *const GstSegment,
        format: GstFormat,
        start: guint64,
        stop: guint64,
        clip_start: *mut guint64,
        clip_stop: *mut guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_segment_do_seek(
        segment: *mut GstSegment,
        rate: gdouble,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: guint64,
        stop_type: GstSeekType,
        stop: guint64,
        update: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_segment_is_equal(s0: *const GstSegment, s1: *const GstSegment) -> gboolean;
}
pub type GstSegment_autoptr = *mut GstSegment;
pub type GstSegment_listautoptr = *mut GList;
pub type GstSegment_slistautoptr = *mut GSList;
pub type GstSegment_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_sample_type: GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSample {
    _unused: [u8; 0],
}
#[doc = " GstSample:\n\n The opaque structure of a #GstSample. A sample contains a typed memory\n block and the associated timing information. It is mainly used to\n exchange buffers with an application."]
pub type GstSample = _GstSample;
unsafe extern "C" {
    pub fn gst_sample_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_sample_new(
        buffer: *mut GstBuffer,
        caps: *mut GstCaps,
        segment: *const GstSegment,
        info: *mut GstStructure,
    ) -> *mut GstSample;
}
unsafe extern "C" {
    pub fn gst_sample_get_buffer(sample: *mut GstSample) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_sample_get_caps(sample: *mut GstSample) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_sample_get_segment(sample: *mut GstSample) -> *mut GstSegment;
}
unsafe extern "C" {
    pub fn gst_sample_get_info(sample: *mut GstSample) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_sample_get_buffer_list(sample: *mut GstSample) -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_sample_set_buffer_list(sample: *mut GstSample, buffer_list: *mut GstBufferList);
}
unsafe extern "C" {
    pub fn gst_sample_set_buffer(sample: *mut GstSample, buffer: *mut GstBuffer);
}
unsafe extern "C" {
    pub fn gst_sample_set_caps(sample: *mut GstSample, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_sample_set_segment(sample: *mut GstSample, segment: *const GstSegment);
}
unsafe extern "C" {
    pub fn gst_sample_set_info(sample: *mut GstSample, info: *mut GstStructure) -> gboolean;
}
pub type GstSample_autoptr = *mut GstSample;
pub type GstSample_listautoptr = *mut GList;
pub type GstSample_slistautoptr = *mut GSList;
pub type GstSample_queueautoptr = *mut GQueue;
pub const GstTagMergeMode_GST_TAG_MERGE_UNDEFINED: GstTagMergeMode = 0;
pub const GstTagMergeMode_GST_TAG_MERGE_REPLACE_ALL: GstTagMergeMode = 1;
pub const GstTagMergeMode_GST_TAG_MERGE_REPLACE: GstTagMergeMode = 2;
pub const GstTagMergeMode_GST_TAG_MERGE_APPEND: GstTagMergeMode = 3;
pub const GstTagMergeMode_GST_TAG_MERGE_PREPEND: GstTagMergeMode = 4;
pub const GstTagMergeMode_GST_TAG_MERGE_KEEP: GstTagMergeMode = 5;
pub const GstTagMergeMode_GST_TAG_MERGE_KEEP_ALL: GstTagMergeMode = 6;
pub const GstTagMergeMode_GST_TAG_MERGE_COUNT: GstTagMergeMode = 7;
#[doc = " GstTagMergeMode:\n @GST_TAG_MERGE_UNDEFINED: undefined merge mode\n @GST_TAG_MERGE_REPLACE_ALL: replace all tags (clear list and append)\n @GST_TAG_MERGE_REPLACE: replace tags\n @GST_TAG_MERGE_APPEND: append tags\n @GST_TAG_MERGE_PREPEND: prepend tags\n @GST_TAG_MERGE_KEEP: keep existing tags\n @GST_TAG_MERGE_KEEP_ALL: keep all existing tags\n @GST_TAG_MERGE_COUNT: the number of merge modes\n\n The different tag merging modes are basically replace, overwrite and append,\n but they can be seen from two directions. Given two taglists: (A) the tags\n already in the element and (B) the ones that are supplied to the element (\n e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or a\n %GST_EVENT_TAG), how are these tags merged?\n In the table below this is shown for the cases that a tag exists in the list\n (A) or does not exists (!A) and combinations thereof.\n\n | merge mode  | A + B | A + !B | !A + B | !A + !B |\n | ----------- | ----- | ------ | ------ | ------- |\n | REPLACE_ALL | B     |       | B      |        |\n | REPLACE     | B     | A      | B      |        |\n | APPEND      | A, B  | A      | B      |        |\n | PREPEND     | B, A  | A      | B      |        |\n | KEEP        | A     | A      | B      |        |\n | KEEP_ALL    | A     | A      |       |        |"]
pub type GstTagMergeMode = ::std::os::raw::c_uint;
pub const GstTagFlag_GST_TAG_FLAG_UNDEFINED: GstTagFlag = 0;
pub const GstTagFlag_GST_TAG_FLAG_META: GstTagFlag = 1;
pub const GstTagFlag_GST_TAG_FLAG_ENCODED: GstTagFlag = 2;
pub const GstTagFlag_GST_TAG_FLAG_DECODED: GstTagFlag = 3;
pub const GstTagFlag_GST_TAG_FLAG_COUNT: GstTagFlag = 4;
#[doc = " GstTagFlag:\n @GST_TAG_FLAG_UNDEFINED: undefined flag\n @GST_TAG_FLAG_META: tag is meta data\n @GST_TAG_FLAG_ENCODED: tag is encoded\n @GST_TAG_FLAG_DECODED: tag is decoded\n @GST_TAG_FLAG_COUNT: number of tag flags\n\n Extra tag flags used when registering tags."]
pub type GstTagFlag = ::std::os::raw::c_uint;
#[doc = " GstTagList:\n @mini_object: the parent type\n\n Object describing tags / metadata."]
pub type GstTagList = _GstTagList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTagList {
    pub mini_object: GstMiniObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTagList"][::std::mem::size_of::<_GstTagList>() - 64usize];
    ["Alignment of _GstTagList"][::std::mem::align_of::<_GstTagList>() - 8usize];
    ["Offset of field: _GstTagList::mini_object"]
        [::std::mem::offset_of!(_GstTagList, mini_object) - 0usize];
};
unsafe extern "C" {
    pub static mut _gst_tag_list_type: GType;
}
#[doc = " GstTagForeachFunc:\n @list: the #GstTagList\n @tag: a name of a tag in @list\n @user_data: user data\n\n A function that will be called in gst_tag_list_foreach(). The function may\n not modify the tag list."]
pub type GstTagForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(list: *const GstTagList, tag: *const gchar, user_data: gpointer),
>;
#[doc = " GstTagMergeFunc:\n @dest: the destination #GValue\n @src: the source #GValue\n\n A function for merging multiple values of a tag used when registering\n tags."]
pub type GstTagMergeFunc =
    ::std::option::Option<unsafe extern "C" fn(dest: *mut GValue, src: *const GValue)>;
unsafe extern "C" {
    pub fn gst_tag_list_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_register(
        name: *const gchar,
        flag: GstTagFlag,
        type_: GType,
        nick: *const gchar,
        blurb: *const gchar,
        func: GstTagMergeFunc,
    );
}
unsafe extern "C" {
    pub fn gst_tag_register_static(
        name: *const gchar,
        flag: GstTagFlag,
        type_: GType,
        nick: *const gchar,
        blurb: *const gchar,
        func: GstTagMergeFunc,
    );
}
unsafe extern "C" {
    pub fn gst_tag_merge_use_first(dest: *mut GValue, src: *const GValue);
}
unsafe extern "C" {
    pub fn gst_tag_merge_strings_with_comma(dest: *mut GValue, src: *const GValue);
}
unsafe extern "C" {
    pub fn gst_tag_exists(tag: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_get_type(tag: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_get_nick(tag: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_tag_get_description(tag: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_tag_get_flag(tag: *const gchar) -> GstTagFlag;
}
unsafe extern "C" {
    pub fn gst_tag_is_fixed(tag: *const gchar) -> gboolean;
}
pub const GstTagScope_GST_TAG_SCOPE_STREAM: GstTagScope = 0;
pub const GstTagScope_GST_TAG_SCOPE_GLOBAL: GstTagScope = 1;
#[doc = " GstTagScope:\n @GST_TAG_SCOPE_STREAM: tags specific to this single stream\n @GST_TAG_SCOPE_GLOBAL: global tags for the complete medium\n\n GstTagScope specifies if a taglist applies to the complete\n medium or only to one single stream."]
pub type GstTagScope = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_tag_list_new_empty() -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_list_new(tag: *const gchar, ...) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_list_new_valist(var_args: *mut __va_list_tag) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_list_set_scope(list: *mut GstTagList, scope: GstTagScope);
}
unsafe extern "C" {
    pub fn gst_tag_list_get_scope(list: *const GstTagList) -> GstTagScope;
}
unsafe extern "C" {
    pub fn gst_tag_list_to_string(list: *const GstTagList) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_tag_list_new_from_string(str_: *const gchar) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_list_n_tags(list: *const GstTagList) -> gint;
}
unsafe extern "C" {
    pub fn gst_tag_list_nth_tag_name(list: *const GstTagList, index: guint) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_tag_list_is_empty(list: *const GstTagList) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_is_equal(list1: *const GstTagList, list2: *const GstTagList) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_insert(
        into: *mut GstTagList,
        from: *const GstTagList,
        mode: GstTagMergeMode,
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_merge(
        list1: *const GstTagList,
        list2: *const GstTagList,
        mode: GstTagMergeMode,
    ) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_tag_size(list: *const GstTagList, tag: *const gchar) -> guint;
}
unsafe extern "C" {
    pub fn gst_tag_list_add(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_tag_list_add_values(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_add_valist(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_add_valist_values(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_add_value(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_remove_tag(list: *mut GstTagList, tag: *const gchar);
}
unsafe extern "C" {
    pub fn gst_tag_list_foreach(
        list: *const GstTagList,
        func: GstTagForeachFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_tag_list_get_value_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
    ) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_tag_list_copy_value(
        dest: *mut GValue,
        list: *const GstTagList,
        tag: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_boolean(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_boolean_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_int(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_int_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_uint(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_uint_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_int64(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_int64_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_uint64(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_uint64_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_float(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gfloat,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_float_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gfloat,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_double(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_double_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_string(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut *mut gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_string_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut *mut gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_peek_string_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_pointer(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_pointer_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_date(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut *mut GDate,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_date_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut *mut GDate,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_date_time(
        list: *const GstTagList,
        tag: *const gchar,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_date_time_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_sample(
        list: *const GstTagList,
        tag: *const gchar,
        sample: *mut *mut GstSample,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_get_sample_index(
        list: *const GstTagList,
        tag: *const gchar,
        index: guint,
        sample: *mut *mut GstSample,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tag_list_copy(taglist: *const GstTagList) -> *mut GstTagList;
}
pub type GstTagList_autoptr = *mut GstTagList;
pub type GstTagList_listautoptr = *mut GList;
pub type GstTagList_slistautoptr = *mut GSList;
pub type GstTagList_queueautoptr = *mut GQueue;
#[doc = " GstMessage:\n @mini_object: the parent structure\n @type: the #GstMessageType of the message\n @timestamp: the timestamp of the message\n @src: the src of the message\n @seqnum: the sequence number of the message\n\n A #GstMessage."]
pub type GstMessage = _GstMessage;
pub const GstMessageType_GST_MESSAGE_UNKNOWN: GstMessageType = 0;
pub const GstMessageType_GST_MESSAGE_EOS: GstMessageType = 1;
pub const GstMessageType_GST_MESSAGE_ERROR: GstMessageType = 2;
pub const GstMessageType_GST_MESSAGE_WARNING: GstMessageType = 4;
pub const GstMessageType_GST_MESSAGE_INFO: GstMessageType = 8;
pub const GstMessageType_GST_MESSAGE_TAG: GstMessageType = 16;
pub const GstMessageType_GST_MESSAGE_BUFFERING: GstMessageType = 32;
pub const GstMessageType_GST_MESSAGE_STATE_CHANGED: GstMessageType = 64;
pub const GstMessageType_GST_MESSAGE_STATE_DIRTY: GstMessageType = 128;
pub const GstMessageType_GST_MESSAGE_STEP_DONE: GstMessageType = 256;
pub const GstMessageType_GST_MESSAGE_CLOCK_PROVIDE: GstMessageType = 512;
pub const GstMessageType_GST_MESSAGE_CLOCK_LOST: GstMessageType = 1024;
pub const GstMessageType_GST_MESSAGE_NEW_CLOCK: GstMessageType = 2048;
pub const GstMessageType_GST_MESSAGE_STRUCTURE_CHANGE: GstMessageType = 4096;
pub const GstMessageType_GST_MESSAGE_STREAM_STATUS: GstMessageType = 8192;
pub const GstMessageType_GST_MESSAGE_APPLICATION: GstMessageType = 16384;
pub const GstMessageType_GST_MESSAGE_ELEMENT: GstMessageType = 32768;
pub const GstMessageType_GST_MESSAGE_SEGMENT_START: GstMessageType = 65536;
pub const GstMessageType_GST_MESSAGE_SEGMENT_DONE: GstMessageType = 131072;
pub const GstMessageType_GST_MESSAGE_DURATION_CHANGED: GstMessageType = 262144;
pub const GstMessageType_GST_MESSAGE_LATENCY: GstMessageType = 524288;
pub const GstMessageType_GST_MESSAGE_ASYNC_START: GstMessageType = 1048576;
pub const GstMessageType_GST_MESSAGE_ASYNC_DONE: GstMessageType = 2097152;
pub const GstMessageType_GST_MESSAGE_REQUEST_STATE: GstMessageType = 4194304;
pub const GstMessageType_GST_MESSAGE_STEP_START: GstMessageType = 8388608;
pub const GstMessageType_GST_MESSAGE_QOS: GstMessageType = 16777216;
pub const GstMessageType_GST_MESSAGE_PROGRESS: GstMessageType = 33554432;
pub const GstMessageType_GST_MESSAGE_TOC: GstMessageType = 67108864;
pub const GstMessageType_GST_MESSAGE_RESET_TIME: GstMessageType = 134217728;
pub const GstMessageType_GST_MESSAGE_STREAM_START: GstMessageType = 268435456;
pub const GstMessageType_GST_MESSAGE_NEED_CONTEXT: GstMessageType = 536870912;
pub const GstMessageType_GST_MESSAGE_HAVE_CONTEXT: GstMessageType = 1073741824;
pub const GstMessageType_GST_MESSAGE_EXTENDED: GstMessageType = -2147483648;
pub const GstMessageType_GST_MESSAGE_DEVICE_ADDED: GstMessageType = -2147483647;
pub const GstMessageType_GST_MESSAGE_DEVICE_REMOVED: GstMessageType = -2147483646;
pub const GstMessageType_GST_MESSAGE_PROPERTY_NOTIFY: GstMessageType = -2147483645;
pub const GstMessageType_GST_MESSAGE_STREAM_COLLECTION: GstMessageType = -2147483644;
pub const GstMessageType_GST_MESSAGE_STREAMS_SELECTED: GstMessageType = -2147483643;
pub const GstMessageType_GST_MESSAGE_REDIRECT: GstMessageType = -2147483642;
pub const GstMessageType_GST_MESSAGE_DEVICE_CHANGED: GstMessageType = -2147483641;
pub const GstMessageType_GST_MESSAGE_INSTANT_RATE_REQUEST: GstMessageType = -2147483640;
pub const GstMessageType_GST_MESSAGE_ANY: GstMessageType = -1;
#[doc = " GstMessageType:\n @GST_MESSAGE_UNKNOWN: an undefined message\n @GST_MESSAGE_EOS: end-of-stream reached in a pipeline. The application will\n only receive this message in the PLAYING state and every time it sets a\n pipeline to PLAYING that is in the EOS state. The application can perform a\n flushing seek in the pipeline, which will undo the EOS state again.\n @GST_MESSAGE_ERROR: an error occurred. When the application receives an error\n message it should stop playback of the pipeline and not assume that more\n data will be played. It is possible to specify a redirection url to the error\n messages by setting a `redirect-location` field into the error message, application\n or high level bins might use the information as required.\n @GST_MESSAGE_WARNING: a warning occurred.\n @GST_MESSAGE_INFO: an info message occurred\n @GST_MESSAGE_TAG: a tag was found.\n @GST_MESSAGE_BUFFERING: the pipeline is buffering. When the application\n receives a buffering message in the PLAYING state for a non-live pipeline it\n must PAUSE the pipeline until the buffering completes, when the percentage\n field in the message is 100%. For live pipelines, no action must be\n performed and the buffering percentage can be used to inform the user about\n the progress.\n @GST_MESSAGE_STATE_CHANGED: a state change happened\n @GST_MESSAGE_STATE_DIRTY: an element changed state in a streaming thread.\n This message is deprecated.\n @GST_MESSAGE_STEP_DONE: a stepping operation finished.\n @GST_MESSAGE_CLOCK_PROVIDE: an element notifies its capability of providing\n                             a clock. This message is used internally and\n                             never forwarded to the application.\n @GST_MESSAGE_CLOCK_LOST: The current clock as selected by the pipeline became\n                          unusable. The pipeline will select a new clock on\n                          the next PLAYING state change. The application\n                          should set the pipeline to PAUSED and back to\n                          PLAYING when this message is received.\n @GST_MESSAGE_NEW_CLOCK: a new clock was selected in the pipeline.\n @GST_MESSAGE_STRUCTURE_CHANGE: the structure of the pipeline changed. This\n message is used internally and never forwarded to the application.\n @GST_MESSAGE_STREAM_STATUS: status about a stream, emitted when it starts,\n                             stops, errors, etc..\n @GST_MESSAGE_APPLICATION: message posted by the application, possibly\n                           via an application-specific element.\n @GST_MESSAGE_ELEMENT: element-specific message, see the specific element's\n                       documentation\n @GST_MESSAGE_SEGMENT_START: pipeline started playback of a segment. This\n message is used internally and never forwarded to the application.\n @GST_MESSAGE_SEGMENT_DONE: pipeline completed playback of a segment. This\n message is forwarded to the application after all elements that posted\n @GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.\n @GST_MESSAGE_DURATION_CHANGED: The duration of a pipeline changed. The\n application can get the new duration with a duration query.\n @GST_MESSAGE_ASYNC_START: Posted by elements when they start an ASYNC\n #GstStateChange. This message is not forwarded to the application but is used\n internally.\n @GST_MESSAGE_ASYNC_DONE: Posted by elements when they complete an ASYNC\n #GstStateChange. The application will only receive this message from the toplevel\n pipeline.\n @GST_MESSAGE_LATENCY: Posted by elements when their latency changes. The\n application should recalculate and distribute a new latency.\n @GST_MESSAGE_REQUEST_STATE: Posted by elements when they want the pipeline to\n change state. This message is a suggestion to the application which can\n decide to perform the state change on (part of) the pipeline.\n @GST_MESSAGE_STEP_START: A stepping operation was started.\n @GST_MESSAGE_QOS: A buffer was dropped or an element changed its processing\n strategy for Quality of Service reasons.\n @GST_MESSAGE_PROGRESS: A progress message.\n @GST_MESSAGE_TOC: A new table of contents (TOC) was found or previously found TOC\n was updated.\n @GST_MESSAGE_RESET_TIME: Message to request resetting the pipeline's\n     running time from the pipeline. This is an internal message which\n     applications will likely never receive.\n @GST_MESSAGE_STREAM_START: Message indicating start of a new stream. Useful\n     e.g. when using playbin in gapless playback mode, to get notified when\n     the next title actually starts playing (which will be some time after\n     the URI for the next title has been set).\n @GST_MESSAGE_NEED_CONTEXT: Message indicating that an element wants a specific context (Since: 1.2)\n @GST_MESSAGE_HAVE_CONTEXT: Message indicating that an element created a context (Since: 1.2)\n @GST_MESSAGE_EXTENDED: Message is an extended message type (see below).\n     These extended message IDs can't be used directly with mask-based API\n     like gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still\n     filter for GST_MESSAGE_EXTENDED and then check the result for the\n     specific type. (Since: 1.4)\n @GST_MESSAGE_DEVICE_ADDED: Message indicating a #GstDevice was added to\n     a #GstDeviceProvider (Since: 1.4)\n @GST_MESSAGE_DEVICE_REMOVED: Message indicating a #GstDevice was removed\n     from a #GstDeviceProvider (Since: 1.4)\n @GST_MESSAGE_PROPERTY_NOTIFY: Message indicating a #GObject property has\n     changed (Since: 1.10)\n @GST_MESSAGE_STREAM_COLLECTION: Message indicating a new #GstStreamCollection\n     is available (Since: 1.10)\n @GST_MESSAGE_STREAMS_SELECTED: Message indicating the active selection of\n     #GstStreams has changed (Since: 1.10)\n @GST_MESSAGE_REDIRECT: Message indicating to request the application to\n     try to play the given URL(s). Useful if for example a HTTP 302/303\n     response is received with a non-HTTP URL inside. (Since: 1.10)\n @GST_MESSAGE_DEVICE_CHANGED: Message indicating a #GstDevice was changed\n     a #GstDeviceProvider (Since: 1.16)\n @GST_MESSAGE_INSTANT_RATE_REQUEST: Message sent by elements to request the\n     running time from the pipeline when an instant rate change should\n     be applied (which may be in the past when the answer arrives). (Since: 1.18)\n @GST_MESSAGE_ANY: mask for all of the above messages.\n\n The different message types that are available."]
pub type GstMessageType = ::std::os::raw::c_int;
#[doc = " GstQuery:\n @mini_object: The parent #GstMiniObject type\n @type: the #GstQueryType\n\n The #GstQuery structure."]
pub type GstQuery = _GstQuery;
pub const GstQueryTypeFlags_GST_QUERY_TYPE_UPSTREAM: GstQueryTypeFlags = 1;
pub const GstQueryTypeFlags_GST_QUERY_TYPE_DOWNSTREAM: GstQueryTypeFlags = 2;
pub const GstQueryTypeFlags_GST_QUERY_TYPE_SERIALIZED: GstQueryTypeFlags = 4;
#[doc = " GstQueryTypeFlags:\n @GST_QUERY_TYPE_UPSTREAM:     Set if the query can travel upstream.\n @GST_QUERY_TYPE_DOWNSTREAM:   Set if the query can travel downstream.\n @GST_QUERY_TYPE_SERIALIZED:   Set if the query should be serialized with data\n                               flow.\n\n #GstQueryTypeFlags indicate the aspects of the different #GstQueryType\n values. You can get the type flags of a #GstQueryType with the\n gst_query_type_get_flags() function."]
pub type GstQueryTypeFlags = ::std::os::raw::c_uint;
pub const GstQueryType_GST_QUERY_UNKNOWN: GstQueryType = 0;
pub const GstQueryType_GST_QUERY_POSITION: GstQueryType = 2563;
pub const GstQueryType_GST_QUERY_DURATION: GstQueryType = 5123;
pub const GstQueryType_GST_QUERY_LATENCY: GstQueryType = 7683;
pub const GstQueryType_GST_QUERY_JITTER: GstQueryType = 10243;
pub const GstQueryType_GST_QUERY_RATE: GstQueryType = 12803;
pub const GstQueryType_GST_QUERY_SEEKING: GstQueryType = 15363;
pub const GstQueryType_GST_QUERY_SEGMENT: GstQueryType = 17923;
pub const GstQueryType_GST_QUERY_CONVERT: GstQueryType = 20483;
pub const GstQueryType_GST_QUERY_FORMATS: GstQueryType = 23043;
pub const GstQueryType_GST_QUERY_BUFFERING: GstQueryType = 28163;
pub const GstQueryType_GST_QUERY_CUSTOM: GstQueryType = 30723;
pub const GstQueryType_GST_QUERY_URI: GstQueryType = 33283;
pub const GstQueryType_GST_QUERY_ALLOCATION: GstQueryType = 35846;
pub const GstQueryType_GST_QUERY_SCHEDULING: GstQueryType = 38401;
pub const GstQueryType_GST_QUERY_ACCEPT_CAPS: GstQueryType = 40963;
pub const GstQueryType_GST_QUERY_CAPS: GstQueryType = 43523;
pub const GstQueryType_GST_QUERY_DRAIN: GstQueryType = 46086;
pub const GstQueryType_GST_QUERY_CONTEXT: GstQueryType = 48643;
pub const GstQueryType_GST_QUERY_BITRATE: GstQueryType = 51202;
#[doc = " GstQueryType:\n @GST_QUERY_UNKNOWN: unknown query type\n @GST_QUERY_POSITION: current position in stream\n @GST_QUERY_DURATION: total duration of the stream\n @GST_QUERY_LATENCY: latency of stream\n @GST_QUERY_JITTER: current jitter of stream\n @GST_QUERY_RATE: current rate of the stream\n @GST_QUERY_SEEKING: seeking capabilities\n @GST_QUERY_SEGMENT: segment start/stop positions\n @GST_QUERY_CONVERT: convert values between formats\n @GST_QUERY_FORMATS: query supported formats for convert\n @GST_QUERY_BUFFERING: query available media for efficient seeking.\n @GST_QUERY_CUSTOM: a custom application or element defined query.\n @GST_QUERY_URI: query the URI of the source or sink.\n @GST_QUERY_ALLOCATION: the buffer allocation properties\n @GST_QUERY_SCHEDULING: the scheduling properties\n @GST_QUERY_ACCEPT_CAPS: the accept caps query\n @GST_QUERY_CAPS: the caps query\n @GST_QUERY_DRAIN: wait till all serialized data is consumed downstream\n @GST_QUERY_CONTEXT: query the pipeline-local context from\n     downstream or upstream (since 1.2)\n @GST_QUERY_BITRATE: the bitrate query (since 1.16)\n\n Standard predefined Query types"]
pub type GstQueryType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static mut _gst_query_type: GType;
}
#[doc = " GstQuery:\n @mini_object: The parent #GstMiniObject type\n @type: the #GstQueryType\n\n The #GstQuery structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstQuery {
    pub mini_object: GstMiniObject,
    pub type_: GstQueryType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstQuery"][::std::mem::size_of::<_GstQuery>() - 72usize];
    ["Alignment of _GstQuery"][::std::mem::align_of::<_GstQuery>() - 8usize];
    ["Offset of field: _GstQuery::mini_object"]
        [::std::mem::offset_of!(_GstQuery, mini_object) - 0usize];
    ["Offset of field: _GstQuery::type_"][::std::mem::offset_of!(_GstQuery, type_) - 64usize];
};
pub const GstBufferingMode_GST_BUFFERING_STREAM: GstBufferingMode = 0;
pub const GstBufferingMode_GST_BUFFERING_DOWNLOAD: GstBufferingMode = 1;
pub const GstBufferingMode_GST_BUFFERING_TIMESHIFT: GstBufferingMode = 2;
pub const GstBufferingMode_GST_BUFFERING_LIVE: GstBufferingMode = 3;
#[doc = " GstBufferingMode:\n @GST_BUFFERING_STREAM: a small amount of data is buffered\n @GST_BUFFERING_DOWNLOAD: the stream is being downloaded\n @GST_BUFFERING_TIMESHIFT: the stream is being downloaded in a ringbuffer\n @GST_BUFFERING_LIVE: the stream is a live stream\n\n The different types of buffering methods."]
pub type GstBufferingMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static mut _gst_toc_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_toc_entry_type: GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTocEntry {
    _unused: [u8; 0],
}
pub type GstTocEntry = _GstTocEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstToc {
    _unused: [u8; 0],
}
pub type GstToc = _GstToc;
pub const GstTocScope_GST_TOC_SCOPE_GLOBAL: GstTocScope = 1;
pub const GstTocScope_GST_TOC_SCOPE_CURRENT: GstTocScope = 2;
#[doc = " GstTocScope:\n @GST_TOC_SCOPE_GLOBAL: global TOC representing all selectable options\n     (this is what applications are usually interested in)\n @GST_TOC_SCOPE_CURRENT: TOC for the currently active/selected stream\n     (this is a TOC representing the current stream from start to EOS,\n     and is what a TOC writer / muxer is usually interested in; it will\n     usually be a subset of the global TOC, e.g. just the chapters of\n     the current title, or the chapters selected for playback from the\n     current title)\n\n The scope of a TOC."]
pub type GstTocScope = ::std::os::raw::c_uint;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_ANGLE: GstTocEntryType = -3;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_VERSION: GstTocEntryType = -2;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_EDITION: GstTocEntryType = -1;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_INVALID: GstTocEntryType = 0;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_TITLE: GstTocEntryType = 1;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_TRACK: GstTocEntryType = 2;
pub const GstTocEntryType_GST_TOC_ENTRY_TYPE_CHAPTER: GstTocEntryType = 3;
#[doc = " GstTocEntryType:\n @GST_TOC_ENTRY_TYPE_ANGLE: entry is an angle (i.e. an alternative)\n @GST_TOC_ENTRY_TYPE_VERSION: entry is a version (i.e. alternative)\n @GST_TOC_ENTRY_TYPE_EDITION: entry is an edition (i.e. alternative)\n @GST_TOC_ENTRY_TYPE_INVALID: invalid entry type value\n @GST_TOC_ENTRY_TYPE_TITLE: entry is a title (i.e. a part of a sequence)\n @GST_TOC_ENTRY_TYPE_TRACK: entry is a track (i.e. a part of a sequence)\n @GST_TOC_ENTRY_TYPE_CHAPTER: entry is a chapter (i.e. a part of a sequence)\n\n The different types of TOC entries (see #GstTocEntry).\n\n There are two types of TOC entries: alternatives or parts in a sequence."]
pub type GstTocEntryType = ::std::os::raw::c_int;
pub const GstTocLoopType_GST_TOC_LOOP_NONE: GstTocLoopType = 0;
pub const GstTocLoopType_GST_TOC_LOOP_FORWARD: GstTocLoopType = 1;
pub const GstTocLoopType_GST_TOC_LOOP_REVERSE: GstTocLoopType = 2;
pub const GstTocLoopType_GST_TOC_LOOP_PING_PONG: GstTocLoopType = 3;
#[doc = " GstTocLoopType:\n @GST_TOC_LOOP_NONE: single forward playback\n @GST_TOC_LOOP_FORWARD: repeat forward\n @GST_TOC_LOOP_REVERSE: repeat backward\n @GST_TOC_LOOP_PING_PONG: repeat forward and backward\n\n How a #GstTocEntry should be repeated. By default, entries are played a\n single time.\n\n Since: 1.4"]
pub type GstTocLoopType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_toc_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_new(scope: GstTocScope) -> *mut GstToc;
}
unsafe extern "C" {
    pub fn gst_toc_get_scope(toc: *const GstToc) -> GstTocScope;
}
unsafe extern "C" {
    pub fn gst_toc_set_tags(toc: *mut GstToc, tags: *mut GstTagList);
}
unsafe extern "C" {
    pub fn gst_toc_merge_tags(toc: *mut GstToc, tags: *mut GstTagList, mode: GstTagMergeMode);
}
unsafe extern "C" {
    pub fn gst_toc_get_tags(toc: *const GstToc) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_toc_append_entry(toc: *mut GstToc, entry: *mut GstTocEntry);
}
unsafe extern "C" {
    pub fn gst_toc_get_entries(toc: *const GstToc) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_toc_dump(toc: *mut GstToc);
}
unsafe extern "C" {
    pub fn gst_toc_entry_new(type_: GstTocEntryType, uid: *const gchar) -> *mut GstTocEntry;
}
unsafe extern "C" {
    pub fn gst_toc_find_entry(toc: *const GstToc, uid: *const gchar) -> *mut GstTocEntry;
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_entry_type(entry: *const GstTocEntry) -> GstTocEntryType;
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_uid(entry: *const GstTocEntry) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_toc_entry_append_sub_entry(entry: *mut GstTocEntry, subentry: *mut GstTocEntry);
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_sub_entries(entry: *const GstTocEntry) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_toc_entry_set_tags(entry: *mut GstTocEntry, tags: *mut GstTagList);
}
unsafe extern "C" {
    pub fn gst_toc_entry_merge_tags(
        entry: *mut GstTocEntry,
        tags: *mut GstTagList,
        mode: GstTagMergeMode,
    );
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_tags(entry: *const GstTocEntry) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_toc_entry_is_alternative(entry: *const GstTocEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_toc_entry_is_sequence(entry: *const GstTocEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_toc_entry_set_start_stop_times(entry: *mut GstTocEntry, start: gint64, stop: gint64);
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_start_stop_times(
        entry: *const GstTocEntry,
        start: *mut gint64,
        stop: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_toc_entry_set_loop(
        entry: *mut GstTocEntry,
        loop_type: GstTocLoopType,
        repeat_count: gint,
    );
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_loop(
        entry: *const GstTocEntry,
        loop_type: *mut GstTocLoopType,
        repeat_count: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_toc(entry: *mut GstTocEntry) -> *mut GstToc;
}
unsafe extern "C" {
    pub fn gst_toc_entry_get_parent(entry: *mut GstTocEntry) -> *mut GstTocEntry;
}
unsafe extern "C" {
    pub fn gst_toc_entry_type_get_nick(type_: GstTocEntryType) -> *const gchar;
}
pub type GstToc_autoptr = *mut GstToc;
pub type GstToc_listautoptr = *mut GList;
pub type GstToc_slistautoptr = *mut GSList;
pub type GstToc_queueautoptr = *mut GQueue;
pub type GstTocEntry_autoptr = *mut GstTocEntry;
pub type GstTocEntry_listautoptr = *mut GList;
pub type GstTocEntry_slistautoptr = *mut GSList;
pub type GstTocEntry_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstContext {
    _unused: [u8; 0],
}
pub type GstContext = _GstContext;
unsafe extern "C" {
    pub static mut _gst_context_type: GType;
}
unsafe extern "C" {
    pub fn gst_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_context_new(context_type: *const gchar, persistent: gboolean) -> *mut GstContext;
}
unsafe extern "C" {
    pub fn gst_context_get_context_type(context: *const GstContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_context_has_context_type(
        context: *const GstContext,
        context_type: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_context_get_structure(context: *const GstContext) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_context_writable_structure(context: *mut GstContext) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_context_is_persistent(context: *const GstContext) -> gboolean;
}
pub type GstContext_autoptr = *mut GstContext;
pub type GstContext_listautoptr = *mut GList;
pub type GstContext_slistautoptr = *mut GSList;
pub type GstContext_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_query_type_get_name(type_: GstQueryType) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_query_type_to_quark(type_: GstQueryType) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_query_type_get_flags(type_: GstQueryType) -> GstQueryTypeFlags;
}
unsafe extern "C" {
    pub fn gst_query_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_query_new_custom(type_: GstQueryType, structure: *mut GstStructure)
    -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_get_structure(query: *mut GstQuery) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_query_writable_structure(query: *mut GstQuery) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_query_new_position(format: GstFormat) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_position(query: *mut GstQuery, format: GstFormat, cur: gint64);
}
unsafe extern "C" {
    pub fn gst_query_parse_position(query: *mut GstQuery, format: *mut GstFormat, cur: *mut gint64);
}
unsafe extern "C" {
    pub fn gst_query_new_duration(format: GstFormat) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_duration(query: *mut GstQuery, format: GstFormat, duration: gint64);
}
unsafe extern "C" {
    pub fn gst_query_parse_duration(
        query: *mut GstQuery,
        format: *mut GstFormat,
        duration: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_new_latency() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_latency(
        query: *mut GstQuery,
        live: gboolean,
        min_latency: GstClockTime,
        max_latency: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_latency(
        query: *mut GstQuery,
        live: *mut gboolean,
        min_latency: *mut GstClockTime,
        max_latency: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_query_new_convert(
        src_format: GstFormat,
        value: gint64,
        dest_format: GstFormat,
    ) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_convert(
        query: *mut GstQuery,
        src_format: GstFormat,
        src_value: gint64,
        dest_format: GstFormat,
        dest_value: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_convert(
        query: *mut GstQuery,
        src_format: *mut GstFormat,
        src_value: *mut gint64,
        dest_format: *mut GstFormat,
        dest_value: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_new_segment(format: GstFormat) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_segment(
        query: *mut GstQuery,
        rate: gdouble,
        format: GstFormat,
        start_value: gint64,
        stop_value: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_segment(
        query: *mut GstQuery,
        rate: *mut gdouble,
        format: *mut GstFormat,
        start_value: *mut gint64,
        stop_value: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_new_seeking(format: GstFormat) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_seeking(
        query: *mut GstQuery,
        format: GstFormat,
        seekable: gboolean,
        segment_start: gint64,
        segment_end: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_seeking(
        query: *mut GstQuery,
        format: *mut GstFormat,
        seekable: *mut gboolean,
        segment_start: *mut gint64,
        segment_end: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_new_formats() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_formats(query: *mut GstQuery, n_formats: gint, ...);
}
unsafe extern "C" {
    pub fn gst_query_set_formatsv(query: *mut GstQuery, n_formats: gint, formats: *const GstFormat);
}
unsafe extern "C" {
    pub fn gst_query_parse_n_formats(query: *mut GstQuery, n_formats: *mut guint);
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_format(query: *mut GstQuery, nth: guint, format: *mut GstFormat);
}
unsafe extern "C" {
    pub fn gst_query_new_buffering(format: GstFormat) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_buffering_percent(query: *mut GstQuery, busy: gboolean, percent: gint);
}
unsafe extern "C" {
    pub fn gst_query_parse_buffering_percent(
        query: *mut GstQuery,
        busy: *mut gboolean,
        percent: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_query_set_buffering_stats(
        query: *mut GstQuery,
        mode: GstBufferingMode,
        avg_in: gint,
        avg_out: gint,
        buffering_left: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_buffering_stats(
        query: *mut GstQuery,
        mode: *mut GstBufferingMode,
        avg_in: *mut gint,
        avg_out: *mut gint,
        buffering_left: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_set_buffering_range(
        query: *mut GstQuery,
        format: GstFormat,
        start: gint64,
        stop: gint64,
        estimated_total: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_buffering_range(
        query: *mut GstQuery,
        format: *mut GstFormat,
        start: *mut gint64,
        stop: *mut gint64,
        estimated_total: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_query_add_buffering_range(
        query: *mut GstQuery,
        start: gint64,
        stop: gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_query_get_n_buffering_ranges(query: *mut GstQuery) -> guint;
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_buffering_range(
        query: *mut GstQuery,
        index: guint,
        start: *mut gint64,
        stop: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_query_new_uri() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_parse_uri(query: *mut GstQuery, uri: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn gst_query_set_uri(query: *mut GstQuery, uri: *const gchar);
}
unsafe extern "C" {
    pub fn gst_query_parse_uri_redirection(query: *mut GstQuery, uri: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn gst_query_set_uri_redirection(query: *mut GstQuery, uri: *const gchar);
}
unsafe extern "C" {
    pub fn gst_query_parse_uri_redirection_permanent(
        query: *mut GstQuery,
        permanent: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_query_set_uri_redirection_permanent(query: *mut GstQuery, permanent: gboolean);
}
unsafe extern "C" {
    pub fn gst_query_new_allocation(caps: *mut GstCaps, need_pool: gboolean) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_parse_allocation(
        query: *mut GstQuery,
        caps: *mut *mut GstCaps,
        need_pool: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_query_add_allocation_pool(
        query: *mut GstQuery,
        pool: *mut GstBufferPool,
        size: guint,
        min_buffers: guint,
        max_buffers: guint,
    );
}
unsafe extern "C" {
    pub fn gst_query_get_n_allocation_pools(query: *mut GstQuery) -> guint;
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_allocation_pool(
        query: *mut GstQuery,
        index: guint,
        pool: *mut *mut GstBufferPool,
        size: *mut guint,
        min_buffers: *mut guint,
        max_buffers: *mut guint,
    );
}
unsafe extern "C" {
    pub fn gst_query_set_nth_allocation_pool(
        query: *mut GstQuery,
        index: guint,
        pool: *mut GstBufferPool,
        size: guint,
        min_buffers: guint,
        max_buffers: guint,
    );
}
unsafe extern "C" {
    pub fn gst_query_remove_nth_allocation_pool(query: *mut GstQuery, index: guint);
}
unsafe extern "C" {
    pub fn gst_query_add_allocation_param(
        query: *mut GstQuery,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_query_get_n_allocation_params(query: *mut GstQuery) -> guint;
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_allocation_param(
        query: *mut GstQuery,
        index: guint,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_query_set_nth_allocation_param(
        query: *mut GstQuery,
        index: guint,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_query_remove_nth_allocation_param(query: *mut GstQuery, index: guint);
}
unsafe extern "C" {
    pub fn gst_query_add_allocation_meta(
        query: *mut GstQuery,
        api: GType,
        params: *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_query_get_n_allocation_metas(query: *mut GstQuery) -> guint;
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_allocation_meta(
        query: *mut GstQuery,
        index: guint,
        params: *mut *const GstStructure,
    ) -> GType;
}
unsafe extern "C" {
    pub fn gst_query_remove_nth_allocation_meta(query: *mut GstQuery, index: guint);
}
unsafe extern "C" {
    pub fn gst_query_find_allocation_meta(
        query: *mut GstQuery,
        api: GType,
        index: *mut guint,
    ) -> gboolean;
}
pub const GstSchedulingFlags_GST_SCHEDULING_FLAG_SEEKABLE: GstSchedulingFlags = 1;
pub const GstSchedulingFlags_GST_SCHEDULING_FLAG_SEQUENTIAL: GstSchedulingFlags = 2;
pub const GstSchedulingFlags_GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: GstSchedulingFlags = 4;
#[doc = " GstSchedulingFlags:\n @GST_SCHEDULING_FLAG_SEEKABLE: if seeking is possible\n @GST_SCHEDULING_FLAG_SEQUENTIAL: if sequential access is recommended\n @GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: if bandwidth is limited and buffering possible (since 1.2)\n\n The different scheduling flags."]
pub type GstSchedulingFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_query_new_scheduling() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_scheduling(
        query: *mut GstQuery,
        flags: GstSchedulingFlags,
        minsize: gint,
        maxsize: gint,
        align: gint,
    );
}
unsafe extern "C" {
    pub fn gst_query_parse_scheduling(
        query: *mut GstQuery,
        flags: *mut GstSchedulingFlags,
        minsize: *mut gint,
        maxsize: *mut gint,
        align: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_query_add_scheduling_mode(query: *mut GstQuery, mode: GstPadMode);
}
unsafe extern "C" {
    pub fn gst_query_get_n_scheduling_modes(query: *mut GstQuery) -> guint;
}
unsafe extern "C" {
    pub fn gst_query_parse_nth_scheduling_mode(query: *mut GstQuery, index: guint) -> GstPadMode;
}
unsafe extern "C" {
    pub fn gst_query_has_scheduling_mode(query: *mut GstQuery, mode: GstPadMode) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_query_has_scheduling_mode_with_flags(
        query: *mut GstQuery,
        mode: GstPadMode,
        flags: GstSchedulingFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_query_new_accept_caps(caps: *mut GstCaps) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_parse_accept_caps(query: *mut GstQuery, caps: *mut *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_query_set_accept_caps_result(query: *mut GstQuery, result: gboolean);
}
unsafe extern "C" {
    pub fn gst_query_parse_accept_caps_result(query: *mut GstQuery, result: *mut gboolean);
}
unsafe extern "C" {
    pub fn gst_query_new_caps(filter: *mut GstCaps) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_parse_caps(query: *mut GstQuery, filter: *mut *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_query_set_caps_result(query: *mut GstQuery, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_query_parse_caps_result(query: *mut GstQuery, caps: *mut *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_query_new_drain() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_new_context(context_type: *const gchar) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_parse_context_type(
        query: *mut GstQuery,
        context_type: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_query_set_context(query: *mut GstQuery, context: *mut GstContext);
}
unsafe extern "C" {
    pub fn gst_query_parse_context(query: *mut GstQuery, context: *mut *mut GstContext);
}
unsafe extern "C" {
    pub fn gst_query_new_bitrate() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_query_set_bitrate(query: *mut GstQuery, nominal_bitrate: guint);
}
unsafe extern "C" {
    pub fn gst_query_parse_bitrate(query: *mut GstQuery, nominal_bitrate: *mut guint);
}
pub type GstQuery_autoptr = *mut GstQuery;
pub type GstQuery_listautoptr = *mut GList;
pub type GstQuery_slistautoptr = *mut GSList;
pub type GstQuery_queueautoptr = *mut GQueue;
#[doc = " GstDevice:\n @parent: The parent #GstObject structure.\n\n A device object.\n\n Since: 1.4"]
pub type GstDevice = _GstDevice;
#[doc = " GstDeviceClass:\n @parent_class: The parent #GstObjectClass structure.\n @create_element: Creates the fully configured element to access this device.\n  Subclasses need to override this and return a new element.\n @reconfigure_element: This only needs to be implemented by subclasses if the\n  element can be reconfigured to use a different device. See the documentation\n  for gst_device_reconfigure_element().\n\n The class structure for a #GstDevice object.\n\n Since: 1.4"]
pub type GstDeviceClass = _GstDeviceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDevicePrivate {
    _unused: [u8; 0],
}
pub type GstDevicePrivate = _GstDevicePrivate;
#[doc = " GstDevice:\n @parent: The parent #GstObject structure.\n\n A device object.\n\n Since: 1.4"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstDevice {
    pub parent: GstObject,
    pub priv_: *mut GstDevicePrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDevice"][::std::mem::size_of::<_GstDevice>() - 128usize];
    ["Alignment of _GstDevice"][::std::mem::align_of::<_GstDevice>() - 8usize];
    ["Offset of field: _GstDevice::parent"][::std::mem::offset_of!(_GstDevice, parent) - 0usize];
    ["Offset of field: _GstDevice::priv_"][::std::mem::offset_of!(_GstDevice, priv_) - 88usize];
    ["Offset of field: _GstDevice::_gst_reserved"]
        [::std::mem::offset_of!(_GstDevice, _gst_reserved) - 96usize];
};
#[doc = " GstDeviceClass:\n @parent_class: The parent #GstObjectClass structure.\n @create_element: Creates the fully configured element to access this device.\n  Subclasses need to override this and return a new element.\n @reconfigure_element: This only needs to be implemented by subclasses if the\n  element can be reconfigured to use a different device. See the documentation\n  for gst_device_reconfigure_element().\n\n The class structure for a #GstDevice object.\n\n Since: 1.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceClass {
    pub parent_class: GstObjectClass,
    pub create_element: ::std::option::Option<
        unsafe extern "C" fn(device: *mut GstDevice, name: *const gchar) -> *mut GstElement,
    >,
    pub reconfigure_element: ::std::option::Option<
        unsafe extern "C" fn(device: *mut GstDevice, element: *mut GstElement) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDeviceClass"][::std::mem::size_of::<_GstDeviceClass>() - 232usize];
    ["Alignment of _GstDeviceClass"][::std::mem::align_of::<_GstDeviceClass>() - 8usize];
    ["Offset of field: _GstDeviceClass::parent_class"]
        [::std::mem::offset_of!(_GstDeviceClass, parent_class) - 0usize];
    ["Offset of field: _GstDeviceClass::create_element"]
        [::std::mem::offset_of!(_GstDeviceClass, create_element) - 184usize];
    ["Offset of field: _GstDeviceClass::reconfigure_element"]
        [::std::mem::offset_of!(_GstDeviceClass, reconfigure_element) - 192usize];
    ["Offset of field: _GstDeviceClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstDeviceClass, _gst_reserved) - 200usize];
};
unsafe extern "C" {
    pub fn gst_device_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_device_create_element(device: *mut GstDevice, name: *const gchar)
    -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_device_get_caps(device: *mut GstDevice) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_device_get_display_name(device: *mut GstDevice) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_device_get_device_class(device: *mut GstDevice) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_device_get_properties(device: *mut GstDevice) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_device_reconfigure_element(
        device: *mut GstDevice,
        element: *mut GstElement,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_has_classesv(device: *mut GstDevice, classes: *mut *mut gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_has_classes(device: *mut GstDevice, classes: *const gchar) -> gboolean;
}
pub type GstDevice_autoptr = *mut GstDevice;
pub type GstDevice_listautoptr = *mut GList;
pub type GstDevice_slistautoptr = *mut GSList;
pub type GstDevice_queueautoptr = *mut GQueue;
pub const GstStreamType_GST_STREAM_TYPE_UNKNOWN: GstStreamType = 1;
pub const GstStreamType_GST_STREAM_TYPE_AUDIO: GstStreamType = 2;
pub const GstStreamType_GST_STREAM_TYPE_VIDEO: GstStreamType = 4;
pub const GstStreamType_GST_STREAM_TYPE_CONTAINER: GstStreamType = 8;
pub const GstStreamType_GST_STREAM_TYPE_TEXT: GstStreamType = 16;
#[doc = " GstStreamType:\n @GST_STREAM_TYPE_UNKNOWN: The stream is of unknown (unclassified) type.\n @GST_STREAM_TYPE_AUDIO: The stream is of audio data\n @GST_STREAM_TYPE_VIDEO: The stream carries video data\n @GST_STREAM_TYPE_CONTAINER: The stream is a muxed container type\n @GST_STREAM_TYPE_TEXT: The stream contains subtitle / subpicture data.\n\n #GstStreamType describes a high level classification set for\n flows of data in #GstStream objects.\n\n Note that this is a flag, and therefore users should not assume it\n will be a single value. Do not use the equality operator for checking\n whether a stream is of a certain type.\n\n Since: 1.10"]
pub type GstStreamType = ::std::os::raw::c_uint;
#[doc = " GstStream:\n @stream_id: The Stream Identifier for this #GstStream\n\n A high-level object representing a single stream. It might be backed, or\n not, by an actual flow of data in a pipeline (#GstPad).\n\n A #GstStream does not care about data changes (such as decoding, encoding,\n parsing,...) as long as the underlying data flow corresponds to the same\n high-level flow (ex: a certain audio track).\n\n A #GstStream contains all the information pertinent to a stream, such as\n stream-id, tags, caps, type, ...\n\n Elements can subclass a #GstStream for internal usage (to contain information\n pertinent to streams of data).\n\n Since: 1.10"]
pub type GstStream = _GstStream;
#[doc = " GstStreamClass:\n @parent_class: the parent class structure\n\n GstStream class structure"]
pub type GstStreamClass = _GstStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStreamPrivate {
    _unused: [u8; 0],
}
pub type GstStreamPrivate = _GstStreamPrivate;
#[doc = " GstStream:\n @stream_id: The Stream Identifier for this #GstStream\n\n A high-level object representing a single stream. It might be backed, or\n not, by an actual flow of data in a pipeline (#GstPad).\n\n A #GstStream does not care about data changes (such as decoding, encoding,\n parsing,...) as long as the underlying data flow corresponds to the same\n high-level flow (ex: a certain audio track).\n\n A #GstStream contains all the information pertinent to a stream, such as\n stream-id, tags, caps, type, ...\n\n Elements can subclass a #GstStream for internal usage (to contain information\n pertinent to streams of data).\n\n Since: 1.10"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstStream {
    pub object: GstObject,
    pub stream_id: *const gchar,
    pub priv_: *mut GstStreamPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStream"][::std::mem::size_of::<_GstStream>() - 136usize];
    ["Alignment of _GstStream"][::std::mem::align_of::<_GstStream>() - 8usize];
    ["Offset of field: _GstStream::object"][::std::mem::offset_of!(_GstStream, object) - 0usize];
    ["Offset of field: _GstStream::stream_id"]
        [::std::mem::offset_of!(_GstStream, stream_id) - 88usize];
    ["Offset of field: _GstStream::priv_"][::std::mem::offset_of!(_GstStream, priv_) - 96usize];
    ["Offset of field: _GstStream::_gst_reserved"]
        [::std::mem::offset_of!(_GstStream, _gst_reserved) - 104usize];
};
#[doc = " GstStreamClass:\n @parent_class: the parent class structure\n\n GstStream class structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStreamClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStreamClass"][::std::mem::size_of::<_GstStreamClass>() - 216usize];
    ["Alignment of _GstStreamClass"][::std::mem::align_of::<_GstStreamClass>() - 8usize];
    ["Offset of field: _GstStreamClass::parent_class"]
        [::std::mem::offset_of!(_GstStreamClass, parent_class) - 0usize];
    ["Offset of field: _GstStreamClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstStreamClass, _gst_reserved) - 184usize];
};
unsafe extern "C" {
    pub fn gst_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_new(
        stream_id: *const gchar,
        caps: *mut GstCaps,
        type_: GstStreamType,
        flags: GstStreamFlags,
    ) -> *mut GstStream;
}
unsafe extern "C" {
    pub fn gst_stream_get_stream_id(stream: *mut GstStream) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_stream_set_stream_flags(stream: *mut GstStream, flags: GstStreamFlags);
}
unsafe extern "C" {
    pub fn gst_stream_get_stream_flags(stream: *mut GstStream) -> GstStreamFlags;
}
unsafe extern "C" {
    pub fn gst_stream_set_stream_type(stream: *mut GstStream, stream_type: GstStreamType);
}
unsafe extern "C" {
    pub fn gst_stream_get_stream_type(stream: *mut GstStream) -> GstStreamType;
}
unsafe extern "C" {
    pub fn gst_stream_set_tags(stream: *mut GstStream, tags: *mut GstTagList);
}
unsafe extern "C" {
    pub fn gst_stream_get_tags(stream: *mut GstStream) -> *mut GstTagList;
}
unsafe extern "C" {
    pub fn gst_stream_set_caps(stream: *mut GstStream, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_stream_get_caps(stream: *mut GstStream) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_stream_type_get_name(stype: GstStreamType) -> *const gchar;
}
pub type GstStream_autoptr = *mut GstStream;
pub type GstStream_listautoptr = *mut GList;
pub type GstStream_slistautoptr = *mut GSList;
pub type GstStream_queueautoptr = *mut GQueue;
#[doc = " GstStreamCollection:\n\n A collection of #GstStream that are available.\n\n A #GstStreamCollection will be provided by elements that can make those\n streams available. Applications can use the collection to show the user\n what streams are available by using %gst_stream_collection_get_stream()\n\n Once posted, a #GstStreamCollection is immutable. Updates are made by sending\n a new #GstStreamCollection message, which may or may not share some of\n the #GstStream objects from the collection it replaces. The receiver can check\n the sender of a stream collection message to know which collection is\n obsoleted.\n\n Several elements in a pipeline can provide #GstStreamCollection.\n\n Applications can activate streams from a collection by using the\n #GST_EVENT_SELECT_STREAMS event on a pipeline, bin or element.\n\n Since: 1.10"]
pub type GstStreamCollection = _GstStreamCollection;
#[doc = " GstStreamCollectionClass:\n @parent_class: the parent class structure\n @stream_notify: default signal handler for the stream-notify signal\n\n GstStreamCollection class structure"]
pub type GstStreamCollectionClass = _GstStreamCollectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStreamCollectionPrivate {
    _unused: [u8; 0],
}
pub type GstStreamCollectionPrivate = _GstStreamCollectionPrivate;
#[doc = " GstStreamCollection:\n\n A collection of #GstStream that are available.\n\n A #GstStreamCollection will be provided by elements that can make those\n streams available. Applications can use the collection to show the user\n what streams are available by using %gst_stream_collection_get_stream()\n\n Once posted, a #GstStreamCollection is immutable. Updates are made by sending\n a new #GstStreamCollection message, which may or may not share some of\n the #GstStream objects from the collection it replaces. The receiver can check\n the sender of a stream collection message to know which collection is\n obsoleted.\n\n Several elements in a pipeline can provide #GstStreamCollection.\n\n Applications can activate streams from a collection by using the\n #GST_EVENT_SELECT_STREAMS event on a pipeline, bin or element.\n\n Since: 1.10"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstStreamCollection {
    pub object: GstObject,
    pub upstream_id: *mut gchar,
    pub priv_: *mut GstStreamCollectionPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStreamCollection"][::std::mem::size_of::<_GstStreamCollection>() - 136usize];
    ["Alignment of _GstStreamCollection"][::std::mem::align_of::<_GstStreamCollection>() - 8usize];
    ["Offset of field: _GstStreamCollection::object"]
        [::std::mem::offset_of!(_GstStreamCollection, object) - 0usize];
    ["Offset of field: _GstStreamCollection::upstream_id"]
        [::std::mem::offset_of!(_GstStreamCollection, upstream_id) - 88usize];
    ["Offset of field: _GstStreamCollection::priv_"]
        [::std::mem::offset_of!(_GstStreamCollection, priv_) - 96usize];
    ["Offset of field: _GstStreamCollection::_gst_reserved"]
        [::std::mem::offset_of!(_GstStreamCollection, _gst_reserved) - 104usize];
};
#[doc = " GstStreamCollectionClass:\n @parent_class: the parent class structure\n @stream_notify: default signal handler for the stream-notify signal\n\n GstStreamCollection class structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStreamCollectionClass {
    pub parent_class: GstObjectClass,
    pub stream_notify: ::std::option::Option<
        unsafe extern "C" fn(
            collection: *mut GstStreamCollection,
            stream: *mut GstStream,
            pspec: *mut GParamSpec,
        ),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStreamCollectionClass"]
        [::std::mem::size_of::<_GstStreamCollectionClass>() - 224usize];
    ["Alignment of _GstStreamCollectionClass"]
        [::std::mem::align_of::<_GstStreamCollectionClass>() - 8usize];
    ["Offset of field: _GstStreamCollectionClass::parent_class"]
        [::std::mem::offset_of!(_GstStreamCollectionClass, parent_class) - 0usize];
    ["Offset of field: _GstStreamCollectionClass::stream_notify"]
        [::std::mem::offset_of!(_GstStreamCollectionClass, stream_notify) - 184usize];
    ["Offset of field: _GstStreamCollectionClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstStreamCollectionClass, _gst_reserved) - 192usize];
};
unsafe extern "C" {
    pub fn gst_stream_collection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_stream_collection_new(upstream_id: *const gchar) -> *mut GstStreamCollection;
}
unsafe extern "C" {
    pub fn gst_stream_collection_get_upstream_id(
        collection: *mut GstStreamCollection,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_stream_collection_get_size(collection: *mut GstStreamCollection) -> guint;
}
unsafe extern "C" {
    pub fn gst_stream_collection_get_stream(
        collection: *mut GstStreamCollection,
        index: guint,
    ) -> *mut GstStream;
}
unsafe extern "C" {
    pub fn gst_stream_collection_add_stream(
        collection: *mut GstStreamCollection,
        stream: *mut GstStream,
    ) -> gboolean;
}
pub type GstStreamCollection_autoptr = *mut GstStreamCollection;
pub type GstStreamCollection_listautoptr = *mut GList;
pub type GstStreamCollection_slistautoptr = *mut GSList;
pub type GstStreamCollection_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_message_type: GType;
}
pub const GstStructureChangeType_GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: GstStructureChangeType = 0;
pub const GstStructureChangeType_GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: GstStructureChangeType = 1;
#[doc = " GstStructureChangeType:\n @GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: Pad linking is starting or done.\n @GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: Pad unlinking is starting or done.\n\n The type of a %GST_MESSAGE_STRUCTURE_CHANGE."]
pub type GstStructureChangeType = ::std::os::raw::c_uint;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_CREATE: GstStreamStatusType = 0;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_ENTER: GstStreamStatusType = 1;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_LEAVE: GstStreamStatusType = 2;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_DESTROY: GstStreamStatusType = 3;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_START: GstStreamStatusType = 8;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_PAUSE: GstStreamStatusType = 9;
pub const GstStreamStatusType_GST_STREAM_STATUS_TYPE_STOP: GstStreamStatusType = 10;
#[doc = " GstStreamStatusType:\n @GST_STREAM_STATUS_TYPE_CREATE: A new thread need to be created.\n @GST_STREAM_STATUS_TYPE_ENTER: a thread entered its loop function\n @GST_STREAM_STATUS_TYPE_LEAVE: a thread left its loop function\n @GST_STREAM_STATUS_TYPE_DESTROY: a thread is destroyed\n @GST_STREAM_STATUS_TYPE_START: a thread is started\n @GST_STREAM_STATUS_TYPE_PAUSE: a thread is paused\n @GST_STREAM_STATUS_TYPE_STOP: a thread is stopped\n\n The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the\n application of new streaming threads and their status."]
pub type GstStreamStatusType = ::std::os::raw::c_uint;
pub const GstProgressType_GST_PROGRESS_TYPE_START: GstProgressType = 0;
pub const GstProgressType_GST_PROGRESS_TYPE_CONTINUE: GstProgressType = 1;
pub const GstProgressType_GST_PROGRESS_TYPE_COMPLETE: GstProgressType = 2;
pub const GstProgressType_GST_PROGRESS_TYPE_CANCELED: GstProgressType = 3;
pub const GstProgressType_GST_PROGRESS_TYPE_ERROR: GstProgressType = 4;
#[doc = " GstProgressType:\n @GST_PROGRESS_TYPE_START: A new task started.\n @GST_PROGRESS_TYPE_CONTINUE: A task completed and a new one continues.\n @GST_PROGRESS_TYPE_COMPLETE: A task completed.\n @GST_PROGRESS_TYPE_CANCELED: A task was canceled.\n @GST_PROGRESS_TYPE_ERROR: A task caused an error. An error message is also\n          posted on the bus.\n\n The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the\n application of the status of asynchronous tasks."]
pub type GstProgressType = ::std::os::raw::c_uint;
#[doc = " GstMessage:\n @mini_object: the parent structure\n @type: the #GstMessageType of the message\n @timestamp: the timestamp of the message\n @src: the src of the message\n @seqnum: the sequence number of the message\n\n A #GstMessage."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstMessage {
    pub mini_object: GstMiniObject,
    pub type_: GstMessageType,
    pub timestamp: guint64,
    pub src: *mut GstObject,
    pub seqnum: guint32,
    pub lock: GMutex,
    pub cond: GCond,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstMessage"][::std::mem::size_of::<_GstMessage>() - 120usize];
    ["Alignment of _GstMessage"][::std::mem::align_of::<_GstMessage>() - 8usize];
    ["Offset of field: _GstMessage::mini_object"]
        [::std::mem::offset_of!(_GstMessage, mini_object) - 0usize];
    ["Offset of field: _GstMessage::type_"][::std::mem::offset_of!(_GstMessage, type_) - 64usize];
    ["Offset of field: _GstMessage::timestamp"]
        [::std::mem::offset_of!(_GstMessage, timestamp) - 72usize];
    ["Offset of field: _GstMessage::src"][::std::mem::offset_of!(_GstMessage, src) - 80usize];
    ["Offset of field: _GstMessage::seqnum"][::std::mem::offset_of!(_GstMessage, seqnum) - 88usize];
    ["Offset of field: _GstMessage::lock"][::std::mem::offset_of!(_GstMessage, lock) - 96usize];
    ["Offset of field: _GstMessage::cond"][::std::mem::offset_of!(_GstMessage, cond) - 104usize];
};
unsafe extern "C" {
    pub fn gst_message_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_message_type_get_name(type_: GstMessageType) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_message_type_to_quark(type_: GstMessageType) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_message_new_custom(
        type_: GstMessageType,
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_get_structure(message: *mut GstMessage) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_message_writable_structure(message: *mut GstMessage) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_message_has_name(message: *mut GstMessage, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_message_get_seqnum(message: *mut GstMessage) -> guint32;
}
unsafe extern "C" {
    pub fn gst_message_set_seqnum(message: *mut GstMessage, seqnum: guint32);
}
unsafe extern "C" {
    pub fn gst_message_new_eos(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_error(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_error_with_details(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_error(
        message: *mut GstMessage,
        gerror: *mut *mut GError,
        debug: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_error_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_warning(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_warning_with_details(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_warning(
        message: *mut GstMessage,
        gerror: *mut *mut GError,
        debug: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_warning_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_info(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_info_with_details(
        src: *mut GstObject,
        error: *mut GError,
        debug: *const gchar,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_info(
        message: *mut GstMessage,
        gerror: *mut *mut GError,
        debug: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_info_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_tag(src: *mut GstObject, tag_list: *mut GstTagList) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_tag(message: *mut GstMessage, tag_list: *mut *mut GstTagList);
}
unsafe extern "C" {
    pub fn gst_message_new_buffering(src: *mut GstObject, percent: gint) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_buffering(message: *mut GstMessage, percent: *mut gint);
}
unsafe extern "C" {
    pub fn gst_message_set_buffering_stats(
        message: *mut GstMessage,
        mode: GstBufferingMode,
        avg_in: gint,
        avg_out: gint,
        buffering_left: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_buffering_stats(
        message: *mut GstMessage,
        mode: *mut GstBufferingMode,
        avg_in: *mut gint,
        avg_out: *mut gint,
        buffering_left: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_state_changed(
        src: *mut GstObject,
        oldstate: GstState,
        newstate: GstState,
        pending: GstState,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_state_changed(
        message: *mut GstMessage,
        oldstate: *mut GstState,
        newstate: *mut GstState,
        pending: *mut GstState,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_state_dirty(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_step_done(
        src: *mut GstObject,
        format: GstFormat,
        amount: guint64,
        rate: gdouble,
        flush: gboolean,
        intermediate: gboolean,
        duration: guint64,
        eos: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_step_done(
        message: *mut GstMessage,
        format: *mut GstFormat,
        amount: *mut guint64,
        rate: *mut gdouble,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
        duration: *mut guint64,
        eos: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_clock_provide(
        src: *mut GstObject,
        clock: *mut GstClock,
        ready: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_clock_provide(
        message: *mut GstMessage,
        clock: *mut *mut GstClock,
        ready: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_clock_lost(src: *mut GstObject, clock: *mut GstClock)
    -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_clock_lost(message: *mut GstMessage, clock: *mut *mut GstClock);
}
unsafe extern "C" {
    pub fn gst_message_new_new_clock(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_new_clock(message: *mut GstMessage, clock: *mut *mut GstClock);
}
unsafe extern "C" {
    pub fn gst_message_new_application(
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_element(
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_segment_start(
        src: *mut GstObject,
        format: GstFormat,
        position: gint64,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_segment_start(
        message: *mut GstMessage,
        format: *mut GstFormat,
        position: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_segment_done(
        src: *mut GstObject,
        format: GstFormat,
        position: gint64,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_segment_done(
        message: *mut GstMessage,
        format: *mut GstFormat,
        position: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_duration_changed(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_latency(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_async_start(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_new_async_done(
        src: *mut GstObject,
        running_time: GstClockTime,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_async_done(message: *mut GstMessage, running_time: *mut GstClockTime);
}
unsafe extern "C" {
    pub fn gst_message_new_structure_change(
        src: *mut GstObject,
        type_: GstStructureChangeType,
        owner: *mut GstElement,
        busy: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_structure_change(
        message: *mut GstMessage,
        type_: *mut GstStructureChangeType,
        owner: *mut *mut GstElement,
        busy: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_stream_status(
        src: *mut GstObject,
        type_: GstStreamStatusType,
        owner: *mut GstElement,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_stream_status(
        message: *mut GstMessage,
        type_: *mut GstStreamStatusType,
        owner: *mut *mut GstElement,
    );
}
unsafe extern "C" {
    pub fn gst_message_set_stream_status_object(message: *mut GstMessage, object: *const GValue);
}
unsafe extern "C" {
    pub fn gst_message_get_stream_status_object(message: *mut GstMessage) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_message_new_request_state(src: *mut GstObject, state: GstState) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_request_state(message: *mut GstMessage, state: *mut GstState);
}
unsafe extern "C" {
    pub fn gst_message_new_step_start(
        src: *mut GstObject,
        active: gboolean,
        format: GstFormat,
        amount: guint64,
        rate: gdouble,
        flush: gboolean,
        intermediate: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_step_start(
        message: *mut GstMessage,
        active: *mut gboolean,
        format: *mut GstFormat,
        amount: *mut guint64,
        rate: *mut gdouble,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_qos(
        src: *mut GstObject,
        live: gboolean,
        running_time: guint64,
        stream_time: guint64,
        timestamp: guint64,
        duration: guint64,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_set_qos_values(
        message: *mut GstMessage,
        jitter: gint64,
        proportion: gdouble,
        quality: gint,
    );
}
unsafe extern "C" {
    pub fn gst_message_set_qos_stats(
        message: *mut GstMessage,
        format: GstFormat,
        processed: guint64,
        dropped: guint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_qos(
        message: *mut GstMessage,
        live: *mut gboolean,
        running_time: *mut guint64,
        stream_time: *mut guint64,
        timestamp: *mut guint64,
        duration: *mut guint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_qos_values(
        message: *mut GstMessage,
        jitter: *mut gint64,
        proportion: *mut gdouble,
        quality: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_qos_stats(
        message: *mut GstMessage,
        format: *mut GstFormat,
        processed: *mut guint64,
        dropped: *mut guint64,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_progress(
        src: *mut GstObject,
        type_: GstProgressType,
        code: *const gchar,
        text: *const gchar,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_progress(
        message: *mut GstMessage,
        type_: *mut GstProgressType,
        code: *mut *mut gchar,
        text: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_toc(
        src: *mut GstObject,
        toc: *mut GstToc,
        updated: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_toc(
        message: *mut GstMessage,
        toc: *mut *mut GstToc,
        updated: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_reset_time(
        src: *mut GstObject,
        running_time: GstClockTime,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_reset_time(message: *mut GstMessage, running_time: *mut GstClockTime);
}
unsafe extern "C" {
    pub fn gst_message_new_stream_start(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_set_group_id(message: *mut GstMessage, group_id: guint);
}
unsafe extern "C" {
    pub fn gst_message_parse_group_id(message: *mut GstMessage, group_id: *mut guint) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_message_new_need_context(
        src: *mut GstObject,
        context_type: *const gchar,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_context_type(
        message: *mut GstMessage,
        context_type: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_message_new_have_context(
        src: *mut GstObject,
        context: *mut GstContext,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_have_context(message: *mut GstMessage, context: *mut *mut GstContext);
}
unsafe extern "C" {
    pub fn gst_message_new_device_added(
        src: *mut GstObject,
        device: *mut GstDevice,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_device_added(message: *mut GstMessage, device: *mut *mut GstDevice);
}
unsafe extern "C" {
    pub fn gst_message_new_device_removed(
        src: *mut GstObject,
        device: *mut GstDevice,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_device_removed(message: *mut GstMessage, device: *mut *mut GstDevice);
}
unsafe extern "C" {
    pub fn gst_message_new_device_changed(
        src: *mut GstObject,
        device: *mut GstDevice,
        changed_device: *mut GstDevice,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_device_changed(
        message: *mut GstMessage,
        device: *mut *mut GstDevice,
        changed_device: *mut *mut GstDevice,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_property_notify(
        src: *mut GstObject,
        property_name: *const gchar,
        val: *mut GValue,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_property_notify(
        message: *mut GstMessage,
        object: *mut *mut GstObject,
        property_name: *mut *const gchar,
        property_value: *mut *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_stream_collection(
        src: *mut GstObject,
        collection: *mut GstStreamCollection,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_stream_collection(
        message: *mut GstMessage,
        collection: *mut *mut GstStreamCollection,
    );
}
unsafe extern "C" {
    pub fn gst_message_new_streams_selected(
        src: *mut GstObject,
        collection: *mut GstStreamCollection,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_streams_selected_add(message: *mut GstMessage, stream: *mut GstStream);
}
unsafe extern "C" {
    pub fn gst_message_parse_streams_selected(
        message: *mut GstMessage,
        collection: *mut *mut GstStreamCollection,
    );
}
unsafe extern "C" {
    pub fn gst_message_streams_selected_get_size(message: *mut GstMessage) -> guint;
}
unsafe extern "C" {
    pub fn gst_message_streams_selected_get_stream(
        message: *mut GstMessage,
        idx: guint,
    ) -> *mut GstStream;
}
unsafe extern "C" {
    pub fn gst_message_new_redirect(
        src: *mut GstObject,
        location: *const gchar,
        tag_list: *mut GstTagList,
        entry_struct: *const GstStructure,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_add_redirect_entry(
        message: *mut GstMessage,
        location: *const gchar,
        tag_list: *mut GstTagList,
        entry_struct: *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_message_parse_redirect_entry(
        message: *mut GstMessage,
        entry_index: gsize,
        location: *mut *const gchar,
        tag_list: *mut *mut GstTagList,
        entry_struct: *mut *const GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_message_get_num_redirect_entries(message: *mut GstMessage) -> gsize;
}
unsafe extern "C" {
    pub fn gst_message_new_instant_rate_request(
        src: *mut GstObject,
        rate_multiplier: gdouble,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_message_parse_instant_rate_request(
        message: *mut GstMessage,
        rate_multiplier: *mut gdouble,
    );
}
pub type GstMessage_autoptr = *mut GstMessage;
pub type GstMessage_listautoptr = *mut GList;
pub type GstMessage_slistautoptr = *mut GSList;
pub type GstMessage_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub static mut _gst_event_type: GType;
}
pub const GstQOSType_GST_QOS_TYPE_OVERFLOW: GstQOSType = 0;
pub const GstQOSType_GST_QOS_TYPE_UNDERFLOW: GstQOSType = 1;
pub const GstQOSType_GST_QOS_TYPE_THROTTLE: GstQOSType = 2;
#[doc = " GstQOSType:\n @GST_QOS_TYPE_OVERFLOW: The QoS event type that is produced when upstream\n    elements are producing data too quickly and the element can't keep up\n    processing the data. Upstream should reduce their production rate. This\n    type is also used when buffers arrive early or in time.\n @GST_QOS_TYPE_UNDERFLOW: The QoS event type that is produced when upstream\n    elements are producing data too slowly and need to speed up their\n    production rate.\n @GST_QOS_TYPE_THROTTLE: The QoS event type that is produced when the\n    application enabled throttling to limit the data rate.\n\n The different types of QoS events that can be given to the\n gst_event_new_qos() method."]
pub type GstQOSType = ::std::os::raw::c_uint;
pub const GstGapFlags_GST_GAP_FLAG_MISSING_DATA: GstGapFlags = 1;
#[doc = " GstGapFlags:\n @GST_GAP_FLAG_MISSING_DATA: The #GST_EVENT_GAP signals missing data,\n    for example because of packet loss.\n\n The different flags that can be set on #GST_EVENT_GAP events. See\n gst_event_set_gap_flags() for details.\n\n Since: 1.20"]
pub type GstGapFlags = ::std::os::raw::c_uint;
#[doc = " GstEvent:\n @mini_object: the parent structure\n @type: the #GstEventType of the event\n @timestamp: the timestamp of the event\n @seqnum: the sequence number of the event\n\n A #GstEvent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstEvent {
    pub mini_object: GstMiniObject,
    pub type_: GstEventType,
    pub timestamp: guint64,
    pub seqnum: guint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstEvent"][::std::mem::size_of::<_GstEvent>() - 88usize];
    ["Alignment of _GstEvent"][::std::mem::align_of::<_GstEvent>() - 8usize];
    ["Offset of field: _GstEvent::mini_object"]
        [::std::mem::offset_of!(_GstEvent, mini_object) - 0usize];
    ["Offset of field: _GstEvent::type_"][::std::mem::offset_of!(_GstEvent, type_) - 64usize];
    ["Offset of field: _GstEvent::timestamp"]
        [::std::mem::offset_of!(_GstEvent, timestamp) - 72usize];
    ["Offset of field: _GstEvent::seqnum"][::std::mem::offset_of!(_GstEvent, seqnum) - 80usize];
};
unsafe extern "C" {
    pub fn gst_event_type_get_name(type_: GstEventType) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_event_type_to_quark(type_: GstEventType) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_event_type_get_flags(type_: GstEventType) -> GstEventTypeFlags;
}
unsafe extern "C" {
    pub fn gst_event_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_event_new_custom(type_: GstEventType, structure: *mut GstStructure)
    -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_get_structure(event: *mut GstEvent) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_event_writable_structure(event: *mut GstEvent) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_event_has_name(event: *mut GstEvent, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_event_has_name_id(event: *mut GstEvent, name: GQuark) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_event_get_seqnum(event: *mut GstEvent) -> guint32;
}
unsafe extern "C" {
    pub fn gst_event_set_seqnum(event: *mut GstEvent, seqnum: guint32);
}
unsafe extern "C" {
    pub fn gst_event_get_running_time_offset(event: *mut GstEvent) -> gint64;
}
unsafe extern "C" {
    pub fn gst_event_set_running_time_offset(event: *mut GstEvent, offset: gint64);
}
unsafe extern "C" {
    pub fn gst_event_new_stream_start(stream_id: *const gchar) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_stream_start(event: *mut GstEvent, stream_id: *mut *const gchar);
}
unsafe extern "C" {
    pub fn gst_event_set_stream(event: *mut GstEvent, stream: *mut GstStream);
}
unsafe extern "C" {
    pub fn gst_event_parse_stream(event: *mut GstEvent, stream: *mut *mut GstStream);
}
unsafe extern "C" {
    pub fn gst_event_set_stream_flags(event: *mut GstEvent, flags: GstStreamFlags);
}
unsafe extern "C" {
    pub fn gst_event_parse_stream_flags(event: *mut GstEvent, flags: *mut GstStreamFlags);
}
unsafe extern "C" {
    pub fn gst_event_set_group_id(event: *mut GstEvent, group_id: guint);
}
unsafe extern "C" {
    pub fn gst_event_parse_group_id(event: *mut GstEvent, group_id: *mut guint) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_event_new_flush_start() -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_new_flush_stop(reset_time: gboolean) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_flush_stop(event: *mut GstEvent, reset_time: *mut gboolean);
}
unsafe extern "C" {
    pub fn gst_event_new_stream_collection(collection: *mut GstStreamCollection) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_stream_collection(
        event: *mut GstEvent,
        collection: *mut *mut GstStreamCollection,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_select_streams(streams: *mut GList) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_select_streams(event: *mut GstEvent, streams: *mut *mut GList);
}
unsafe extern "C" {
    pub fn gst_event_new_stream_group_done(group_id: guint) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_stream_group_done(event: *mut GstEvent, group_id: *mut guint);
}
unsafe extern "C" {
    pub fn gst_event_new_eos() -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_gap(
        event: *mut GstEvent,
        timestamp: *mut GstClockTime,
        duration: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_event_set_gap_flags(event: *mut GstEvent, flags: GstGapFlags);
}
unsafe extern "C" {
    pub fn gst_event_parse_gap_flags(event: *mut GstEvent, flags: *mut GstGapFlags);
}
unsafe extern "C" {
    pub fn gst_event_new_caps(caps: *mut GstCaps) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_caps(event: *mut GstEvent, caps: *mut *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_event_new_segment(segment: *const GstSegment) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_segment(event: *mut GstEvent, segment: *mut *const GstSegment);
}
unsafe extern "C" {
    pub fn gst_event_copy_segment(event: *mut GstEvent, segment: *mut GstSegment);
}
unsafe extern "C" {
    pub fn gst_event_new_tag(taglist: *mut GstTagList) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_tag(event: *mut GstEvent, taglist: *mut *mut GstTagList);
}
unsafe extern "C" {
    pub fn gst_event_new_toc(toc: *mut GstToc, updated: gboolean) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_toc(event: *mut GstEvent, toc: *mut *mut GstToc, updated: *mut gboolean);
}
unsafe extern "C" {
    pub fn gst_event_new_protection(
        system_id: *const gchar,
        data: *mut GstBuffer,
        origin: *const gchar,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_protection(
        event: *mut GstEvent,
        system_id: *mut *const gchar,
        data: *mut *mut GstBuffer,
        origin: *mut *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_buffer_size(
        format: GstFormat,
        minsize: gint64,
        maxsize: gint64,
        async_: gboolean,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_buffer_size(
        event: *mut GstEvent,
        format: *mut GstFormat,
        minsize: *mut gint64,
        maxsize: *mut gint64,
        async_: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_sink_message(name: *const gchar, msg: *mut GstMessage) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_sink_message(event: *mut GstEvent, msg: *mut *mut GstMessage);
}
unsafe extern "C" {
    pub fn gst_event_new_qos(
        type_: GstQOSType,
        proportion: gdouble,
        diff: GstClockTimeDiff,
        timestamp: GstClockTime,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_qos(
        event: *mut GstEvent,
        type_: *mut GstQOSType,
        proportion: *mut gdouble,
        diff: *mut GstClockTimeDiff,
        timestamp: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_seek(
        rate: gdouble,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: gint64,
        stop_type: GstSeekType,
        stop: gint64,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_seek(
        event: *mut GstEvent,
        rate: *mut gdouble,
        format: *mut GstFormat,
        flags: *mut GstSeekFlags,
        start_type: *mut GstSeekType,
        start: *mut gint64,
        stop_type: *mut GstSeekType,
        stop: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_event_set_seek_trickmode_interval(event: *mut GstEvent, interval: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_event_parse_seek_trickmode_interval(
        event: *mut GstEvent,
        interval: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_navigation(structure: *mut GstStructure) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_new_latency(latency: GstClockTime) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_latency(event: *mut GstEvent, latency: *mut GstClockTime);
}
unsafe extern "C" {
    pub fn gst_event_new_step(
        format: GstFormat,
        amount: guint64,
        rate: gdouble,
        flush: gboolean,
        intermediate: gboolean,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_step(
        event: *mut GstEvent,
        format: *mut GstFormat,
        amount: *mut guint64,
        rate: *mut gdouble,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_reconfigure() -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_new_toc_select(uid: *const gchar) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_toc_select(event: *mut GstEvent, uid: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn gst_event_new_segment_done(format: GstFormat, position: gint64) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_segment_done(
        event: *mut GstEvent,
        format: *mut GstFormat,
        position: *mut gint64,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_instant_rate_change(
        rate_multiplier: gdouble,
        new_flags: GstSegmentFlags,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_instant_rate_change(
        event: *mut GstEvent,
        rate_multiplier: *mut gdouble,
        new_flags: *mut GstSegmentFlags,
    );
}
unsafe extern "C" {
    pub fn gst_event_new_instant_rate_sync_time(
        rate_multiplier: gdouble,
        running_time: GstClockTime,
        upstream_running_time: GstClockTime,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_event_parse_instant_rate_sync_time(
        event: *mut GstEvent,
        rate_multiplier: *mut gdouble,
        running_time: *mut GstClockTime,
        upstream_running_time: *mut GstClockTime,
    );
}
pub type GstEvent_autoptr = *mut GstEvent;
pub type GstEvent_listautoptr = *mut GList;
pub type GstEvent_slistautoptr = *mut GSList;
pub type GstEvent_queueautoptr = *mut GQueue;
#[doc = " GstTaskPool:\n\n The #GstTaskPool object."]
pub type GstTaskPool = _GstTaskPool;
#[doc = " GstTaskPoolClass:\n @parent_class: the parent class structure\n @prepare: prepare the threadpool\n @cleanup: make sure all threads are stopped\n @push: start a new thread\n @join: join a thread\n\n The #GstTaskPoolClass object."]
pub type GstTaskPoolClass = _GstTaskPoolClass;
#[doc = " GstTaskPoolFunction:\n @user_data: user data for the task function\n\n Task function, see gst_task_pool_push()."]
pub type GstTaskPoolFunction =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = " GstTaskPool:\n\n The #GstTaskPool object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstTaskPool {
    pub object: GstObject,
    pub pool: *mut GThreadPool,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTaskPool"][::std::mem::size_of::<_GstTaskPool>() - 128usize];
    ["Alignment of _GstTaskPool"][::std::mem::align_of::<_GstTaskPool>() - 8usize];
    ["Offset of field: _GstTaskPool::object"]
        [::std::mem::offset_of!(_GstTaskPool, object) - 0usize];
    ["Offset of field: _GstTaskPool::pool"][::std::mem::offset_of!(_GstTaskPool, pool) - 88usize];
    ["Offset of field: _GstTaskPool::_gst_reserved"]
        [::std::mem::offset_of!(_GstTaskPool, _gst_reserved) - 96usize];
};
#[doc = " GstTaskPoolClass:\n @parent_class: the parent class structure\n @prepare: prepare the threadpool\n @cleanup: make sure all threads are stopped\n @push: start a new thread\n @join: join a thread\n\n The #GstTaskPoolClass object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTaskPoolClass {
    pub parent_class: GstObjectClass,
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut GstTaskPool, error: *mut *mut GError),
    >,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstTaskPool)>,
    pub push: ::std::option::Option<
        unsafe extern "C" fn(
            pool: *mut GstTaskPool,
            func: GstTaskPoolFunction,
            user_data: gpointer,
            error: *mut *mut GError,
        ) -> gpointer,
    >,
    pub join: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstTaskPool, id: gpointer)>,
    #[doc = " GstTaskPoolClass::dispose_handle:\n @pool: a #GstTaskPool\n @id: (transfer full): the handle to dispose of\n\n free / unref the handle returned in GstTaskPoolClass::push.\n\n Since: 1.20"]
    pub dispose_handle:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut GstTaskPool, id: gpointer)>,
    pub _gst_reserved: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTaskPoolClass"][::std::mem::size_of::<_GstTaskPoolClass>() - 248usize];
    ["Alignment of _GstTaskPoolClass"][::std::mem::align_of::<_GstTaskPoolClass>() - 8usize];
    ["Offset of field: _GstTaskPoolClass::parent_class"]
        [::std::mem::offset_of!(_GstTaskPoolClass, parent_class) - 0usize];
    ["Offset of field: _GstTaskPoolClass::prepare"]
        [::std::mem::offset_of!(_GstTaskPoolClass, prepare) - 184usize];
    ["Offset of field: _GstTaskPoolClass::cleanup"]
        [::std::mem::offset_of!(_GstTaskPoolClass, cleanup) - 192usize];
    ["Offset of field: _GstTaskPoolClass::push"]
        [::std::mem::offset_of!(_GstTaskPoolClass, push) - 200usize];
    ["Offset of field: _GstTaskPoolClass::join"]
        [::std::mem::offset_of!(_GstTaskPoolClass, join) - 208usize];
    ["Offset of field: _GstTaskPoolClass::dispose_handle"]
        [::std::mem::offset_of!(_GstTaskPoolClass, dispose_handle) - 216usize];
    ["Offset of field: _GstTaskPoolClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstTaskPoolClass, _gst_reserved) - 224usize];
};
unsafe extern "C" {
    pub fn gst_task_pool_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_task_pool_new() -> *mut GstTaskPool;
}
unsafe extern "C" {
    pub fn gst_task_pool_prepare(pool: *mut GstTaskPool, error: *mut *mut GError);
}
unsafe extern "C" {
    pub fn gst_task_pool_push(
        pool: *mut GstTaskPool,
        func: GstTaskPoolFunction,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_task_pool_join(pool: *mut GstTaskPool, id: gpointer);
}
unsafe extern "C" {
    pub fn gst_task_pool_dispose_handle(pool: *mut GstTaskPool, id: gpointer);
}
unsafe extern "C" {
    pub fn gst_task_pool_cleanup(pool: *mut GstTaskPool);
}
pub type GstTaskPool_autoptr = *mut GstTaskPool;
pub type GstTaskPool_listautoptr = *mut GList;
pub type GstTaskPool_slistautoptr = *mut GSList;
pub type GstTaskPool_queueautoptr = *mut GQueue;
#[doc = " GstSharedTaskPool:\n\n The #GstSharedTaskPool object.\n\n since: 1.20"]
pub type GstSharedTaskPool = _GstSharedTaskPool;
#[doc = " GstSharedTaskPoolClass:\n\n The #GstSharedTaskPoolClass object.\n\n Since: 1.20"]
pub type GstSharedTaskPoolClass = _GstSharedTaskPoolClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSharedTaskPoolPrivate {
    _unused: [u8; 0],
}
pub type GstSharedTaskPoolPrivate = _GstSharedTaskPoolPrivate;
#[doc = " GstSharedTaskPool:\n\n The #GstSharedTaskPool object.\n\n since: 1.20"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstSharedTaskPool {
    pub parent: GstTaskPool,
    pub priv_: *mut GstSharedTaskPoolPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstSharedTaskPool"][::std::mem::size_of::<_GstSharedTaskPool>() - 168usize];
    ["Alignment of _GstSharedTaskPool"][::std::mem::align_of::<_GstSharedTaskPool>() - 8usize];
    ["Offset of field: _GstSharedTaskPool::parent"]
        [::std::mem::offset_of!(_GstSharedTaskPool, parent) - 0usize];
    ["Offset of field: _GstSharedTaskPool::priv_"]
        [::std::mem::offset_of!(_GstSharedTaskPool, priv_) - 128usize];
    ["Offset of field: _GstSharedTaskPool::_gst_reserved"]
        [::std::mem::offset_of!(_GstSharedTaskPool, _gst_reserved) - 136usize];
};
#[doc = " GstSharedTaskPoolClass:\n\n The #GstSharedTaskPoolClass object.\n\n Since: 1.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSharedTaskPoolClass {
    pub parent_class: GstTaskPoolClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstSharedTaskPoolClass"]
        [::std::mem::size_of::<_GstSharedTaskPoolClass>() - 280usize];
    ["Alignment of _GstSharedTaskPoolClass"]
        [::std::mem::align_of::<_GstSharedTaskPoolClass>() - 8usize];
    ["Offset of field: _GstSharedTaskPoolClass::parent_class"]
        [::std::mem::offset_of!(_GstSharedTaskPoolClass, parent_class) - 0usize];
    ["Offset of field: _GstSharedTaskPoolClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstSharedTaskPoolClass, _gst_reserved) - 248usize];
};
unsafe extern "C" {
    pub fn gst_shared_task_pool_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_shared_task_pool_set_max_threads(pool: *mut GstSharedTaskPool, max_threads: guint);
}
unsafe extern "C" {
    pub fn gst_shared_task_pool_get_max_threads(pool: *mut GstSharedTaskPool) -> guint;
}
unsafe extern "C" {
    pub fn gst_shared_task_pool_new() -> *mut GstTaskPool;
}
#[doc = " GstTaskFunction:\n @user_data: user data passed to the function\n\n A function that will repeatedly be called in the thread created by\n a #GstTask."]
pub type GstTaskFunction = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GstTask:\n @state: the state of the task\n @cond: used to pause/resume the task\n @lock: The lock taken when iterating the task function\n @func: the function executed by this task\n @user_data: user_data passed to the task function\n @notify: GDestroyNotify for @user_data\n @running: a flag indicating that the task is running\n\n The #GstTask object."]
pub type GstTask = _GstTask;
pub type GstTaskClass = _GstTaskClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTaskPrivate {
    _unused: [u8; 0],
}
pub type GstTaskPrivate = _GstTaskPrivate;
pub const GstTaskState_GST_TASK_STARTED: GstTaskState = 0;
pub const GstTaskState_GST_TASK_STOPPED: GstTaskState = 1;
pub const GstTaskState_GST_TASK_PAUSED: GstTaskState = 2;
#[doc = " GstTaskState:\n @GST_TASK_STARTED: the task is started and running\n @GST_TASK_STOPPED: the task is stopped\n @GST_TASK_PAUSED: the task is paused\n\n The different states a task can be in"]
pub type GstTaskState = ::std::os::raw::c_uint;
#[doc = " GstTaskThreadFunc:\n @task: The #GstTask\n @thread: The #GThread\n @user_data: user data\n\n Custom GstTask thread callback functions that can be installed."]
pub type GstTaskThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(task: *mut GstTask, thread: *mut GThread, user_data: gpointer),
>;
#[doc = " GstTask:\n @state: the state of the task\n @cond: used to pause/resume the task\n @lock: The lock taken when iterating the task function\n @func: the function executed by this task\n @user_data: user_data passed to the task function\n @notify: GDestroyNotify for @user_data\n @running: a flag indicating that the task is running\n\n The #GstTask object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstTask {
    pub object: GstObject,
    pub state: GstTaskState,
    pub cond: GCond,
    pub lock: *mut GRecMutex,
    pub func: GstTaskFunction,
    pub user_data: gpointer,
    pub notify: GDestroyNotify,
    pub running: gboolean,
    pub thread: *mut GThread,
    pub priv_: *mut GstTaskPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTask"][::std::mem::size_of::<_GstTask>() - 200usize];
    ["Alignment of _GstTask"][::std::mem::align_of::<_GstTask>() - 8usize];
    ["Offset of field: _GstTask::object"][::std::mem::offset_of!(_GstTask, object) - 0usize];
    ["Offset of field: _GstTask::state"][::std::mem::offset_of!(_GstTask, state) - 88usize];
    ["Offset of field: _GstTask::cond"][::std::mem::offset_of!(_GstTask, cond) - 96usize];
    ["Offset of field: _GstTask::lock"][::std::mem::offset_of!(_GstTask, lock) - 112usize];
    ["Offset of field: _GstTask::func"][::std::mem::offset_of!(_GstTask, func) - 120usize];
    ["Offset of field: _GstTask::user_data"]
        [::std::mem::offset_of!(_GstTask, user_data) - 128usize];
    ["Offset of field: _GstTask::notify"][::std::mem::offset_of!(_GstTask, notify) - 136usize];
    ["Offset of field: _GstTask::running"][::std::mem::offset_of!(_GstTask, running) - 144usize];
    ["Offset of field: _GstTask::thread"][::std::mem::offset_of!(_GstTask, thread) - 152usize];
    ["Offset of field: _GstTask::priv_"][::std::mem::offset_of!(_GstTask, priv_) - 160usize];
    ["Offset of field: _GstTask::_gst_reserved"]
        [::std::mem::offset_of!(_GstTask, _gst_reserved) - 168usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTaskClass {
    pub parent_class: GstObjectClass,
    pub pool: *mut GstTaskPool,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTaskClass"][::std::mem::size_of::<_GstTaskClass>() - 224usize];
    ["Alignment of _GstTaskClass"][::std::mem::align_of::<_GstTaskClass>() - 8usize];
    ["Offset of field: _GstTaskClass::parent_class"]
        [::std::mem::offset_of!(_GstTaskClass, parent_class) - 0usize];
    ["Offset of field: _GstTaskClass::pool"]
        [::std::mem::offset_of!(_GstTaskClass, pool) - 184usize];
    ["Offset of field: _GstTaskClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstTaskClass, _gst_reserved) - 192usize];
};
unsafe extern "C" {
    pub fn gst_task_cleanup_all();
}
unsafe extern "C" {
    pub fn gst_task_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_task_new(
        func: GstTaskFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GstTask;
}
unsafe extern "C" {
    pub fn gst_task_set_lock(task: *mut GstTask, mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn gst_task_get_pool(task: *mut GstTask) -> *mut GstTaskPool;
}
unsafe extern "C" {
    pub fn gst_task_set_pool(task: *mut GstTask, pool: *mut GstTaskPool);
}
unsafe extern "C" {
    pub fn gst_task_set_enter_callback(
        task: *mut GstTask,
        enter_func: GstTaskThreadFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_task_set_leave_callback(
        task: *mut GstTask,
        leave_func: GstTaskThreadFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_task_get_state(task: *mut GstTask) -> GstTaskState;
}
unsafe extern "C" {
    pub fn gst_task_set_state(task: *mut GstTask, state: GstTaskState) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_task_start(task: *mut GstTask) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_task_stop(task: *mut GstTask) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_task_pause(task: *mut GstTask) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_task_resume(task: *mut GstTask) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_task_join(task: *mut GstTask) -> gboolean;
}
pub type GstTask_autoptr = *mut GstTask;
pub type GstTask_listautoptr = *mut GList;
pub type GstTask_slistautoptr = *mut GSList;
pub type GstTask_queueautoptr = *mut GQueue;
pub const GstPadPresence_GST_PAD_ALWAYS: GstPadPresence = 0;
pub const GstPadPresence_GST_PAD_SOMETIMES: GstPadPresence = 1;
pub const GstPadPresence_GST_PAD_REQUEST: GstPadPresence = 2;
#[doc = " GstPadPresence:\n @GST_PAD_ALWAYS: the pad is always available\n @GST_PAD_SOMETIMES: the pad will become available depending on the media stream\n @GST_PAD_REQUEST: the pad is only available on request with\n  gst_element_request_pad().\n\n Indicates when this pad will become available."]
pub type GstPadPresence = ::std::os::raw::c_uint;
pub const GstPadTemplateFlags_GST_PAD_TEMPLATE_FLAG_LAST: GstPadTemplateFlags = 256;
#[doc = " GstPadTemplateFlags:\n @GST_PAD_TEMPLATE_FLAG_LAST: first flag that can be used by subclasses.\n\n Flags for the padtemplate"]
pub type GstPadTemplateFlags = ::std::os::raw::c_uint;
#[doc = " GstPadTemplate:\n\n The padtemplate object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstPadTemplate {
    pub object: GstObject,
    pub name_template: *mut gchar,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub caps: *mut GstCaps,
    pub ABI: _GstPadTemplate__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstPadTemplate__bindgen_ty_1 {
    pub _gst_reserved: [gpointer; 4usize],
    pub abi: _GstPadTemplate__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPadTemplate__bindgen_ty_1__bindgen_ty_1 {
    pub gtype: GType,
    pub documentation_caps: *mut GstCaps,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadTemplate__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstPadTemplate__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of _GstPadTemplate__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPadTemplate__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstPadTemplate__bindgen_ty_1__bindgen_ty_1::gtype"]
        [::std::mem::offset_of!(_GstPadTemplate__bindgen_ty_1__bindgen_ty_1, gtype) - 0usize];
    ["Offset of field: _GstPadTemplate__bindgen_ty_1__bindgen_ty_1::documentation_caps"][::std::mem::offset_of!(
        _GstPadTemplate__bindgen_ty_1__bindgen_ty_1,
        documentation_caps
    )
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadTemplate__bindgen_ty_1"]
        [::std::mem::size_of::<_GstPadTemplate__bindgen_ty_1>() - 32usize];
    ["Alignment of _GstPadTemplate__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPadTemplate__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstPadTemplate__bindgen_ty_1::_gst_reserved"]
        [::std::mem::offset_of!(_GstPadTemplate__bindgen_ty_1, _gst_reserved) - 0usize];
    ["Offset of field: _GstPadTemplate__bindgen_ty_1::abi"]
        [::std::mem::offset_of!(_GstPadTemplate__bindgen_ty_1, abi) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadTemplate"][::std::mem::size_of::<_GstPadTemplate>() - 144usize];
    ["Alignment of _GstPadTemplate"][::std::mem::align_of::<_GstPadTemplate>() - 8usize];
    ["Offset of field: _GstPadTemplate::object"]
        [::std::mem::offset_of!(_GstPadTemplate, object) - 0usize];
    ["Offset of field: _GstPadTemplate::name_template"]
        [::std::mem::offset_of!(_GstPadTemplate, name_template) - 88usize];
    ["Offset of field: _GstPadTemplate::direction"]
        [::std::mem::offset_of!(_GstPadTemplate, direction) - 96usize];
    ["Offset of field: _GstPadTemplate::presence"]
        [::std::mem::offset_of!(_GstPadTemplate, presence) - 100usize];
    ["Offset of field: _GstPadTemplate::caps"]
        [::std::mem::offset_of!(_GstPadTemplate, caps) - 104usize];
    ["Offset of field: _GstPadTemplate::ABI"]
        [::std::mem::offset_of!(_GstPadTemplate, ABI) - 112usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPadTemplateClass {
    pub parent_class: GstObjectClass,
    pub pad_created:
        ::std::option::Option<unsafe extern "C" fn(templ: *mut GstPadTemplate, pad: *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadTemplateClass"][::std::mem::size_of::<_GstPadTemplateClass>() - 224usize];
    ["Alignment of _GstPadTemplateClass"][::std::mem::align_of::<_GstPadTemplateClass>() - 8usize];
    ["Offset of field: _GstPadTemplateClass::parent_class"]
        [::std::mem::offset_of!(_GstPadTemplateClass, parent_class) - 0usize];
    ["Offset of field: _GstPadTemplateClass::pad_created"]
        [::std::mem::offset_of!(_GstPadTemplateClass, pad_created) - 184usize];
    ["Offset of field: _GstPadTemplateClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstPadTemplateClass, _gst_reserved) - 192usize];
};
#[doc = " GstStaticPadTemplate:\n @name_template: the name of the template\n @direction: the direction of the template\n @presence: the presence of the template\n @static_caps: the caps of the template.\n\n Structure describing the #GstStaticPadTemplate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstStaticPadTemplate {
    pub name_template: *const gchar,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub static_caps: GstStaticCaps,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstStaticPadTemplate"][::std::mem::size_of::<_GstStaticPadTemplate>() - 64usize];
    ["Alignment of _GstStaticPadTemplate"]
        [::std::mem::align_of::<_GstStaticPadTemplate>() - 8usize];
    ["Offset of field: _GstStaticPadTemplate::name_template"]
        [::std::mem::offset_of!(_GstStaticPadTemplate, name_template) - 0usize];
    ["Offset of field: _GstStaticPadTemplate::direction"]
        [::std::mem::offset_of!(_GstStaticPadTemplate, direction) - 8usize];
    ["Offset of field: _GstStaticPadTemplate::presence"]
        [::std::mem::offset_of!(_GstStaticPadTemplate, presence) - 12usize];
    ["Offset of field: _GstStaticPadTemplate::static_caps"]
        [::std::mem::offset_of!(_GstStaticPadTemplate, static_caps) - 16usize];
};
unsafe extern "C" {
    pub fn gst_pad_template_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " gst_static_pad_template_get_type: (attributes doc.skip=true)"]
    pub fn gst_static_pad_template_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_template_new(
        name_template: *const gchar,
        direction: GstPadDirection,
        presence: GstPadPresence,
        caps: *mut GstCaps,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_pad_template_new_with_gtype(
        name_template: *const gchar,
        direction: GstPadDirection,
        presence: GstPadPresence,
        caps: *mut GstCaps,
        pad_type: GType,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_static_pad_template_get(
        pad_template: *mut GstStaticPadTemplate,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_pad_template_new_from_static_pad_template_with_gtype(
        pad_template: *mut GstStaticPadTemplate,
        pad_type: GType,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_static_pad_template_get_caps(templ: *mut GstStaticPadTemplate) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_template_get_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_template_set_documentation_caps(templ: *mut GstPadTemplate, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_pad_template_get_documentation_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_template_pad_created(templ: *mut GstPadTemplate, pad: *mut GstPad);
}
pub type GstPadTemplate_autoptr = *mut GstPadTemplate;
pub type GstPadTemplate_listautoptr = *mut GList;
pub type GstPadTemplate_slistautoptr = *mut GSList;
pub type GstPadTemplate_queueautoptr = *mut GQueue;
pub const GstPadLinkReturn_GST_PAD_LINK_OK: GstPadLinkReturn = 0;
pub const GstPadLinkReturn_GST_PAD_LINK_WRONG_HIERARCHY: GstPadLinkReturn = -1;
pub const GstPadLinkReturn_GST_PAD_LINK_WAS_LINKED: GstPadLinkReturn = -2;
pub const GstPadLinkReturn_GST_PAD_LINK_WRONG_DIRECTION: GstPadLinkReturn = -3;
pub const GstPadLinkReturn_GST_PAD_LINK_NOFORMAT: GstPadLinkReturn = -4;
pub const GstPadLinkReturn_GST_PAD_LINK_NOSCHED: GstPadLinkReturn = -5;
pub const GstPadLinkReturn_GST_PAD_LINK_REFUSED: GstPadLinkReturn = -6;
#[doc = " GstPadLinkReturn:\n @GST_PAD_LINK_OK\t\t: link succeeded\n @GST_PAD_LINK_WRONG_HIERARCHY: pads have no common grandparent\n @GST_PAD_LINK_WAS_LINKED\t: pad was already linked\n @GST_PAD_LINK_WRONG_DIRECTION: pads have wrong direction\n @GST_PAD_LINK_NOFORMAT\t: pads do not have common format\n @GST_PAD_LINK_NOSCHED\t: pads cannot cooperate in scheduling\n @GST_PAD_LINK_REFUSED\t: refused for some reason\n\n Result values from gst_pad_link and friends."]
pub type GstPadLinkReturn = ::std::os::raw::c_int;
pub const GstFlowReturn_GST_FLOW_CUSTOM_SUCCESS_2: GstFlowReturn = 102;
pub const GstFlowReturn_GST_FLOW_CUSTOM_SUCCESS_1: GstFlowReturn = 101;
pub const GstFlowReturn_GST_FLOW_CUSTOM_SUCCESS: GstFlowReturn = 100;
pub const GstFlowReturn_GST_FLOW_OK: GstFlowReturn = 0;
pub const GstFlowReturn_GST_FLOW_NOT_LINKED: GstFlowReturn = -1;
pub const GstFlowReturn_GST_FLOW_FLUSHING: GstFlowReturn = -2;
pub const GstFlowReturn_GST_FLOW_EOS: GstFlowReturn = -3;
pub const GstFlowReturn_GST_FLOW_NOT_NEGOTIATED: GstFlowReturn = -4;
pub const GstFlowReturn_GST_FLOW_ERROR: GstFlowReturn = -5;
pub const GstFlowReturn_GST_FLOW_NOT_SUPPORTED: GstFlowReturn = -6;
pub const GstFlowReturn_GST_FLOW_CUSTOM_ERROR: GstFlowReturn = -100;
pub const GstFlowReturn_GST_FLOW_CUSTOM_ERROR_1: GstFlowReturn = -101;
pub const GstFlowReturn_GST_FLOW_CUSTOM_ERROR_2: GstFlowReturn = -102;
#[doc = " GstFlowReturn:\n @GST_FLOW_OK:\t\t Data passing was ok.\n @GST_FLOW_NOT_LINKED:\t Pad is not linked.\n @GST_FLOW_FLUSHING:\t         Pad is flushing.\n @GST_FLOW_EOS:                Pad is EOS.\n @GST_FLOW_NOT_NEGOTIATED:\t Pad is not negotiated.\n @GST_FLOW_ERROR:\t\t Some (fatal) error occurred. Element generating\n                               this error should post an error message using\n                               GST_ELEMENT_ERROR() with more details.\n @GST_FLOW_NOT_SUPPORTED:\t This operation is not supported.\n @GST_FLOW_CUSTOM_SUCCESS:\t Elements can use values starting from\n                               this (and higher) to define custom success\n                               codes.\n @GST_FLOW_CUSTOM_SUCCESS_1:\t Pre-defined custom success code (define your\n                               custom success code to this to avoid compiler\n                               warnings).\n @GST_FLOW_CUSTOM_SUCCESS_2:\t Pre-defined custom success code.\n @GST_FLOW_CUSTOM_ERROR:\t Elements can use values starting from\n                               this (and lower) to define custom error codes.\n @GST_FLOW_CUSTOM_ERROR_1:\t Pre-defined custom error code (define your\n                               custom error code to this to avoid compiler\n                               warnings).\n @GST_FLOW_CUSTOM_ERROR_2:\t Pre-defined custom error code.\n\n The result of passing data to a pad.\n\n Note that the custom return values should not be exposed outside of the\n element scope."]
pub type GstFlowReturn = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn gst_flow_get_name(ret: GstFlowReturn) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_flow_to_quark(ret: GstFlowReturn) -> GQuark;
}
unsafe extern "C" {
    pub fn gst_pad_link_get_name(ret: GstPadLinkReturn) -> *const gchar;
}
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_NOTHING: GstPadLinkCheck = 0;
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_HIERARCHY: GstPadLinkCheck = 1;
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_TEMPLATE_CAPS: GstPadLinkCheck = 2;
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_CAPS: GstPadLinkCheck = 4;
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_NO_RECONFIGURE: GstPadLinkCheck = 8;
pub const GstPadLinkCheck_GST_PAD_LINK_CHECK_DEFAULT: GstPadLinkCheck = 5;
#[doc = " GstPadLinkCheck:\n @GST_PAD_LINK_CHECK_NOTHING: Don't check hierarchy or caps compatibility.\n @GST_PAD_LINK_CHECK_HIERARCHY: Check the pads have same parents/grandparents.\n   Could be omitted if it is already known that the two elements that own the\n   pads are in the same bin.\n @GST_PAD_LINK_CHECK_TEMPLATE_CAPS: Check if the pads are compatible by using\n   their template caps. This is much faster than @GST_PAD_LINK_CHECK_CAPS, but\n   would be unsafe e.g. if one pad has %GST_CAPS_ANY.\n @GST_PAD_LINK_CHECK_CAPS: Check if the pads are compatible by comparing the\n   caps returned by gst_pad_query_caps().\n @GST_PAD_LINK_CHECK_NO_RECONFIGURE: Disables pushing a reconfigure event when pads are\n   linked.\n @GST_PAD_LINK_CHECK_DEFAULT: The default checks done when linking\n   pads (i.e. the ones used by gst_pad_link()).\n\n The amount of checking to be done when linking pads. @GST_PAD_LINK_CHECK_CAPS\n and @GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually exclusive. If both are\n specified, expensive but safe @GST_PAD_LINK_CHECK_CAPS are performed.\n\n > Only disable some of the checks if you are 100% certain you know the link\n > will not fail because of hierarchy/caps compatibility failures. If uncertain,\n > use the default checks (%GST_PAD_LINK_CHECK_DEFAULT) or the regular methods\n > for linking the pads."]
pub type GstPadLinkCheck = ::std::os::raw::c_uint;
#[doc = " GstPadActivateFunction:\n @pad: a #GstPad\n @parent: the parent of @pad\n\n This function is called when the pad is activated during the element\n READY to PAUSED state change. By default this function will call the\n activate function that puts the pad in push mode but elements can\n override this function to activate the pad in pull mode if they wish.\n\n Returns: %TRUE if the pad could be activated."]
pub type GstPadActivateFunction = ::std::option::Option<
    unsafe extern "C" fn(pad: *mut GstPad, parent: *mut GstObject) -> gboolean,
>;
#[doc = " GstPadActivateModeFunction:\n @pad: a #GstPad\n @parent: the parent of @pad\n @mode: the requested activation mode of @pad\n @active: activate or deactivate the pad.\n\n The prototype of the push and pull activate functions.\n\n Returns: %TRUE if the pad could be activated or deactivated."]
pub type GstPadActivateModeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        mode: GstPadMode,
        active: gboolean,
    ) -> gboolean,
>;
#[doc = " GstPadChainFunction:\n @pad: the sink #GstPad that performed the chain.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @buffer: (transfer full): the #GstBuffer that is chained, not %NULL.\n\n A function that will be called on sinkpads when chaining buffers.\n The function typically processes the data contained in the buffer and\n either consumes the data or passes it on to the internally linked pad(s).\n\n The implementer of this function receives a refcount to @buffer and should\n gst_buffer_unref() when the buffer is no longer needed.\n\n When a chain function detects an error in the data stream, it must post an\n error on the bus and return an appropriate #GstFlowReturn value.\n\n Returns: #GST_FLOW_OK for success"]
pub type GstPadChainFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        buffer: *mut GstBuffer,
    ) -> GstFlowReturn,
>;
#[doc = " GstPadChainListFunction:\n @pad: the sink #GstPad that performed the chain.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @list: (transfer full): the #GstBufferList that is chained, not %NULL.\n\n A function that will be called on sinkpads when chaining buffer lists.\n The function typically processes the data contained in the buffer list and\n either consumes the data or passes it on to the internally linked pad(s).\n\n The implementer of this function receives a refcount to @list and\n should gst_buffer_list_unref() when the list is no longer needed.\n\n When a chainlist function detects an error in the data stream, it must\n post an error on the bus and return an appropriate #GstFlowReturn value.\n\n Returns: #GST_FLOW_OK for success"]
pub type GstPadChainListFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        list: *mut GstBufferList,
    ) -> GstFlowReturn,
>;
#[doc = " GstPadGetRangeFunction:\n @pad: the src #GstPad to perform the getrange on.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @offset: the offset of the range\n @length: the length of the range\n @buffer: a memory location to hold the result buffer, cannot be %NULL.\n\n This function will be called on source pads when a peer element\n request a buffer at the specified @offset and @length. If this function\n returns #GST_FLOW_OK, the result buffer will be stored in @buffer. The\n contents of @buffer is invalid for any other return value.\n\n This function is installed on a source pad with\n gst_pad_set_getrange_function() and can only be called on source pads after\n they are successfully activated with gst_pad_activate_mode() with the\n #GST_PAD_MODE_PULL.\n\n @offset and @length are always given in byte units. @offset must normally be a value\n between 0 and the length in bytes of the data available on @pad. The\n length (duration in bytes) can be retrieved with a #GST_QUERY_DURATION or with a\n #GST_QUERY_SEEKING.\n\n Any @offset larger or equal than the length will make the function return\n #GST_FLOW_EOS, which corresponds to EOS. In this case @buffer does not\n contain a valid buffer.\n\n The buffer size of @buffer will only be smaller than @length when @offset is\n near the end of the stream. In all other cases, the size of @buffer must be\n exactly the requested size.\n\n It is allowed to call this function with a 0 @length and valid @offset, in\n which case @buffer will contain a 0-sized buffer and the function returns\n #GST_FLOW_OK.\n\n When this function is called with a -1 @offset, the sequentially next buffer\n of length @length in the stream is returned.\n\n When this function is called with a -1 @length, a buffer with a default\n optimal length is returned in @buffer. The length might depend on the value\n of @offset.\n\n Returns: #GST_FLOW_OK for success and a valid buffer in @buffer. Any other\n return value leaves @buffer undefined."]
pub type GstPadGetRangeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        offset: guint64,
        length: guint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn,
>;
#[doc = " GstPadEventFunction:\n @pad: the #GstPad to handle the event.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @event: (transfer full): the #GstEvent to handle.\n\n Function signature to handle an event for the pad.\n\n Returns: %TRUE if the pad could handle the event."]
pub type GstPadEventFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        event: *mut GstEvent,
    ) -> gboolean,
>;
#[doc = " GstPadEventFullFunction:\n @pad: the #GstPad to handle the event.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @event: (transfer full): the #GstEvent to handle.\n\n Function signature to handle an event for the pad.\n\n This variant is for specific elements that will take into account the\n last downstream flow return (from a pad push), in which case they can\n return it.\n\n Returns: %GST_FLOW_OK if the event was handled properly, or any other\n #GstFlowReturn dependent on downstream state.\n\n Since: 1.8"]
pub type GstPadEventFullFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        event: *mut GstEvent,
    ) -> GstFlowReturn,
>;
#[doc = " GstPadIterIntLinkFunction:\n @pad: The #GstPad to query.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n\n The signature of the internal pad link iterator function.\n\n Returns: a new #GstIterator that will iterate over all pads that are\n linked to the given pad on the inside of the parent element.\n\n the caller must call gst_iterator_free() after usage."]
pub type GstPadIterIntLinkFunction = ::std::option::Option<
    unsafe extern "C" fn(pad: *mut GstPad, parent: *mut GstObject) -> *mut GstIterator,
>;
#[doc = " GstPadQueryFunction:\n @pad: the #GstPad to query.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @query: the #GstQuery object to execute\n\n The signature of the query function.\n\n Returns: %TRUE if the query could be performed."]
pub type GstPadQueryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        query: *mut GstQuery,
    ) -> gboolean,
>;
#[doc = " GstPadLinkFunction:\n @pad: the #GstPad that is linked.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n @peer: the peer #GstPad of the link\n\n Function signature to handle a new link on the pad.\n\n Returns: the result of the link with the specified peer."]
pub type GstPadLinkFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        parent: *mut GstObject,
        peer: *mut GstPad,
    ) -> GstPadLinkReturn,
>;
#[doc = " GstPadUnlinkFunction:\n @pad: the #GstPad that is linked.\n @parent: (allow-none): the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT\n          flag is set, @parent is guaranteed to be not-%NULL and remain valid\n          during the execution of this function.\n\n Function signature to handle a unlinking the pad prom its peer.\n\n The pad's lock is already held when the unlink function is called, so most\n pad functions cannot be called from within the callback."]
pub type GstPadUnlinkFunction =
    ::std::option::Option<unsafe extern "C" fn(pad: *mut GstPad, parent: *mut GstObject)>;
#[doc = " GstPadForwardFunction:\n @pad: the #GstPad that is forwarded.\n @user_data: the gpointer to optional user data.\n\n A forward function is called for all internally linked pads, see\n gst_pad_forward().\n\n Returns: %TRUE if the dispatching procedure has to be stopped."]
pub type GstPadForwardFunction =
    ::std::option::Option<unsafe extern "C" fn(pad: *mut GstPad, user_data: gpointer) -> gboolean>;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_INVALID: GstPadProbeType = 0;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_IDLE: GstPadProbeType = 1;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BLOCK: GstPadProbeType = 2;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BUFFER: GstPadProbeType = 16;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BUFFER_LIST: GstPadProbeType = 32;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: GstPadProbeType = 64;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: GstPadProbeType = 128;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_EVENT_FLUSH: GstPadProbeType = 256;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: GstPadProbeType = 512;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: GstPadProbeType = 1024;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_PUSH: GstPadProbeType = 4096;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_PULL: GstPadProbeType = 8192;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BLOCKING: GstPadProbeType = 3;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: GstPadProbeType = 112;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_DATA_UPSTREAM: GstPadProbeType = 128;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_DATA_BOTH: GstPadProbeType = 240;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: GstPadProbeType = 114;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: GstPadProbeType = 130;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_EVENT_BOTH: GstPadProbeType = 192;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_QUERY_BOTH: GstPadProbeType = 1536;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_ALL_BOTH: GstPadProbeType = 1776;
pub const GstPadProbeType_GST_PAD_PROBE_TYPE_SCHEDULING: GstPadProbeType = 12288;
#[doc = " GstPadProbeType:\n @GST_PAD_PROBE_TYPE_INVALID: invalid probe type\n @GST_PAD_PROBE_TYPE_IDLE: probe idle pads and block while the callback is called\n @GST_PAD_PROBE_TYPE_BLOCK: probe and block pads\n @GST_PAD_PROBE_TYPE_BUFFER: probe buffers\n @GST_PAD_PROBE_TYPE_BUFFER_LIST: probe buffer lists\n @GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: probe downstream events\n @GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: probe upstream events\n @GST_PAD_PROBE_TYPE_EVENT_FLUSH: probe flush events. This probe has to be\n     explicitly enabled and is not included in the\n     @@GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or\n     @@GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.\n @GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: probe downstream queries\n @GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: probe upstream queries\n @GST_PAD_PROBE_TYPE_PUSH: probe push\n @GST_PAD_PROBE_TYPE_PULL: probe pull\n @GST_PAD_PROBE_TYPE_BLOCKING: probe and block at the next opportunity, at data flow or when idle\n @GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: probe downstream data (buffers, buffer lists, and events)\n @GST_PAD_PROBE_TYPE_DATA_UPSTREAM: probe upstream data (events)\n @GST_PAD_PROBE_TYPE_DATA_BOTH: probe upstream and downstream data (buffers, buffer lists, and events)\n @GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: probe and block downstream data (buffers, buffer lists, and events)\n @GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: probe and block upstream data (events)\n @GST_PAD_PROBE_TYPE_EVENT_BOTH: probe upstream and downstream events\n @GST_PAD_PROBE_TYPE_QUERY_BOTH: probe upstream and downstream queries\n @GST_PAD_PROBE_TYPE_ALL_BOTH: probe upstream events and queries and downstream buffers, buffer lists, events and queries\n @GST_PAD_PROBE_TYPE_SCHEDULING: probe push and pull\n\n The different probing types that can occur. When either one of\n @GST_PAD_PROBE_TYPE_IDLE or @GST_PAD_PROBE_TYPE_BLOCK is used, the probe will be a\n blocking probe."]
pub type GstPadProbeType = ::std::os::raw::c_uint;
pub const GstPadProbeReturn_GST_PAD_PROBE_DROP: GstPadProbeReturn = 0;
pub const GstPadProbeReturn_GST_PAD_PROBE_OK: GstPadProbeReturn = 1;
pub const GstPadProbeReturn_GST_PAD_PROBE_REMOVE: GstPadProbeReturn = 2;
pub const GstPadProbeReturn_GST_PAD_PROBE_PASS: GstPadProbeReturn = 3;
pub const GstPadProbeReturn_GST_PAD_PROBE_HANDLED: GstPadProbeReturn = 4;
#[doc = " GstPadProbeReturn:\n @GST_PAD_PROBE_OK: normal probe return value. This leaves the probe in\n        place, and defers decisions about dropping or passing data to other\n        probes, if any. If there are no other probes, the default behaviour\n        for the probe type applies ('block' for blocking probes,\n        and 'pass' for non-blocking probes).\n @GST_PAD_PROBE_DROP: drop data in data probes. For push mode this means that\n        the data item is not sent downstream. For pull mode, it means that\n        the data item is not passed upstream. In both cases, no other probes\n        are called for this item and %GST_FLOW_OK or %TRUE is returned to the\n        caller.\n @GST_PAD_PROBE_REMOVE: remove this probe, passing the data. For blocking probes\n        this will cause data flow to unblock, unless there are also other\n        blocking probes installed.\n @GST_PAD_PROBE_PASS: pass the data item in the block probe and block on the\n        next item. Note, that if there are multiple pad probes installed and\n        any probe returns PASS, the data will be passed.\n @GST_PAD_PROBE_HANDLED: Data has been handled in the probe and will not be\n        forwarded further. For events and buffers this is the same behaviour as\n        %GST_PAD_PROBE_DROP (except that in this case you need to unref the buffer\n        or event yourself). For queries it will also return %TRUE to the caller.\n        The probe can also modify the #GstFlowReturn value by using the\n        #GST_PAD_PROBE_INFO_FLOW_RETURN() accessor.\n        Note that the resulting query must contain valid entries.\n        Since: 1.6\n\n Different return values for the #GstPadProbeCallback."]
pub type GstPadProbeReturn = ::std::os::raw::c_uint;
#[doc = " GstPadProbeInfo:\n @type: the current probe type\n @id: the id of the probe\n @data: (allow-none): type specific data, check the @type field to know the\n    datatype.  This field can be %NULL.\n @offset: offset of pull probe, this field is valid when @type contains\n    #GST_PAD_PROBE_TYPE_PULL\n @size: size of pull probe, this field is valid when @type contains\n    #GST_PAD_PROBE_TYPE_PULL\n\n Info passed in the #GstPadProbeCallback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstPadProbeInfo {
    pub type_: GstPadProbeType,
    pub id: gulong,
    pub data: gpointer,
    pub offset: guint64,
    pub size: guint,
    pub ABI: _GstPadProbeInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstPadProbeInfo__bindgen_ty_1 {
    pub _gst_reserved: [gpointer; 4usize],
    pub abi: _GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub flow_ret: GstFlowReturn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: _GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1::flow_ret"]
        [::std::mem::offset_of!(_GstPadProbeInfo__bindgen_ty_1__bindgen_ty_1, flow_ret) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadProbeInfo__bindgen_ty_1"]
        [::std::mem::size_of::<_GstPadProbeInfo__bindgen_ty_1>() - 32usize];
    ["Alignment of _GstPadProbeInfo__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPadProbeInfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstPadProbeInfo__bindgen_ty_1::_gst_reserved"]
        [::std::mem::offset_of!(_GstPadProbeInfo__bindgen_ty_1, _gst_reserved) - 0usize];
    ["Offset of field: _GstPadProbeInfo__bindgen_ty_1::abi"]
        [::std::mem::offset_of!(_GstPadProbeInfo__bindgen_ty_1, abi) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadProbeInfo"][::std::mem::size_of::<_GstPadProbeInfo>() - 72usize];
    ["Alignment of _GstPadProbeInfo"][::std::mem::align_of::<_GstPadProbeInfo>() - 8usize];
    ["Offset of field: _GstPadProbeInfo::type_"]
        [::std::mem::offset_of!(_GstPadProbeInfo, type_) - 0usize];
    ["Offset of field: _GstPadProbeInfo::id"]
        [::std::mem::offset_of!(_GstPadProbeInfo, id) - 8usize];
    ["Offset of field: _GstPadProbeInfo::data"]
        [::std::mem::offset_of!(_GstPadProbeInfo, data) - 16usize];
    ["Offset of field: _GstPadProbeInfo::offset"]
        [::std::mem::offset_of!(_GstPadProbeInfo, offset) - 24usize];
    ["Offset of field: _GstPadProbeInfo::size"]
        [::std::mem::offset_of!(_GstPadProbeInfo, size) - 32usize];
    ["Offset of field: _GstPadProbeInfo::ABI"]
        [::std::mem::offset_of!(_GstPadProbeInfo, ABI) - 40usize];
};
unsafe extern "C" {
    pub fn gst_pad_probe_info_get_event(info: *mut GstPadProbeInfo) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_pad_probe_info_get_query(info: *mut GstPadProbeInfo) -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_pad_probe_info_get_buffer(info: *mut GstPadProbeInfo) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_pad_probe_info_get_buffer_list(info: *mut GstPadProbeInfo) -> *mut GstBufferList;
}
#[doc = " GstPadProbeCallback:\n @pad: the #GstPad that is blocked\n @info: #GstPadProbeInfo\n @user_data: the gpointer to optional user data.\n\n Callback used by gst_pad_add_probe(). Gets called to notify about the current\n blocking type.\n\n The callback is allowed to modify the data pointer in @info.\n\n Returns: a #GstPadProbeReturn"]
pub type GstPadProbeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        info: *mut GstPadProbeInfo,
        user_data: gpointer,
    ) -> GstPadProbeReturn,
>;
#[doc = " GstPadStickyEventsForeachFunction:\n @pad: the #GstPad.\n @event: (allow-none): a sticky #GstEvent.\n @user_data: the #gpointer to optional user data.\n\n Callback used by gst_pad_sticky_events_foreach().\n\n When this function returns %TRUE, the next event will be\n returned. When %FALSE is returned, gst_pad_sticky_events_foreach() will return.\n\n When @event is set to %NULL, the item will be removed from the list of sticky events.\n @event can be replaced by assigning a new reference to it.\n This function is responsible for unreffing the old event when\n removing or modifying.\n\n Returns: %TRUE if the iteration should continue"]
pub type GstPadStickyEventsForeachFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pad: *mut GstPad,
        event: *mut *mut GstEvent,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GstPadFlags_GST_PAD_FLAG_BLOCKED: GstPadFlags = 16;
pub const GstPadFlags_GST_PAD_FLAG_FLUSHING: GstPadFlags = 32;
pub const GstPadFlags_GST_PAD_FLAG_EOS: GstPadFlags = 64;
pub const GstPadFlags_GST_PAD_FLAG_BLOCKING: GstPadFlags = 128;
pub const GstPadFlags_GST_PAD_FLAG_NEED_PARENT: GstPadFlags = 256;
pub const GstPadFlags_GST_PAD_FLAG_NEED_RECONFIGURE: GstPadFlags = 512;
pub const GstPadFlags_GST_PAD_FLAG_PENDING_EVENTS: GstPadFlags = 1024;
pub const GstPadFlags_GST_PAD_FLAG_FIXED_CAPS: GstPadFlags = 2048;
pub const GstPadFlags_GST_PAD_FLAG_PROXY_CAPS: GstPadFlags = 4096;
pub const GstPadFlags_GST_PAD_FLAG_PROXY_ALLOCATION: GstPadFlags = 8192;
pub const GstPadFlags_GST_PAD_FLAG_PROXY_SCHEDULING: GstPadFlags = 16384;
pub const GstPadFlags_GST_PAD_FLAG_ACCEPT_INTERSECT: GstPadFlags = 32768;
pub const GstPadFlags_GST_PAD_FLAG_ACCEPT_TEMPLATE: GstPadFlags = 65536;
pub const GstPadFlags_GST_PAD_FLAG_LAST: GstPadFlags = 1048576;
#[doc = " GstPadFlags:\n @GST_PAD_FLAG_BLOCKED: is dataflow on a pad blocked\n @GST_PAD_FLAG_FLUSHING: is pad flushing\n @GST_PAD_FLAG_EOS: is pad in EOS state\n @GST_PAD_FLAG_BLOCKING: is pad currently blocking on a buffer or event\n @GST_PAD_FLAG_NEED_PARENT: ensure that there is a parent object before calling\n                       into the pad callbacks.\n @GST_PAD_FLAG_NEED_RECONFIGURE: the pad should be reconfigured/renegotiated.\n                            The flag has to be unset manually after\n                            reconfiguration happened.\n @GST_PAD_FLAG_PENDING_EVENTS: the pad has pending events\n @GST_PAD_FLAG_FIXED_CAPS: the pad is using fixed caps. This means that\n     once the caps are set on the pad, the default caps query function\n     will only return those caps.\n @GST_PAD_FLAG_PROXY_CAPS: the default event and query handler will forward\n                      all events and queries to the internally linked pads\n                      instead of discarding them.\n @GST_PAD_FLAG_PROXY_ALLOCATION: the default query handler will forward\n                      allocation queries to the internally linked pads\n                      instead of discarding them.\n @GST_PAD_FLAG_PROXY_SCHEDULING: the default query handler will forward\n                      scheduling queries to the internally linked pads\n                      instead of discarding them.\n @GST_PAD_FLAG_ACCEPT_INTERSECT: the default accept-caps handler will check\n                      it the caps intersect the query-caps result instead\n                      of checking for a subset. This is interesting for\n                      parsers that can accept incompletely specified caps.\n @GST_PAD_FLAG_ACCEPT_TEMPLATE: the default accept-caps handler will use\n                      the template pad caps instead of query caps to\n                      compare with the accept caps. Use this in combination\n                      with %GST_PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6)\n @GST_PAD_FLAG_LAST: offset to define more flags\n\n Pad state flags"]
pub type GstPadFlags = ::std::os::raw::c_uint;
#[doc = " GstPad:\n @element_private: private data owned by the parent element\n @padtemplate: padtemplate for this pad\n @direction: the direction of the pad, cannot change after creating\n             the pad.\n\n The #GstPad structure. Use the functions to update the variables."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstPad {
    pub object: GstObject,
    pub element_private: gpointer,
    pub padtemplate: *mut GstPadTemplate,
    pub direction: GstPadDirection,
    pub stream_rec_lock: GRecMutex,
    pub task: *mut GstTask,
    pub block_cond: GCond,
    pub probes: GHookList,
    pub mode: GstPadMode,
    pub activatefunc: GstPadActivateFunction,
    pub activatedata: gpointer,
    pub activatenotify: GDestroyNotify,
    pub activatemodefunc: GstPadActivateModeFunction,
    pub activatemodedata: gpointer,
    pub activatemodenotify: GDestroyNotify,
    pub peer: *mut GstPad,
    pub linkfunc: GstPadLinkFunction,
    pub linkdata: gpointer,
    pub linknotify: GDestroyNotify,
    pub unlinkfunc: GstPadUnlinkFunction,
    pub unlinkdata: gpointer,
    pub unlinknotify: GDestroyNotify,
    pub chainfunc: GstPadChainFunction,
    pub chaindata: gpointer,
    pub chainnotify: GDestroyNotify,
    pub chainlistfunc: GstPadChainListFunction,
    pub chainlistdata: gpointer,
    pub chainlistnotify: GDestroyNotify,
    pub getrangefunc: GstPadGetRangeFunction,
    pub getrangedata: gpointer,
    pub getrangenotify: GDestroyNotify,
    pub eventfunc: GstPadEventFunction,
    pub eventdata: gpointer,
    pub eventnotify: GDestroyNotify,
    pub offset: gint64,
    pub queryfunc: GstPadQueryFunction,
    pub querydata: gpointer,
    pub querynotify: GDestroyNotify,
    pub iterintlinkfunc: GstPadIterIntLinkFunction,
    pub iterintlinkdata: gpointer,
    pub iterintlinknotify: GDestroyNotify,
    pub num_probes: gint,
    pub num_blocked: gint,
    pub priv_: *mut GstPadPrivate,
    pub ABI: _GstPad__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstPad__bindgen_ty_1 {
    pub _gst_reserved: [gpointer; 4usize],
    pub abi: _GstPad__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPad__bindgen_ty_1__bindgen_ty_1 {
    pub last_flowret: GstFlowReturn,
    pub eventfullfunc: GstPadEventFullFunction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPad__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstPad__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of _GstPad__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPad__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstPad__bindgen_ty_1__bindgen_ty_1::last_flowret"]
        [::std::mem::offset_of!(_GstPad__bindgen_ty_1__bindgen_ty_1, last_flowret) - 0usize];
    ["Offset of field: _GstPad__bindgen_ty_1__bindgen_ty_1::eventfullfunc"]
        [::std::mem::offset_of!(_GstPad__bindgen_ty_1__bindgen_ty_1, eventfullfunc) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPad__bindgen_ty_1"][::std::mem::size_of::<_GstPad__bindgen_ty_1>() - 32usize];
    ["Alignment of _GstPad__bindgen_ty_1"]
        [::std::mem::align_of::<_GstPad__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstPad__bindgen_ty_1::_gst_reserved"]
        [::std::mem::offset_of!(_GstPad__bindgen_ty_1, _gst_reserved) - 0usize];
    ["Offset of field: _GstPad__bindgen_ty_1::abi"]
        [::std::mem::offset_of!(_GstPad__bindgen_ty_1, abi) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPad"][::std::mem::size_of::<_GstPad>() - 520usize];
    ["Alignment of _GstPad"][::std::mem::align_of::<_GstPad>() - 8usize];
    ["Offset of field: _GstPad::object"][::std::mem::offset_of!(_GstPad, object) - 0usize];
    ["Offset of field: _GstPad::element_private"]
        [::std::mem::offset_of!(_GstPad, element_private) - 88usize];
    ["Offset of field: _GstPad::padtemplate"]
        [::std::mem::offset_of!(_GstPad, padtemplate) - 96usize];
    ["Offset of field: _GstPad::direction"][::std::mem::offset_of!(_GstPad, direction) - 104usize];
    ["Offset of field: _GstPad::stream_rec_lock"]
        [::std::mem::offset_of!(_GstPad, stream_rec_lock) - 112usize];
    ["Offset of field: _GstPad::task"][::std::mem::offset_of!(_GstPad, task) - 128usize];
    ["Offset of field: _GstPad::block_cond"]
        [::std::mem::offset_of!(_GstPad, block_cond) - 136usize];
    ["Offset of field: _GstPad::probes"][::std::mem::offset_of!(_GstPad, probes) - 152usize];
    ["Offset of field: _GstPad::mode"][::std::mem::offset_of!(_GstPad, mode) - 208usize];
    ["Offset of field: _GstPad::activatefunc"]
        [::std::mem::offset_of!(_GstPad, activatefunc) - 216usize];
    ["Offset of field: _GstPad::activatedata"]
        [::std::mem::offset_of!(_GstPad, activatedata) - 224usize];
    ["Offset of field: _GstPad::activatenotify"]
        [::std::mem::offset_of!(_GstPad, activatenotify) - 232usize];
    ["Offset of field: _GstPad::activatemodefunc"]
        [::std::mem::offset_of!(_GstPad, activatemodefunc) - 240usize];
    ["Offset of field: _GstPad::activatemodedata"]
        [::std::mem::offset_of!(_GstPad, activatemodedata) - 248usize];
    ["Offset of field: _GstPad::activatemodenotify"]
        [::std::mem::offset_of!(_GstPad, activatemodenotify) - 256usize];
    ["Offset of field: _GstPad::peer"][::std::mem::offset_of!(_GstPad, peer) - 264usize];
    ["Offset of field: _GstPad::linkfunc"][::std::mem::offset_of!(_GstPad, linkfunc) - 272usize];
    ["Offset of field: _GstPad::linkdata"][::std::mem::offset_of!(_GstPad, linkdata) - 280usize];
    ["Offset of field: _GstPad::linknotify"]
        [::std::mem::offset_of!(_GstPad, linknotify) - 288usize];
    ["Offset of field: _GstPad::unlinkfunc"]
        [::std::mem::offset_of!(_GstPad, unlinkfunc) - 296usize];
    ["Offset of field: _GstPad::unlinkdata"]
        [::std::mem::offset_of!(_GstPad, unlinkdata) - 304usize];
    ["Offset of field: _GstPad::unlinknotify"]
        [::std::mem::offset_of!(_GstPad, unlinknotify) - 312usize];
    ["Offset of field: _GstPad::chainfunc"][::std::mem::offset_of!(_GstPad, chainfunc) - 320usize];
    ["Offset of field: _GstPad::chaindata"][::std::mem::offset_of!(_GstPad, chaindata) - 328usize];
    ["Offset of field: _GstPad::chainnotify"]
        [::std::mem::offset_of!(_GstPad, chainnotify) - 336usize];
    ["Offset of field: _GstPad::chainlistfunc"]
        [::std::mem::offset_of!(_GstPad, chainlistfunc) - 344usize];
    ["Offset of field: _GstPad::chainlistdata"]
        [::std::mem::offset_of!(_GstPad, chainlistdata) - 352usize];
    ["Offset of field: _GstPad::chainlistnotify"]
        [::std::mem::offset_of!(_GstPad, chainlistnotify) - 360usize];
    ["Offset of field: _GstPad::getrangefunc"]
        [::std::mem::offset_of!(_GstPad, getrangefunc) - 368usize];
    ["Offset of field: _GstPad::getrangedata"]
        [::std::mem::offset_of!(_GstPad, getrangedata) - 376usize];
    ["Offset of field: _GstPad::getrangenotify"]
        [::std::mem::offset_of!(_GstPad, getrangenotify) - 384usize];
    ["Offset of field: _GstPad::eventfunc"][::std::mem::offset_of!(_GstPad, eventfunc) - 392usize];
    ["Offset of field: _GstPad::eventdata"][::std::mem::offset_of!(_GstPad, eventdata) - 400usize];
    ["Offset of field: _GstPad::eventnotify"]
        [::std::mem::offset_of!(_GstPad, eventnotify) - 408usize];
    ["Offset of field: _GstPad::offset"][::std::mem::offset_of!(_GstPad, offset) - 416usize];
    ["Offset of field: _GstPad::queryfunc"][::std::mem::offset_of!(_GstPad, queryfunc) - 424usize];
    ["Offset of field: _GstPad::querydata"][::std::mem::offset_of!(_GstPad, querydata) - 432usize];
    ["Offset of field: _GstPad::querynotify"]
        [::std::mem::offset_of!(_GstPad, querynotify) - 440usize];
    ["Offset of field: _GstPad::iterintlinkfunc"]
        [::std::mem::offset_of!(_GstPad, iterintlinkfunc) - 448usize];
    ["Offset of field: _GstPad::iterintlinkdata"]
        [::std::mem::offset_of!(_GstPad, iterintlinkdata) - 456usize];
    ["Offset of field: _GstPad::iterintlinknotify"]
        [::std::mem::offset_of!(_GstPad, iterintlinknotify) - 464usize];
    ["Offset of field: _GstPad::num_probes"]
        [::std::mem::offset_of!(_GstPad, num_probes) - 472usize];
    ["Offset of field: _GstPad::num_blocked"]
        [::std::mem::offset_of!(_GstPad, num_blocked) - 476usize];
    ["Offset of field: _GstPad::priv_"][::std::mem::offset_of!(_GstPad, priv_) - 480usize];
    ["Offset of field: _GstPad::ABI"][::std::mem::offset_of!(_GstPad, ABI) - 488usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPadClass {
    pub parent_class: GstObjectClass,
    pub linked: ::std::option::Option<unsafe extern "C" fn(pad: *mut GstPad, peer: *mut GstPad)>,
    pub unlinked: ::std::option::Option<unsafe extern "C" fn(pad: *mut GstPad, peer: *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPadClass"][::std::mem::size_of::<_GstPadClass>() - 232usize];
    ["Alignment of _GstPadClass"][::std::mem::align_of::<_GstPadClass>() - 8usize];
    ["Offset of field: _GstPadClass::parent_class"]
        [::std::mem::offset_of!(_GstPadClass, parent_class) - 0usize];
    ["Offset of field: _GstPadClass::linked"]
        [::std::mem::offset_of!(_GstPadClass, linked) - 184usize];
    ["Offset of field: _GstPadClass::unlinked"]
        [::std::mem::offset_of!(_GstPadClass, unlinked) - 192usize];
    ["Offset of field: _GstPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstPadClass, _gst_reserved) - 200usize];
};
unsafe extern "C" {
    pub fn gst_pad_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pad_new(name: *const gchar, direction: GstPadDirection) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_pad_new_from_template(templ: *mut GstPadTemplate, name: *const gchar)
    -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_pad_new_from_static_template(
        templ: *mut GstStaticPadTemplate,
        name: *const gchar,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_pad_get_direction(pad: *mut GstPad) -> GstPadDirection;
}
unsafe extern "C" {
    pub fn gst_pad_set_active(pad: *mut GstPad, active: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_is_active(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_activate_mode(pad: *mut GstPad, mode: GstPadMode, active: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_add_probe(
        pad: *mut GstPad,
        mask: GstPadProbeType,
        callback: GstPadProbeCallback,
        user_data: gpointer,
        destroy_data: GDestroyNotify,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn gst_pad_remove_probe(pad: *mut GstPad, id: gulong);
}
unsafe extern "C" {
    pub fn gst_pad_is_blocked(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_is_blocking(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_mark_reconfigure(pad: *mut GstPad);
}
unsafe extern "C" {
    pub fn gst_pad_needs_reconfigure(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_check_reconfigure(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_set_element_private(pad: *mut GstPad, priv_: gpointer);
}
unsafe extern "C" {
    pub fn gst_pad_get_element_private(pad: *mut GstPad) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_pad_get_pad_template(pad: *mut GstPad) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_pad_store_sticky_event(pad: *mut GstPad, event: *mut GstEvent) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_get_sticky_event(
        pad: *mut GstPad,
        event_type: GstEventType,
        idx: guint,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_pad_sticky_events_foreach(
        pad: *mut GstPad,
        foreach_func: GstPadStickyEventsForeachFunction,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_activate_function_full(
        pad: *mut GstPad,
        activate: GstPadActivateFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_activatemode_function_full(
        pad: *mut GstPad,
        activatemode: GstPadActivateModeFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_chain_function_full(
        pad: *mut GstPad,
        chain: GstPadChainFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_chain_list_function_full(
        pad: *mut GstPad,
        chainlist: GstPadChainListFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_getrange_function_full(
        pad: *mut GstPad,
        get: GstPadGetRangeFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_event_function_full(
        pad: *mut GstPad,
        event: GstPadEventFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_event_full_function_full(
        pad: *mut GstPad,
        event: GstPadEventFullFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_link_function_full(
        pad: *mut GstPad,
        link: GstPadLinkFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_set_unlink_function_full(
        pad: *mut GstPad,
        unlink: GstPadUnlinkFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_can_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> GstPadLinkReturn;
}
unsafe extern "C" {
    pub fn gst_pad_link_full(
        srcpad: *mut GstPad,
        sinkpad: *mut GstPad,
        flags: GstPadLinkCheck,
    ) -> GstPadLinkReturn;
}
unsafe extern "C" {
    pub fn gst_pad_unlink(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_is_linked(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_get_peer(pad: *mut GstPad) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_pad_get_pad_template_caps(pad: *mut GstPad) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_get_current_caps(pad: *mut GstPad) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_has_current_caps(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_get_allowed_caps(pad: *mut GstPad) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_get_offset(pad: *mut GstPad) -> gint64;
}
unsafe extern "C" {
    pub fn gst_pad_set_offset(pad: *mut GstPad, offset: gint64);
}
unsafe extern "C" {
    pub fn gst_pad_push(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_push_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_pull_range(
        pad: *mut GstPad,
        offset: guint64,
        size: guint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_push_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_event_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        event: *mut GstEvent,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_get_last_flow_return(pad: *mut GstPad) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_chain(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_chain_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_get_range(
        pad: *mut GstPad,
        offset: guint64,
        size: guint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_pad_send_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_start_task(
        pad: *mut GstPad,
        func: GstTaskFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_pause_task(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_stop_task(pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_get_task_state(pad: *mut GstPad) -> GstTaskState;
}
unsafe extern "C" {
    pub fn gst_pad_set_iterate_internal_links_function_full(
        pad: *mut GstPad,
        iterintlink: GstPadIterIntLinkFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_iterate_internal_links(pad: *mut GstPad) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_pad_iterate_internal_links_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_pad_get_single_internal_link(pad: *mut GstPad) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_pad_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_set_query_function_full(
        pad: *mut GstPad,
        query: GstPadQueryFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_pad_query_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        query: *mut GstQuery,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_forward(
        pad: *mut GstPad,
        forward: GstPadForwardFunction,
        user_data: gpointer,
    ) -> gboolean;
}
pub type GstPad_autoptr = *mut GstPad;
pub type GstPad_listautoptr = *mut GList;
pub type GstPad_slistautoptr = *mut GSList;
pub type GstPad_queueautoptr = *mut GQueue;
#[doc = " GstBus:\n @object: the parent structure\n\n The opaque #GstBus data structure."]
pub type GstBus = _GstBus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBusPrivate {
    _unused: [u8; 0],
}
pub type GstBusPrivate = _GstBusPrivate;
#[doc = " GstBusClass:\n @parent_class: the parent class structure\n\n GStreamer bus class."]
pub type GstBusClass = _GstBusClass;
pub const GstBusFlags_GST_BUS_FLUSHING: GstBusFlags = 16;
pub const GstBusFlags_GST_BUS_FLAG_LAST: GstBusFlags = 32;
#[doc = " GstBusFlags:\n @GST_BUS_FLUSHING: The bus is currently dropping all messages\n @GST_BUS_FLAG_LAST: offset to define more flags\n\n The standard flags that a bus may have."]
pub type GstBusFlags = ::std::os::raw::c_uint;
pub const GstBusSyncReply_GST_BUS_DROP: GstBusSyncReply = 0;
pub const GstBusSyncReply_GST_BUS_PASS: GstBusSyncReply = 1;
pub const GstBusSyncReply_GST_BUS_ASYNC: GstBusSyncReply = 2;
#[doc = " GstBusSyncReply:\n @GST_BUS_DROP: drop the message\n @GST_BUS_PASS: pass the message to the async queue\n @GST_BUS_ASYNC: pass message to async queue, continue if message is handled\n\n The result values for a GstBusSyncHandler."]
pub type GstBusSyncReply = ::std::os::raw::c_uint;
#[doc = " GstBusSyncHandler:\n @bus: the #GstBus that sent the message\n @message: the #GstMessage\n @user_data: user data that has been given, when registering the handler\n\n Handler will be invoked synchronously, when a new message has been injected\n into the bus. This function is mostly used internally. Only one sync handler\n can be attached to a given bus.\n\n If the handler returns %GST_BUS_DROP, it should unref the message, else the\n message should not be unreffed by the sync handler.\n\n Returns: #GstBusSyncReply stating what to do with the message"]
pub type GstBusSyncHandler = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *mut GstBus,
        message: *mut GstMessage,
        user_data: gpointer,
    ) -> GstBusSyncReply,
>;
#[doc = " GstBusFunc:\n @bus: the #GstBus that sent the message\n @message: the #GstMessage\n @user_data: user data that has been given, when registering the handler\n\n Specifies the type of function passed to gst_bus_add_watch() or\n gst_bus_add_watch_full(), which is called from the mainloop when a message\n is available on the bus.\n\n The message passed to the function will be unreffed after execution of this\n function so it should not be freed in the function.\n\n Note that this function is used as a #GSourceFunc which means that returning\n %FALSE will remove the #GSource from the mainloop.\n\n Returns: %FALSE if the event source should be removed."]
pub type GstBusFunc = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *mut GstBus,
        message: *mut GstMessage,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstBus:\n @object: the parent structure\n\n The opaque #GstBus data structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBus {
    pub object: GstObject,
    pub priv_: *mut GstBusPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBus"][::std::mem::size_of::<_GstBus>() - 128usize];
    ["Alignment of _GstBus"][::std::mem::align_of::<_GstBus>() - 8usize];
    ["Offset of field: _GstBus::object"][::std::mem::offset_of!(_GstBus, object) - 0usize];
    ["Offset of field: _GstBus::priv_"][::std::mem::offset_of!(_GstBus, priv_) - 88usize];
    ["Offset of field: _GstBus::_gst_reserved"]
        [::std::mem::offset_of!(_GstBus, _gst_reserved) - 96usize];
};
#[doc = " GstBusClass:\n @parent_class: the parent class structure\n\n GStreamer bus class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBusClass {
    pub parent_class: GstObjectClass,
    #[doc = " GstBusClass::message:\n @bus: the #GstBus\n @message: the message that has been posted asynchronously\n\n A message has been posted on the bus."]
    pub message:
        ::std::option::Option<unsafe extern "C" fn(bus: *mut GstBus, message: *mut GstMessage)>,
    #[doc = " GstBusClass::sync_message:\n @bus: the #GstBus\n @message: the message that has been posted synchronously\n\n A message has been posted on the bus."]
    pub sync_message:
        ::std::option::Option<unsafe extern "C" fn(bus: *mut GstBus, message: *mut GstMessage)>,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBusClass"][::std::mem::size_of::<_GstBusClass>() - 232usize];
    ["Alignment of _GstBusClass"][::std::mem::align_of::<_GstBusClass>() - 8usize];
    ["Offset of field: _GstBusClass::parent_class"]
        [::std::mem::offset_of!(_GstBusClass, parent_class) - 0usize];
    ["Offset of field: _GstBusClass::message"]
        [::std::mem::offset_of!(_GstBusClass, message) - 184usize];
    ["Offset of field: _GstBusClass::sync_message"]
        [::std::mem::offset_of!(_GstBusClass, sync_message) - 192usize];
    ["Offset of field: _GstBusClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstBusClass, _gst_reserved) - 200usize];
};
unsafe extern "C" {
    pub fn gst_bus_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bus_new() -> *mut GstBus;
}
unsafe extern "C" {
    pub fn gst_bus_post(bus: *mut GstBus, message: *mut GstMessage) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bus_have_pending(bus: *mut GstBus) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bus_peek(bus: *mut GstBus) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_pop(bus: *mut GstBus) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_pop_filtered(bus: *mut GstBus, types: GstMessageType) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_timed_pop(bus: *mut GstBus, timeout: GstClockTime) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_timed_pop_filtered(
        bus: *mut GstBus,
        timeout: GstClockTime,
        types: GstMessageType,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_set_flushing(bus: *mut GstBus, flushing: gboolean);
}
unsafe extern "C" {
    pub fn gst_bus_set_sync_handler(
        bus: *mut GstBus,
        func: GstBusSyncHandler,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_bus_get_pollfd(bus: *mut GstBus, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn gst_bus_create_watch(bus: *mut GstBus) -> *mut GSource;
}
unsafe extern "C" {
    pub fn gst_bus_add_watch_full(
        bus: *mut GstBus,
        priority: gint,
        func: GstBusFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_bus_add_watch(bus: *mut GstBus, func: GstBusFunc, user_data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn gst_bus_remove_watch(bus: *mut GstBus) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bus_poll(
        bus: *mut GstBus,
        events: GstMessageType,
        timeout: GstClockTime,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_bus_async_signal_func(
        bus: *mut GstBus,
        message: *mut GstMessage,
        data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bus_sync_signal_handler(
        bus: *mut GstBus,
        message: *mut GstMessage,
        data: gpointer,
    ) -> GstBusSyncReply;
}
unsafe extern "C" {
    pub fn gst_bus_add_signal_watch(bus: *mut GstBus);
}
unsafe extern "C" {
    pub fn gst_bus_add_signal_watch_full(bus: *mut GstBus, priority: gint);
}
unsafe extern "C" {
    pub fn gst_bus_remove_signal_watch(bus: *mut GstBus);
}
unsafe extern "C" {
    pub fn gst_bus_enable_sync_message_emission(bus: *mut GstBus);
}
unsafe extern "C" {
    pub fn gst_bus_disable_sync_message_emission(bus: *mut GstBus);
}
pub type GstBus_autoptr = *mut GstBus;
pub type GstBus_listautoptr = *mut GList;
pub type GstBus_slistautoptr = *mut GSList;
pub type GstBus_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstElementFactory {
    _unused: [u8; 0],
}
#[doc = " GstElementFactory:\n\n The opaque #GstElementFactory data structure."]
pub type GstElementFactory = _GstElementFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstElementFactoryClass {
    _unused: [u8; 0],
}
pub type GstElementFactoryClass = _GstElementFactoryClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPlugin {
    _unused: [u8; 0],
}
#[doc = " GstPlugin:\n\n The opaque plugin object"]
pub type GstPlugin = _GstPlugin;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPluginClass {
    _unused: [u8; 0],
}
pub type GstPluginClass = _GstPluginClass;
#[doc = " GstPluginDesc:\n @major_version: the major version number of core that plugin was compiled for\n @minor_version: the minor version number of core that plugin was compiled for\n @name: a unique name of the plugin\n @description: description of plugin\n @plugin_init: pointer to the init function of this plugin.\n @version: version of the plugin\n @license: effective license of plugin\n @source: source module plugin belongs to\n @package: shipped package plugin belongs to\n @origin: URL to provider of plugin\n @release_datetime: (allow-none): date time string in ISO 8601\n     format (or rather, a subset thereof), or %NULL. Allowed are the\n     following formats: \"YYYY-MM-DD\" and \"YYY-MM-DDTHH:MMZ\" (with\n     'T' a separator and 'Z' indicating UTC/Zulu time). This field\n     should be set via the GST_PACKAGE_RELEASE_DATETIME\n     preprocessor macro.\n\n A plugin should export a variable of this type called plugin_desc. The plugin\n loader will use the data provided there to initialize the plugin.\n\n The @licence parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL,\n BSD, MIT/X11, Proprietary, unknown."]
pub type GstPluginDesc = _GstPluginDesc;
unsafe extern "C" {
    #[doc = " gst_plugin_error_quark:\n\n Get the error quark.\n\n Returns: The error quark used in GError messages"]
    pub fn gst_plugin_error_quark() -> GQuark;
}
pub const GstPluginError_GST_PLUGIN_ERROR_MODULE: GstPluginError = 0;
pub const GstPluginError_GST_PLUGIN_ERROR_DEPENDENCIES: GstPluginError = 1;
pub const GstPluginError_GST_PLUGIN_ERROR_NAME_MISMATCH: GstPluginError = 2;
#[doc = " GstPluginError:\n @GST_PLUGIN_ERROR_MODULE: The plugin could not be loaded\n @GST_PLUGIN_ERROR_DEPENDENCIES: The plugin has unresolved dependencies\n @GST_PLUGIN_ERROR_NAME_MISMATCH: The plugin has already be loaded from a different file\n\n The plugin loading errors"]
pub type GstPluginError = ::std::os::raw::c_uint;
pub const GstPluginFlags_GST_PLUGIN_FLAG_CACHED: GstPluginFlags = 16;
pub const GstPluginFlags_GST_PLUGIN_FLAG_BLACKLISTED: GstPluginFlags = 32;
#[doc = " GstPluginFlags:\n @GST_PLUGIN_FLAG_CACHED: Temporarily loaded plugins\n @GST_PLUGIN_FLAG_BLACKLISTED: The plugin won't be scanned (again)\n\n The plugin loading state"]
pub type GstPluginFlags = ::std::os::raw::c_uint;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_NONE: GstPluginDependencyFlags = 0;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_RECURSE: GstPluginDependencyFlags = 1;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY:
    GstPluginDependencyFlags = 2;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX:
    GstPluginDependencyFlags = 4;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX:
    GstPluginDependencyFlags = 8;
pub const GstPluginDependencyFlags_GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE:
    GstPluginDependencyFlags = 16;
#[doc = " GstPluginDependencyFlags:\n @GST_PLUGIN_DEPENDENCY_FLAG_NONE : no special flags\n @GST_PLUGIN_DEPENDENCY_FLAG_RECURSE : recurse into subdirectories\n @GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY : use paths\n         argument only if none of the environment variables is set\n @GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX : interpret\n         filename argument as filter suffix and check all matching files in\n         the directory\n @GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX : interpret\n         filename argument as filter prefix and check all matching files in\n         the directory. Since: 1.8.\n @GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE : interpret\n   non-absolute paths as relative to the main executable directory. Since\n   1.14.\n\n Flags used in connection with gst_plugin_add_dependency()."]
pub type GstPluginDependencyFlags = ::std::os::raw::c_uint;
#[doc = " GstPluginInitFunc:\n @plugin: The plugin object\n\n A plugin should provide a pointer to a function of this type in the\n plugin_desc struct.\n This function will be called by the loader at startup. One would then\n register each #GstPluginFeature.\n\n Returns: %TRUE if plugin initialised successfully"]
pub type GstPluginInitFunc =
    ::std::option::Option<unsafe extern "C" fn(plugin: *mut GstPlugin) -> gboolean>;
#[doc = " GstPluginInitFullFunc:\n @plugin: The plugin object\n @user_data: extra data\n\n A plugin should provide a pointer to a function of either #GstPluginInitFunc\n or this type in the plugin_desc struct.\n The function will be called by the loader at startup. One would then\n register each #GstPluginFeature. This version allows\n user data to be passed to init function (useful for bindings).\n\n Returns: %TRUE if plugin initialised successfully"]
pub type GstPluginInitFullFunc = ::std::option::Option<
    unsafe extern "C" fn(plugin: *mut GstPlugin, user_data: gpointer) -> gboolean,
>;
#[doc = " GstPluginDesc:\n @major_version: the major version number of core that plugin was compiled for\n @minor_version: the minor version number of core that plugin was compiled for\n @name: a unique name of the plugin\n @description: description of plugin\n @plugin_init: pointer to the init function of this plugin.\n @version: version of the plugin\n @license: effective license of plugin\n @source: source module plugin belongs to\n @package: shipped package plugin belongs to\n @origin: URL to provider of plugin\n @release_datetime: (allow-none): date time string in ISO 8601\n     format (or rather, a subset thereof), or %NULL. Allowed are the\n     following formats: \"YYYY-MM-DD\" and \"YYY-MM-DDTHH:MMZ\" (with\n     'T' a separator and 'Z' indicating UTC/Zulu time). This field\n     should be set via the GST_PACKAGE_RELEASE_DATETIME\n     preprocessor macro.\n\n A plugin should export a variable of this type called plugin_desc. The plugin\n loader will use the data provided there to initialize the plugin.\n\n The @licence parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL,\n BSD, MIT/X11, Proprietary, unknown."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPluginDesc {
    pub major_version: gint,
    pub minor_version: gint,
    pub name: *const gchar,
    pub description: *const gchar,
    pub plugin_init: GstPluginInitFunc,
    pub version: *const gchar,
    pub license: *const gchar,
    pub source: *const gchar,
    pub package: *const gchar,
    pub origin: *const gchar,
    pub release_datetime: *const gchar,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPluginDesc"][::std::mem::size_of::<_GstPluginDesc>() - 112usize];
    ["Alignment of _GstPluginDesc"][::std::mem::align_of::<_GstPluginDesc>() - 8usize];
    ["Offset of field: _GstPluginDesc::major_version"]
        [::std::mem::offset_of!(_GstPluginDesc, major_version) - 0usize];
    ["Offset of field: _GstPluginDesc::minor_version"]
        [::std::mem::offset_of!(_GstPluginDesc, minor_version) - 4usize];
    ["Offset of field: _GstPluginDesc::name"]
        [::std::mem::offset_of!(_GstPluginDesc, name) - 8usize];
    ["Offset of field: _GstPluginDesc::description"]
        [::std::mem::offset_of!(_GstPluginDesc, description) - 16usize];
    ["Offset of field: _GstPluginDesc::plugin_init"]
        [::std::mem::offset_of!(_GstPluginDesc, plugin_init) - 24usize];
    ["Offset of field: _GstPluginDesc::version"]
        [::std::mem::offset_of!(_GstPluginDesc, version) - 32usize];
    ["Offset of field: _GstPluginDesc::license"]
        [::std::mem::offset_of!(_GstPluginDesc, license) - 40usize];
    ["Offset of field: _GstPluginDesc::source"]
        [::std::mem::offset_of!(_GstPluginDesc, source) - 48usize];
    ["Offset of field: _GstPluginDesc::package"]
        [::std::mem::offset_of!(_GstPluginDesc, package) - 56usize];
    ["Offset of field: _GstPluginDesc::origin"]
        [::std::mem::offset_of!(_GstPluginDesc, origin) - 64usize];
    ["Offset of field: _GstPluginDesc::release_datetime"]
        [::std::mem::offset_of!(_GstPluginDesc, release_datetime) - 72usize];
    ["Offset of field: _GstPluginDesc::_gst_reserved"]
        [::std::mem::offset_of!(_GstPluginDesc, _gst_reserved) - 80usize];
};
#[doc = " GstPluginFilter:\n @plugin: the plugin to check\n @user_data: the user_data that has been passed on e.g. gst_registry_plugin_filter()\n\n A function that can be used with e.g. gst_registry_plugin_filter()\n to get a list of plugins that match certain criteria.\n\n Returns: %TRUE for a positive match, %FALSE otherwise"]
pub type GstPluginFilter = ::std::option::Option<
    unsafe extern "C" fn(plugin: *mut GstPlugin, user_data: gpointer) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_plugin_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_register_static(
        major_version: gint,
        minor_version: gint,
        name: *const gchar,
        description: *const gchar,
        init_func: GstPluginInitFunc,
        version: *const gchar,
        license: *const gchar,
        source: *const gchar,
        package: *const gchar,
        origin: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_plugin_register_static_full(
        major_version: gint,
        minor_version: gint,
        name: *const gchar,
        description: *const gchar,
        init_full_func: GstPluginInitFullFunc,
        version: *const gchar,
        license: *const gchar,
        source: *const gchar,
        package: *const gchar,
        origin: *const gchar,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_plugin_get_name(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_description(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_filename(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_version(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_license(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_source(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_package(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_origin(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_release_date_string(plugin: *mut GstPlugin) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_get_cache_data(plugin: *mut GstPlugin) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_plugin_set_cache_data(plugin: *mut GstPlugin, cache_data: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_plugin_is_loaded(plugin: *mut GstPlugin) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_plugin_load_file(filename: *const gchar, error: *mut *mut GError) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_plugin_load(plugin: *mut GstPlugin) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_plugin_load_by_name(name: *const gchar) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_plugin_add_dependency(
        plugin: *mut GstPlugin,
        env_vars: *mut *const gchar,
        paths: *mut *const gchar,
        names: *mut *const gchar,
        flags: GstPluginDependencyFlags,
    );
}
unsafe extern "C" {
    pub fn gst_plugin_add_dependency_simple(
        plugin: *mut GstPlugin,
        env_vars: *const gchar,
        paths: *const gchar,
        names: *const gchar,
        flags: GstPluginDependencyFlags,
    );
}
unsafe extern "C" {
    pub fn gst_plugin_list_free(list: *mut GList);
}
pub type GstPlugin_autoptr = *mut GstPlugin;
pub type GstPlugin_listautoptr = *mut GList;
pub type GstPlugin_slistautoptr = *mut GSList;
pub type GstPlugin_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPluginFeature {
    _unused: [u8; 0],
}
#[doc = " GstPluginFeature:\n\n Opaque #GstPluginFeature structure."]
pub type GstPluginFeature = _GstPluginFeature;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPluginFeatureClass {
    _unused: [u8; 0],
}
pub type GstPluginFeatureClass = _GstPluginFeatureClass;
pub const GstRank_GST_RANK_NONE: GstRank = 0;
pub const GstRank_GST_RANK_MARGINAL: GstRank = 64;
pub const GstRank_GST_RANK_SECONDARY: GstRank = 128;
pub const GstRank_GST_RANK_PRIMARY: GstRank = 256;
#[doc = " GstRank:\n @GST_RANK_NONE: will be chosen last or not at all\n @GST_RANK_MARGINAL: unlikely to be chosen\n @GST_RANK_SECONDARY: likely to be chosen\n @GST_RANK_PRIMARY: will be chosen first\n\n Element priority ranks. Defines the order in which the autoplugger (or\n similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())\n will choose this element over an alternative one with the same function.\n\n These constants serve as a rough guidance for defining the rank of a\n #GstPluginFeature. Any value is valid, including values bigger than\n @GST_RANK_PRIMARY."]
pub type GstRank = ::std::os::raw::c_uint;
#[doc = " GstPluginFeatureFilter:\n @feature: the pluginfeature to check\n @user_data: the user_data that has been passed on e.g.\n  gst_registry_feature_filter()\n\n A function that can be used with e.g. gst_registry_feature_filter()\n to get a list of pluginfeature that match certain criteria.\n\n Returns: %TRUE for a positive match, %FALSE otherwise"]
pub type GstPluginFeatureFilter = ::std::option::Option<
    unsafe extern "C" fn(feature: *mut GstPluginFeature, user_data: gpointer) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_plugin_feature_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_load(feature: *mut GstPluginFeature) -> *mut GstPluginFeature;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_set_rank(feature: *mut GstPluginFeature, rank: guint);
}
unsafe extern "C" {
    pub fn gst_plugin_feature_get_rank(feature: *mut GstPluginFeature) -> guint;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_get_plugin(feature: *mut GstPluginFeature) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_get_plugin_name(feature: *mut GstPluginFeature) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_list_free(list: *mut GList);
}
unsafe extern "C" {
    pub fn gst_plugin_feature_list_copy(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_list_debug(list: *mut GList);
}
unsafe extern "C" {
    pub fn gst_plugin_feature_check_version(
        feature: *mut GstPluginFeature,
        min_major: guint,
        min_minor: guint,
        min_micro: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_plugin_feature_rank_compare_func(p1: gconstpointer, p2: gconstpointer) -> gint;
}
pub type GstPluginFeature_autoptr = *mut GstPluginFeature;
pub type GstPluginFeature_listautoptr = *mut GList;
pub type GstPluginFeature_slistautoptr = *mut GSList;
pub type GstPluginFeature_queueautoptr = *mut GQueue;
unsafe extern "C" {
    #[doc = " gst_uri_error_quark: (attributes doc.skip=true)"]
    pub fn gst_uri_error_quark() -> GQuark;
}
pub const GstURIError_GST_URI_ERROR_UNSUPPORTED_PROTOCOL: GstURIError = 0;
pub const GstURIError_GST_URI_ERROR_BAD_URI: GstURIError = 1;
pub const GstURIError_GST_URI_ERROR_BAD_STATE: GstURIError = 2;
pub const GstURIError_GST_URI_ERROR_BAD_REFERENCE: GstURIError = 3;
#[doc = " GstURIError:\n @GST_URI_ERROR_UNSUPPORTED_PROTOCOL: The protocol is not supported\n @GST_URI_ERROR_BAD_URI: There was a problem with the URI\n @GST_URI_ERROR_BAD_STATE: Could not set or change the URI because the\n     URI handler was in a state where that is not possible or not permitted\n @GST_URI_ERROR_BAD_REFERENCE: There was a problem with the entity that\n     the URI references\n\n Different URI-related errors that can occur."]
pub type GstURIError = ::std::os::raw::c_uint;
pub const GstURIType_GST_URI_UNKNOWN: GstURIType = 0;
pub const GstURIType_GST_URI_SINK: GstURIType = 1;
pub const GstURIType_GST_URI_SRC: GstURIType = 2;
#[doc = " GstURIType:\n @GST_URI_UNKNOWN: The URI direction is unknown\n @GST_URI_SINK: The URI is a consumer.\n @GST_URI_SRC: The URI is a producer.\n\n The different types of URI direction."]
pub type GstURIType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstURIHandler {
    _unused: [u8; 0],
}
#[doc = " GstURIHandler:\n\n Opaque #GstURIHandler structure."]
pub type GstURIHandler = _GstURIHandler;
#[doc = " GstURIHandlerInterface:\n @parent: The parent interface type\n @get_type: Method to tell whether the element handles source or sink URI.\n @get_protocols: Method to return the list of protocols handled by the element.\n @get_uri: Method to return the URI currently handled by the element.\n @set_uri: Method to set a new URI.\n\n Any #GstElement using this interface should implement these methods."]
pub type GstURIHandlerInterface = _GstURIHandlerInterface;
#[doc = " GstURIHandlerInterface:\n @parent: The parent interface type\n @get_type: Method to tell whether the element handles source or sink URI.\n @get_protocols: Method to return the list of protocols handled by the element.\n @get_uri: Method to return the URI currently handled by the element.\n @set_uri: Method to set a new URI.\n\n Any #GstElement using this interface should implement these methods."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstURIHandlerInterface {
    pub parent: GTypeInterface,
    pub get_type: ::std::option::Option<unsafe extern "C" fn(type_: GType) -> GstURIType>,
    pub get_protocols:
        ::std::option::Option<unsafe extern "C" fn(type_: GType) -> *const *const gchar>,
    pub get_uri:
        ::std::option::Option<unsafe extern "C" fn(handler: *mut GstURIHandler) -> *mut gchar>,
    pub set_uri: ::std::option::Option<
        unsafe extern "C" fn(
            handler: *mut GstURIHandler,
            uri: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstURIHandlerInterface"][::std::mem::size_of::<_GstURIHandlerInterface>() - 48usize];
    ["Alignment of _GstURIHandlerInterface"]
        [::std::mem::align_of::<_GstURIHandlerInterface>() - 8usize];
    ["Offset of field: _GstURIHandlerInterface::parent"]
        [::std::mem::offset_of!(_GstURIHandlerInterface, parent) - 0usize];
    ["Offset of field: _GstURIHandlerInterface::get_type"]
        [::std::mem::offset_of!(_GstURIHandlerInterface, get_type) - 16usize];
    ["Offset of field: _GstURIHandlerInterface::get_protocols"]
        [::std::mem::offset_of!(_GstURIHandlerInterface, get_protocols) - 24usize];
    ["Offset of field: _GstURIHandlerInterface::get_uri"]
        [::std::mem::offset_of!(_GstURIHandlerInterface, get_uri) - 32usize];
    ["Offset of field: _GstURIHandlerInterface::set_uri"]
        [::std::mem::offset_of!(_GstURIHandlerInterface, set_uri) - 40usize];
};
unsafe extern "C" {
    pub fn gst_uri_protocol_is_valid(protocol: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_protocol_is_supported(type_: GstURIType, protocol: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_is_valid(uri: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_protocol(uri: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_has_protocol(uri: *const gchar, protocol: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_location(uri: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_construct(protocol: *const gchar, location: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_filename_to_uri(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_element_make_from_uri(
        type_: GstURIType,
        uri: *const gchar,
        elementname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_uri_handler_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_uri_handler_get_uri_type(handler: *mut GstURIHandler) -> GstURIType;
}
unsafe extern "C" {
    pub fn gst_uri_handler_get_protocols(handler: *mut GstURIHandler) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_handler_get_uri(handler: *mut GstURIHandler) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_handler_set_uri(
        handler: *mut GstURIHandler,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GstUri:\n\n This is a private structure that holds the various parts of a parsed URI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstUri {
    _unused: [u8; 0],
}
pub type GstUri = _GstUri;
unsafe extern "C" {
    pub fn gst_uri_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_uri_new(
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: guint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_new_with_base(
        base: *mut GstUri,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: guint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_from_string(uri: *const gchar) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_from_string_escaped(uri: *const gchar) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_from_string_with_base(base: *mut GstUri, uri: *const gchar) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_equal(first: *const GstUri, second: *const GstUri) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_join(base_uri: *mut GstUri, ref_uri: *mut GstUri) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_join_strings(base_uri: *const gchar, ref_uri: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_is_writable(uri: *const GstUri) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_make_writable(uri: *mut GstUri) -> *mut GstUri;
}
unsafe extern "C" {
    pub fn gst_uri_to_string(uri: *const GstUri) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_is_normalized(uri: *const GstUri) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_normalize(uri: *mut GstUri) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_scheme(uri: *const GstUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_scheme(uri: *mut GstUri, scheme: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_userinfo(uri: *const GstUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_userinfo(uri: *mut GstUri, userinfo: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_host(uri: *const GstUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_host(uri: *mut GstUri, host: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_port(uri: *const GstUri) -> guint;
}
unsafe extern "C" {
    pub fn gst_uri_set_port(uri: *mut GstUri, port: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_path(uri: *const GstUri) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_path(uri: *mut GstUri, path: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_path_string(uri: *const GstUri) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_path_string(uri: *mut GstUri, path: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_path_segments(uri: *const GstUri) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_uri_set_path_segments(uri: *mut GstUri, path_segments: *mut GList) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_append_path(uri: *mut GstUri, relative_path: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_append_path_segment(uri: *mut GstUri, path_segment: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_query_string(uri: *const GstUri) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_query_string(uri: *mut GstUri, query: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_query_table(uri: *const GstUri) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn gst_uri_set_query_table(uri: *mut GstUri, query_table: *mut GHashTable) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_set_query_value(
        uri: *mut GstUri,
        query_key: *const gchar,
        query_value: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_remove_query_key(uri: *mut GstUri, query_key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_query_has_key(uri: *const GstUri, query_key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_query_value(uri: *const GstUri, query_key: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_get_query_keys(uri: *const GstUri) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_uri_get_fragment(uri: *const GstUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_uri_set_fragment(uri: *mut GstUri, fragment: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_uri_get_media_fragment_table(uri: *const GstUri) -> *mut GHashTable;
}
pub type GstUri_autoptr = *mut GstUri;
pub type GstUri_listautoptr = *mut GList;
pub type GstUri_slistautoptr = *mut GSList;
pub type GstUri_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_element_factory_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_element_factory_find(name: *const gchar) -> *mut GstElementFactory;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_element_type(factory: *mut GstElementFactory) -> GType;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_metadata(
        factory: *mut GstElementFactory,
        key: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_metadata_keys(
        factory: *mut GstElementFactory,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_num_pad_templates(factory: *mut GstElementFactory) -> guint;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_static_pad_templates(
        factory: *mut GstElementFactory,
    ) -> *const GList;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_uri_type(factory: *mut GstElementFactory) -> GstURIType;
}
unsafe extern "C" {
    pub fn gst_element_factory_get_uri_protocols(
        factory: *mut GstElementFactory,
    ) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn gst_element_factory_has_interface(
        factory: *mut GstElementFactory,
        interfacename: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_create(
        factory: *mut GstElementFactory,
        name: *const gchar,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_create_full(
        factory: *mut GstElementFactory,
        first: *const gchar,
        ...
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_create_valist(
        factory: *mut GstElementFactory,
        first: *const gchar,
        properties: *mut __va_list_tag,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_create_with_properties(
        factory: *mut GstElementFactory,
        n: guint,
        names: *mut *const gchar,
        values: *const GValue,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_make(
        factoryname: *const gchar,
        name: *const gchar,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_make_full(
        factoryname: *const gchar,
        first: *const gchar,
        ...
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_make_valist(
        factoryname: *const gchar,
        first: *const gchar,
        properties: *mut __va_list_tag,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_factory_make_with_properties(
        factoryname: *const gchar,
        n: guint,
        names: *mut *const gchar,
        values: *const GValue,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_element_register(
        plugin: *mut GstPlugin,
        name: *const gchar,
        rank: guint,
        type_: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_type_set_skip_documentation(type_: GType);
}
unsafe extern "C" {
    pub fn gst_element_factory_get_skip_documentation(factory: *mut GstElementFactory) -> gboolean;
}
#[doc = " GstElementFactoryListType:\n\n A type defining the type of an element factory."]
pub type GstElementFactoryListType = guint64;
unsafe extern "C" {
    pub fn gst_element_factory_list_is_type(
        factory: *mut GstElementFactory,
        type_: GstElementFactoryListType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_list_get_elements(
        type_: GstElementFactoryListType,
        minrank: GstRank,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_element_factory_list_filter(
        list: *mut GList,
        caps: *const GstCaps,
        direction: GstPadDirection,
        subsetonly: gboolean,
    ) -> *mut GList;
}
pub type GstElementFactory_autoptr = *mut GstElementFactory;
pub type GstElementFactory_listautoptr = *mut GList;
pub type GstElementFactory_slistautoptr = *mut GSList;
pub type GstElementFactory_queueautoptr = *mut GQueue;
pub const GstStateChange_GST_STATE_CHANGE_NULL_TO_READY: GstStateChange = 10;
pub const GstStateChange_GST_STATE_CHANGE_READY_TO_PAUSED: GstStateChange = 19;
pub const GstStateChange_GST_STATE_CHANGE_PAUSED_TO_PLAYING: GstStateChange = 28;
pub const GstStateChange_GST_STATE_CHANGE_PLAYING_TO_PAUSED: GstStateChange = 35;
pub const GstStateChange_GST_STATE_CHANGE_PAUSED_TO_READY: GstStateChange = 26;
pub const GstStateChange_GST_STATE_CHANGE_READY_TO_NULL: GstStateChange = 17;
pub const GstStateChange_GST_STATE_CHANGE_NULL_TO_NULL: GstStateChange = 9;
pub const GstStateChange_GST_STATE_CHANGE_READY_TO_READY: GstStateChange = 18;
pub const GstStateChange_GST_STATE_CHANGE_PAUSED_TO_PAUSED: GstStateChange = 27;
pub const GstStateChange_GST_STATE_CHANGE_PLAYING_TO_PLAYING: GstStateChange = 36;
#[doc = " GstStateChange:\n @GST_STATE_CHANGE_NULL_TO_READY    : state change from NULL to READY.\n   * The element must check if the resources it needs are available. Device\n     sinks and -sources typically try to probe the device to constrain their\n     caps.\n   * The element opens the device (in case feature need to be probed).\n @GST_STATE_CHANGE_READY_TO_PAUSED  : state change from READY to PAUSED.\n   * The element pads are activated in order to receive data in PAUSED.\n     Streaming threads are started.\n   * Some elements might need to return %GST_STATE_CHANGE_ASYNC and complete\n     the state change when they have enough information. It is a requirement\n     for sinks to return %GST_STATE_CHANGE_ASYNC and complete the state change\n     when they receive the first buffer or %GST_EVENT_EOS (preroll).\n     Sinks also block the dataflow when in PAUSED.\n   * A pipeline resets the running_time to 0.\n   * Live sources return %GST_STATE_CHANGE_NO_PREROLL and don't generate data.\n @GST_STATE_CHANGE_PAUSED_TO_PLAYING: state change from PAUSED to PLAYING.\n   * Most elements ignore this state change.\n   * The pipeline selects a #GstClock and distributes this to all the children\n     before setting them to PLAYING. This means that it is only allowed to\n     synchronize on the #GstClock in the PLAYING state.\n   * The pipeline uses the #GstClock and the running_time to calculate the\n     base_time. The base_time is distributed to all children when performing\n     the state change.\n   * Sink elements stop blocking on the preroll buffer or event and start\n     rendering the data.\n   * Sinks can post %GST_MESSAGE_EOS in the PLAYING state. It is not allowed\n     to post %GST_MESSAGE_EOS when not in the PLAYING state.\n   * While streaming in PAUSED or PLAYING elements can create and remove\n     sometimes pads.\n   * Live sources start generating data and return %GST_STATE_CHANGE_SUCCESS.\n @GST_STATE_CHANGE_PLAYING_TO_PAUSED: state change from PLAYING to PAUSED.\n   * Most elements ignore this state change.\n   * The pipeline calculates the running_time based on the last selected\n     #GstClock and the base_time. It stores this information to continue\n     playback when going back to the PLAYING state.\n   * Sinks unblock any #GstClock wait calls.\n   * When a sink does not have a pending buffer to play, it returns\n     #GST_STATE_CHANGE_ASYNC from this state change and completes the state\n     change when it receives a new buffer or an %GST_EVENT_EOS.\n   * Any queued %GST_MESSAGE_EOS items are removed since they will be reposted\n     when going back to the PLAYING state. The EOS messages are queued in\n     #GstBin containers.\n   * Live sources stop generating data and return %GST_STATE_CHANGE_NO_PREROLL.\n @GST_STATE_CHANGE_PAUSED_TO_READY  : state change from PAUSED to READY.\n   * Sinks unblock any waits in the preroll.\n   * Elements unblock any waits on devices\n   * Chain or get_range functions return %GST_FLOW_FLUSHING.\n   * The element pads are deactivated so that streaming becomes impossible and\n     all streaming threads are stopped.\n   * The sink forgets all negotiated formats\n   * Elements remove all sometimes pads\n @GST_STATE_CHANGE_READY_TO_NULL    : state change from READY to NULL.\n   * Elements close devices\n   * Elements reset any internal state.\n @GST_STATE_CHANGE_NULL_TO_NULL       : state change from NULL to NULL. (Since: 1.14)\n @GST_STATE_CHANGE_READY_TO_READY     : state change from READY to READY,\n This might happen when going to PAUSED asynchronously failed, in that case\n elements should make sure they are in a proper, coherent READY state. (Since: 1.14)\n @GST_STATE_CHANGE_PAUSED_TO_PAUSED   : state change from PAUSED to PAUSED.\n This might happen when elements were in PLAYING state and 'lost state',\n they should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)\n @GST_STATE_CHANGE_PLAYING_TO_PLAYING : state change from PLAYING to PLAYING. (Since: 1.14)\n\n These are the different state changes an element goes through.\n %GST_STATE_NULL &rArr; %GST_STATE_PLAYING is called an upwards state change\n and %GST_STATE_PLAYING &rArr; %GST_STATE_NULL a downwards state change."]
pub type GstStateChange = ::std::os::raw::c_uint;
pub const GstElementFlags_GST_ELEMENT_FLAG_LOCKED_STATE: GstElementFlags = 16;
pub const GstElementFlags_GST_ELEMENT_FLAG_SINK: GstElementFlags = 32;
pub const GstElementFlags_GST_ELEMENT_FLAG_SOURCE: GstElementFlags = 64;
pub const GstElementFlags_GST_ELEMENT_FLAG_PROVIDE_CLOCK: GstElementFlags = 128;
pub const GstElementFlags_GST_ELEMENT_FLAG_REQUIRE_CLOCK: GstElementFlags = 256;
pub const GstElementFlags_GST_ELEMENT_FLAG_INDEXABLE: GstElementFlags = 512;
pub const GstElementFlags_GST_ELEMENT_FLAG_LAST: GstElementFlags = 16384;
#[doc = " GstElementFlags:\n @GST_ELEMENT_FLAG_LOCKED_STATE: ignore state changes from parent\n @GST_ELEMENT_FLAG_SINK: the element is a sink\n @GST_ELEMENT_FLAG_SOURCE: the element is a source.\n @GST_ELEMENT_FLAG_PROVIDE_CLOCK: the element can provide a clock\n @GST_ELEMENT_FLAG_REQUIRE_CLOCK: the element requires a clock\n @GST_ELEMENT_FLAG_INDEXABLE: the element can use an index\n @GST_ELEMENT_FLAG_LAST: offset to define more flags\n\n The standard flags that an element may have."]
pub type GstElementFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_make_element_message_details(
        name: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GstStructure;
}
#[doc = " GstElement:\n @state_lock: Used to serialize execution of gst_element_set_state()\n @state_cond: Used to signal completion of a state change\n @state_cookie: Used to detect concurrent execution of\n gst_element_set_state() and gst_element_get_state()\n @target_state: the target state of an element as set by the application\n @current_state: the current state of an element\n @next_state: the next state of an element, can be #GST_STATE_VOID_PENDING if\n the element is in the correct state.\n @pending_state: the final state the element should go to, can be\n #GST_STATE_VOID_PENDING if the element is in the correct state\n @last_return: the last return value of an element state change\n @bus: the bus of the element. This bus is provided to the element by the\n parent element or the application. A #GstPipeline has a bus of its own.\n @clock: the clock of the element. This clock is usually provided to the\n element by the toplevel #GstPipeline.\n @base_time: the time of the clock right before the element is set to\n PLAYING. Subtracting @base_time from the current clock time in the PLAYING\n state will yield the running_time against the clock.\n @start_time: the running_time of the last PAUSED state\n @numpads: number of pads of the element, includes both source and sink pads.\n @pads: (element-type Gst.Pad): list of pads\n @numsrcpads: number of source pads of the element.\n @srcpads: (element-type Gst.Pad): list of source pads\n @numsinkpads: number of sink pads of the element.\n @sinkpads: (element-type Gst.Pad): list of sink pads\n @pads_cookie: updated whenever the a pad is added or removed\n @contexts: (element-type Gst.Context): list of contexts\n\n GStreamer element abstract base class."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstElement {
    pub object: GstObject,
    pub state_lock: GRecMutex,
    pub state_cond: GCond,
    pub state_cookie: guint32,
    pub target_state: GstState,
    pub current_state: GstState,
    pub next_state: GstState,
    pub pending_state: GstState,
    pub last_return: GstStateChangeReturn,
    pub bus: *mut GstBus,
    pub clock: *mut GstClock,
    pub base_time: GstClockTimeDiff,
    pub start_time: GstClockTime,
    pub numpads: guint16,
    pub pads: *mut GList,
    pub numsrcpads: guint16,
    pub srcpads: *mut GList,
    pub numsinkpads: guint16,
    pub sinkpads: *mut GList,
    pub pads_cookie: guint32,
    pub contexts: *mut GList,
    pub _gst_reserved: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstElement"][::std::mem::size_of::<_GstElement>() - 264usize];
    ["Alignment of _GstElement"][::std::mem::align_of::<_GstElement>() - 8usize];
    ["Offset of field: _GstElement::object"][::std::mem::offset_of!(_GstElement, object) - 0usize];
    ["Offset of field: _GstElement::state_lock"]
        [::std::mem::offset_of!(_GstElement, state_lock) - 88usize];
    ["Offset of field: _GstElement::state_cond"]
        [::std::mem::offset_of!(_GstElement, state_cond) - 104usize];
    ["Offset of field: _GstElement::state_cookie"]
        [::std::mem::offset_of!(_GstElement, state_cookie) - 120usize];
    ["Offset of field: _GstElement::target_state"]
        [::std::mem::offset_of!(_GstElement, target_state) - 124usize];
    ["Offset of field: _GstElement::current_state"]
        [::std::mem::offset_of!(_GstElement, current_state) - 128usize];
    ["Offset of field: _GstElement::next_state"]
        [::std::mem::offset_of!(_GstElement, next_state) - 132usize];
    ["Offset of field: _GstElement::pending_state"]
        [::std::mem::offset_of!(_GstElement, pending_state) - 136usize];
    ["Offset of field: _GstElement::last_return"]
        [::std::mem::offset_of!(_GstElement, last_return) - 140usize];
    ["Offset of field: _GstElement::bus"][::std::mem::offset_of!(_GstElement, bus) - 144usize];
    ["Offset of field: _GstElement::clock"][::std::mem::offset_of!(_GstElement, clock) - 152usize];
    ["Offset of field: _GstElement::base_time"]
        [::std::mem::offset_of!(_GstElement, base_time) - 160usize];
    ["Offset of field: _GstElement::start_time"]
        [::std::mem::offset_of!(_GstElement, start_time) - 168usize];
    ["Offset of field: _GstElement::numpads"]
        [::std::mem::offset_of!(_GstElement, numpads) - 176usize];
    ["Offset of field: _GstElement::pads"][::std::mem::offset_of!(_GstElement, pads) - 184usize];
    ["Offset of field: _GstElement::numsrcpads"]
        [::std::mem::offset_of!(_GstElement, numsrcpads) - 192usize];
    ["Offset of field: _GstElement::srcpads"]
        [::std::mem::offset_of!(_GstElement, srcpads) - 200usize];
    ["Offset of field: _GstElement::numsinkpads"]
        [::std::mem::offset_of!(_GstElement, numsinkpads) - 208usize];
    ["Offset of field: _GstElement::sinkpads"]
        [::std::mem::offset_of!(_GstElement, sinkpads) - 216usize];
    ["Offset of field: _GstElement::pads_cookie"]
        [::std::mem::offset_of!(_GstElement, pads_cookie) - 224usize];
    ["Offset of field: _GstElement::contexts"]
        [::std::mem::offset_of!(_GstElement, contexts) - 232usize];
    ["Offset of field: _GstElement::_gst_reserved"]
        [::std::mem::offset_of!(_GstElement, _gst_reserved) - 240usize];
};
#[doc = " GstElementClass:\n @parent_class: the parent class structure\n @metadata: metadata for elements of this class\n @elementfactory: the #GstElementFactory that creates these elements\n @padtemplates: a #GList of #GstPadTemplate\n @numpadtemplates: the number of padtemplates\n @pad_templ_cookie: changed whenever the padtemplates change\n @request_new_pad: called when a new pad is requested\n @release_pad: called when a request pad is to be released\n @get_state: get the state of the element\n @set_state: set a new state on the element\n @change_state: called by @set_state to perform an incremental state change\n @set_bus: set a #GstBus on the element\n @provide_clock: gets the #GstClock provided by the element\n @set_clock: set the #GstClock on the element\n @send_event: send a #GstEvent to the element\n @query: perform a #GstQuery on the element\n @state_changed: called immediately after a new state was set.\n @post_message: called when a message is posted on the element. Chain up to\n                the parent class' handler to have it posted on the bus.\n @set_context: set a #GstContext on the element\n\n GStreamer element class. Override the vmethods to implement the element\n functionality."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstElementClass {
    pub parent_class: GstObjectClass,
    pub metadata: gpointer,
    pub elementfactory: *mut GstElementFactory,
    pub padtemplates: *mut GList,
    pub numpadtemplates: gint,
    pub pad_templ_cookie: guint32,
    pub pad_added:
        ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement, pad: *mut GstPad)>,
    pub pad_removed:
        ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement, pad: *mut GstPad)>,
    pub no_more_pads: ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement)>,
    pub request_new_pad: ::std::option::Option<
        unsafe extern "C" fn(
            element: *mut GstElement,
            templ: *mut GstPadTemplate,
            name: *const gchar,
            caps: *const GstCaps,
        ) -> *mut GstPad,
    >,
    pub release_pad:
        ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement, pad: *mut GstPad)>,
    pub get_state: ::std::option::Option<
        unsafe extern "C" fn(
            element: *mut GstElement,
            state: *mut GstState,
            pending: *mut GstState,
            timeout: GstClockTime,
        ) -> GstStateChangeReturn,
    >,
    pub set_state: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, state: GstState) -> GstStateChangeReturn,
    >,
    pub change_state: ::std::option::Option<
        unsafe extern "C" fn(
            element: *mut GstElement,
            transition: GstStateChange,
        ) -> GstStateChangeReturn,
    >,
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            element: *mut GstElement,
            oldstate: GstState,
            newstate: GstState,
            pending: GstState,
        ),
    >,
    pub set_bus:
        ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement, bus: *mut GstBus)>,
    pub provide_clock:
        ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement) -> *mut GstClock>,
    pub set_clock: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, clock: *mut GstClock) -> gboolean,
    >,
    pub send_event: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, event: *mut GstEvent) -> gboolean,
    >,
    pub query: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, query: *mut GstQuery) -> gboolean,
    >,
    pub post_message: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, message: *mut GstMessage) -> gboolean,
    >,
    pub set_context: ::std::option::Option<
        unsafe extern "C" fn(element: *mut GstElement, context: *mut GstContext),
    >,
    pub _gst_reserved: [gpointer; 18usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstElementClass"][::std::mem::size_of::<_GstElementClass>() - 488usize];
    ["Alignment of _GstElementClass"][::std::mem::align_of::<_GstElementClass>() - 8usize];
    ["Offset of field: _GstElementClass::parent_class"]
        [::std::mem::offset_of!(_GstElementClass, parent_class) - 0usize];
    ["Offset of field: _GstElementClass::metadata"]
        [::std::mem::offset_of!(_GstElementClass, metadata) - 184usize];
    ["Offset of field: _GstElementClass::elementfactory"]
        [::std::mem::offset_of!(_GstElementClass, elementfactory) - 192usize];
    ["Offset of field: _GstElementClass::padtemplates"]
        [::std::mem::offset_of!(_GstElementClass, padtemplates) - 200usize];
    ["Offset of field: _GstElementClass::numpadtemplates"]
        [::std::mem::offset_of!(_GstElementClass, numpadtemplates) - 208usize];
    ["Offset of field: _GstElementClass::pad_templ_cookie"]
        [::std::mem::offset_of!(_GstElementClass, pad_templ_cookie) - 212usize];
    ["Offset of field: _GstElementClass::pad_added"]
        [::std::mem::offset_of!(_GstElementClass, pad_added) - 216usize];
    ["Offset of field: _GstElementClass::pad_removed"]
        [::std::mem::offset_of!(_GstElementClass, pad_removed) - 224usize];
    ["Offset of field: _GstElementClass::no_more_pads"]
        [::std::mem::offset_of!(_GstElementClass, no_more_pads) - 232usize];
    ["Offset of field: _GstElementClass::request_new_pad"]
        [::std::mem::offset_of!(_GstElementClass, request_new_pad) - 240usize];
    ["Offset of field: _GstElementClass::release_pad"]
        [::std::mem::offset_of!(_GstElementClass, release_pad) - 248usize];
    ["Offset of field: _GstElementClass::get_state"]
        [::std::mem::offset_of!(_GstElementClass, get_state) - 256usize];
    ["Offset of field: _GstElementClass::set_state"]
        [::std::mem::offset_of!(_GstElementClass, set_state) - 264usize];
    ["Offset of field: _GstElementClass::change_state"]
        [::std::mem::offset_of!(_GstElementClass, change_state) - 272usize];
    ["Offset of field: _GstElementClass::state_changed"]
        [::std::mem::offset_of!(_GstElementClass, state_changed) - 280usize];
    ["Offset of field: _GstElementClass::set_bus"]
        [::std::mem::offset_of!(_GstElementClass, set_bus) - 288usize];
    ["Offset of field: _GstElementClass::provide_clock"]
        [::std::mem::offset_of!(_GstElementClass, provide_clock) - 296usize];
    ["Offset of field: _GstElementClass::set_clock"]
        [::std::mem::offset_of!(_GstElementClass, set_clock) - 304usize];
    ["Offset of field: _GstElementClass::send_event"]
        [::std::mem::offset_of!(_GstElementClass, send_event) - 312usize];
    ["Offset of field: _GstElementClass::query"]
        [::std::mem::offset_of!(_GstElementClass, query) - 320usize];
    ["Offset of field: _GstElementClass::post_message"]
        [::std::mem::offset_of!(_GstElementClass, post_message) - 328usize];
    ["Offset of field: _GstElementClass::set_context"]
        [::std::mem::offset_of!(_GstElementClass, set_context) - 336usize];
    ["Offset of field: _GstElementClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstElementClass, _gst_reserved) - 344usize];
};
unsafe extern "C" {
    pub fn gst_element_class_add_pad_template(
        klass: *mut GstElementClass,
        templ: *mut GstPadTemplate,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_add_static_pad_template(
        klass: *mut GstElementClass,
        static_templ: *mut GstStaticPadTemplate,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_add_static_pad_template_with_gtype(
        klass: *mut GstElementClass,
        static_templ: *mut GstStaticPadTemplate,
        pad_type: GType,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_get_pad_template(
        element_class: *mut GstElementClass,
        name: *const gchar,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_element_class_get_pad_template_list(
        element_class: *mut GstElementClass,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_element_class_set_metadata(
        klass: *mut GstElementClass,
        longname: *const gchar,
        classification: *const gchar,
        description: *const gchar,
        author: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_set_static_metadata(
        klass: *mut GstElementClass,
        longname: *const gchar,
        classification: *const gchar,
        description: *const gchar,
        author: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_add_metadata(
        klass: *mut GstElementClass,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_add_static_metadata(
        klass: *mut GstElementClass,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_class_get_metadata(
        klass: *mut GstElementClass,
        key: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_element_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_element_provide_clock(element: *mut GstElement) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_element_get_clock(element: *mut GstElement) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_element_set_clock(element: *mut GstElement, clock: *mut GstClock) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_set_base_time(element: *mut GstElement, time: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_element_get_base_time(element: *mut GstElement) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_element_set_start_time(element: *mut GstElement, time: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_element_get_start_time(element: *mut GstElement) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_element_get_current_running_time(element: *mut GstElement) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_element_get_current_clock_time(element: *mut GstElement) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_element_set_bus(element: *mut GstElement, bus: *mut GstBus);
}
unsafe extern "C" {
    pub fn gst_element_get_bus(element: *mut GstElement) -> *mut GstBus;
}
unsafe extern "C" {
    pub fn gst_element_set_context(element: *mut GstElement, context: *mut GstContext);
}
unsafe extern "C" {
    pub fn gst_element_get_contexts(element: *mut GstElement) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_element_get_context(
        element: *mut GstElement,
        context_type: *const gchar,
    ) -> *mut GstContext;
}
unsafe extern "C" {
    pub fn gst_element_get_context_unlocked(
        element: *mut GstElement,
        context_type: *const gchar,
    ) -> *mut GstContext;
}
unsafe extern "C" {
    pub fn gst_element_add_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_remove_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_no_more_pads(element: *mut GstElement);
}
unsafe extern "C" {
    pub fn gst_element_get_static_pad(element: *mut GstElement, name: *const gchar) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_element_get_request_pad(element: *mut GstElement, name: *const gchar)
    -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_element_request_pad_simple(
        element: *mut GstElement,
        name: *const gchar,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_element_request_pad(
        element: *mut GstElement,
        templ: *mut GstPadTemplate,
        name: *const gchar,
        caps: *const GstCaps,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_element_release_request_pad(element: *mut GstElement, pad: *mut GstPad);
}
unsafe extern "C" {
    pub fn gst_element_iterate_pads(element: *mut GstElement) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_element_iterate_src_pads(element: *mut GstElement) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_element_iterate_sink_pads(element: *mut GstElement) -> *mut GstIterator;
}
#[doc = " GstElementForeachPadFunc:\n @element: the #GstElement\n @pad: a #GstPad\n @user_data: user data passed to the foreach function\n\n Function called for each pad when using gst_element_foreach_sink_pad(),\n gst_element_foreach_src_pad(), or gst_element_foreach_pad().\n\n Returns: %FALSE to stop iterating pads, %TRUE to continue\n\n Since: 1.14"]
pub type GstElementForeachPadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        element: *mut GstElement,
        pad: *mut GstPad,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn gst_element_foreach_sink_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_foreach_src_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_foreach_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_send_event(element: *mut GstElement, event: *mut GstEvent) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_seek(
        element: *mut GstElement,
        rate: gdouble,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: gint64,
        stop_type: GstSeekType,
        stop: gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_query(element: *mut GstElement, query: *mut GstQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_post_message(element: *mut GstElement, message: *mut GstMessage)
    -> gboolean;
}
unsafe extern "C" {
    pub fn _gst_element_error_printf(format: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_element_message_full(
        element: *mut GstElement,
        type_: GstMessageType,
        domain: GQuark,
        code: gint,
        text: *mut gchar,
        debug: *mut gchar,
        file: *const gchar,
        function: *const gchar,
        line: gint,
    );
}
unsafe extern "C" {
    pub fn gst_element_message_full_with_details(
        element: *mut GstElement,
        type_: GstMessageType,
        domain: GQuark,
        code: gint,
        text: *mut gchar,
        debug: *mut gchar,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        structure: *mut GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_element_is_locked_state(element: *mut GstElement) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_set_locked_state(
        element: *mut GstElement,
        locked_state: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_sync_state_with_parent(element: *mut GstElement) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_get_state(
        element: *mut GstElement,
        state: *mut GstState,
        pending: *mut GstState,
        timeout: GstClockTime,
    ) -> GstStateChangeReturn;
}
unsafe extern "C" {
    pub fn gst_element_set_state(element: *mut GstElement, state: GstState)
    -> GstStateChangeReturn;
}
unsafe extern "C" {
    pub fn gst_element_abort_state(element: *mut GstElement);
}
unsafe extern "C" {
    pub fn gst_element_change_state(
        element: *mut GstElement,
        transition: GstStateChange,
    ) -> GstStateChangeReturn;
}
unsafe extern "C" {
    pub fn gst_element_continue_state(
        element: *mut GstElement,
        ret: GstStateChangeReturn,
    ) -> GstStateChangeReturn;
}
unsafe extern "C" {
    pub fn gst_element_lost_state(element: *mut GstElement);
}
#[doc = " GstElementCallAsyncFunc:\n @element: The #GstElement this function has been called against\n @user_data: Data passed in the function where that callback has been passed\n\n Callback prototype used in #gst_element_call_async"]
pub type GstElementCallAsyncFunc =
    ::std::option::Option<unsafe extern "C" fn(element: *mut GstElement, user_data: gpointer)>;
unsafe extern "C" {
    pub fn gst_element_call_async(
        element: *mut GstElement,
        func: GstElementCallAsyncFunc,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_element_get_factory(element: *mut GstElement) -> *mut GstElementFactory;
}
unsafe extern "C" {
    pub fn gst_element_add_property_notify_watch(
        element: *mut GstElement,
        property_name: *const gchar,
        include_value: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn gst_element_add_property_deep_notify_watch(
        element: *mut GstElement,
        property_name: *const gchar,
        include_value: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn gst_element_remove_property_notify_watch(element: *mut GstElement, watch_id: gulong);
}
unsafe extern "C" {
    pub fn gst_element_get_pad_template(
        element: *mut GstElement,
        name: *const gchar,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_element_get_pad_template_list(element: *mut GstElement) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_element_get_metadata(element: *mut GstElement, key: *const gchar) -> *const gchar;
}
pub type GstElement_autoptr = *mut GstElement;
pub type GstElement_listautoptr = *mut GList;
pub type GstElement_slistautoptr = *mut GSList;
pub type GstElement_queueautoptr = *mut GQueue;
#[doc = " GST_BIN_FLAG_NO_RESYNC:\n\n Don't resync a state change when elements are added or linked in the bin\n\n Since: 1.0.5"]
pub const GstBinFlags_GST_BIN_FLAG_NO_RESYNC: GstBinFlags = 16384;
#[doc = " GST_BIN_FLAG_STREAMS_AWARE:\n\n Indicates whether the bin can handle elements that add/remove source pads\n at any point in time without first posting a no-more-pads signal.\n\n Since: 1.10"]
pub const GstBinFlags_GST_BIN_FLAG_STREAMS_AWARE: GstBinFlags = 32768;
#[doc = " GST_BIN_FLAG_LAST:\n\n The last enum in the series of flags for bins. Derived classes can use this\n as first value in a list of flags."]
pub const GstBinFlags_GST_BIN_FLAG_LAST: GstBinFlags = 524288;
#[doc = " GstBinFlags:\n @GST_BIN_FLAG_LAST: the last enum in the series of flags for bins.\n Derived classes can use this as first value in a list of flags.\n\n GstBinFlags are a set of flags specific to bins. Most are set/used\n internally. They can be checked using the GST_OBJECT_FLAG_IS_SET() macro,\n and (un)set using GST_OBJECT_FLAG_SET() and GST_OBJECT_FLAG_UNSET()."]
pub type GstBinFlags = ::std::os::raw::c_uint;
#[doc = " GstBin:\n @numchildren: the number of children in this bin\n @children: (element-type Gst.Element): the list of children in this bin\n @children_cookie: updated whenever @children changes\n @child_bus: internal bus for handling child messages\n @messages: (element-type Gst.Message): queued and cached messages\n @polling: the bin is currently calculating its state\n @state_dirty: the bin needs to recalculate its state (deprecated)\n @clock_dirty: the bin needs to select a new clock\n @provided_clock: the last clock selected\n @clock_provider: the element that provided @provided_clock\n\n The GstBin base class. Subclasses can access these fields provided\n the LOCK is taken."]
pub type GstBin = _GstBin;
#[doc = " GstBinClass:\n @parent_class: bin parent class\n\n Subclasses can override #GstBinClass::add_element and #GstBinClass::remove_element\n to update the list of children in the bin.\n\n The #GstBinClass::handle_message method can be overridden to implement custom\n message handling.\n\n #GstBinClass::deep_element_added will be called when a new element has been\n added to any bin inside this bin, so it will also be called if a new child\n was added to a sub-bin of this bin. #GstBin implementations that override\n this message should chain up to the parent class implementation so the\n #GstBin::deep-element-added signal is emitted on all parents."]
pub type GstBinClass = _GstBinClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBinPrivate {
    _unused: [u8; 0],
}
pub type GstBinPrivate = _GstBinPrivate;
#[doc = " GstBin:\n @numchildren: the number of children in this bin\n @children: (element-type Gst.Element): the list of children in this bin\n @children_cookie: updated whenever @children changes\n @child_bus: internal bus for handling child messages\n @messages: (element-type Gst.Message): queued and cached messages\n @polling: the bin is currently calculating its state\n @state_dirty: the bin needs to recalculate its state (deprecated)\n @clock_dirty: the bin needs to select a new clock\n @provided_clock: the last clock selected\n @clock_provider: the element that provided @provided_clock\n\n The GstBin base class. Subclasses can access these fields provided\n the LOCK is taken."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBin {
    pub element: GstElement,
    pub numchildren: gint,
    pub children: *mut GList,
    pub children_cookie: guint32,
    pub child_bus: *mut GstBus,
    pub messages: *mut GList,
    pub polling: gboolean,
    pub state_dirty: gboolean,
    pub clock_dirty: gboolean,
    pub provided_clock: *mut GstClock,
    pub clock_provider: *mut GstElement,
    pub priv_: *mut GstBinPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBin"][::std::mem::size_of::<_GstBin>() - 376usize];
    ["Alignment of _GstBin"][::std::mem::align_of::<_GstBin>() - 8usize];
    ["Offset of field: _GstBin::element"][::std::mem::offset_of!(_GstBin, element) - 0usize];
    ["Offset of field: _GstBin::numchildren"]
        [::std::mem::offset_of!(_GstBin, numchildren) - 264usize];
    ["Offset of field: _GstBin::children"][::std::mem::offset_of!(_GstBin, children) - 272usize];
    ["Offset of field: _GstBin::children_cookie"]
        [::std::mem::offset_of!(_GstBin, children_cookie) - 280usize];
    ["Offset of field: _GstBin::child_bus"][::std::mem::offset_of!(_GstBin, child_bus) - 288usize];
    ["Offset of field: _GstBin::messages"][::std::mem::offset_of!(_GstBin, messages) - 296usize];
    ["Offset of field: _GstBin::polling"][::std::mem::offset_of!(_GstBin, polling) - 304usize];
    ["Offset of field: _GstBin::state_dirty"]
        [::std::mem::offset_of!(_GstBin, state_dirty) - 308usize];
    ["Offset of field: _GstBin::clock_dirty"]
        [::std::mem::offset_of!(_GstBin, clock_dirty) - 312usize];
    ["Offset of field: _GstBin::provided_clock"]
        [::std::mem::offset_of!(_GstBin, provided_clock) - 320usize];
    ["Offset of field: _GstBin::clock_provider"]
        [::std::mem::offset_of!(_GstBin, clock_provider) - 328usize];
    ["Offset of field: _GstBin::priv_"][::std::mem::offset_of!(_GstBin, priv_) - 336usize];
    ["Offset of field: _GstBin::_gst_reserved"]
        [::std::mem::offset_of!(_GstBin, _gst_reserved) - 344usize];
};
#[doc = " GstBinClass:\n @parent_class: bin parent class\n\n Subclasses can override #GstBinClass::add_element and #GstBinClass::remove_element\n to update the list of children in the bin.\n\n The #GstBinClass::handle_message method can be overridden to implement custom\n message handling.\n\n #GstBinClass::deep_element_added will be called when a new element has been\n added to any bin inside this bin, so it will also be called if a new child\n was added to a sub-bin of this bin. #GstBin implementations that override\n this message should chain up to the parent class implementation so the\n #GstBin::deep-element-added signal is emitted on all parents."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBinClass {
    pub parent_class: GstElementClass,
    pub pool: *mut GThreadPool,
    #[doc = " GstBinClass::element_added:\n @bin: the #GstBin\n @child: the element that was added\n\n Method called when an element was added to the bin."]
    pub element_added:
        ::std::option::Option<unsafe extern "C" fn(bin: *mut GstBin, child: *mut GstElement)>,
    #[doc = " GstBinClass::element_removed:\n @bin: the #GstBin\n @child: the element that was removed\n\n Method called when an element was removed from the bin."]
    pub element_removed:
        ::std::option::Option<unsafe extern "C" fn(bin: *mut GstBin, child: *mut GstElement)>,
    #[doc = " GstBinClass::add_element:\n @bin: the #GstBin\n @element: the element to be added\n\n Method to add an element to the bin.\n\n Returns: %TRUE if the @element was added"]
    pub add_element: ::std::option::Option<
        unsafe extern "C" fn(bin: *mut GstBin, element: *mut GstElement) -> gboolean,
    >,
    #[doc = " GstBinClass::remove_element:\n @bin: the #GstBin\n @element: the element to be removed\n\n Method to remove an element from the bin.\n\n Returns: %TRUE if the @element was removed"]
    pub remove_element: ::std::option::Option<
        unsafe extern "C" fn(bin: *mut GstBin, element: *mut GstElement) -> gboolean,
    >,
    #[doc = " GstBinClass::handle_message:\n @bin: the #GstBin\n @message: (transfer full): the message to be handled\n\n Method to handle a message from the children."]
    pub handle_message:
        ::std::option::Option<unsafe extern "C" fn(bin: *mut GstBin, message: *mut GstMessage)>,
    pub do_latency: ::std::option::Option<unsafe extern "C" fn(bin: *mut GstBin) -> gboolean>,
    #[doc = " GstBinClass::deep_element_added:\n @bin: the top level #GstBin\n @sub_bin: the #GstBin to which the element was added\n @child: the element that was added\n\n Method called when an element was added somewhere in the bin hierarchy."]
    pub deep_element_added: ::std::option::Option<
        unsafe extern "C" fn(bin: *mut GstBin, sub_bin: *mut GstBin, child: *mut GstElement),
    >,
    #[doc = " GstBinClass::deep_element_removed:\n @bin: the top level #GstBin\n @sub_bin: the #GstBin from which the element was removed\n @child: the element that was removed\n\n Method called when an element was removed somewhere in the bin hierarchy."]
    pub deep_element_removed: ::std::option::Option<
        unsafe extern "C" fn(bin: *mut GstBin, sub_bin: *mut GstBin, child: *mut GstElement),
    >,
    pub _gst_reserved: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBinClass"][::std::mem::size_of::<_GstBinClass>() - 576usize];
    ["Alignment of _GstBinClass"][::std::mem::align_of::<_GstBinClass>() - 8usize];
    ["Offset of field: _GstBinClass::parent_class"]
        [::std::mem::offset_of!(_GstBinClass, parent_class) - 0usize];
    ["Offset of field: _GstBinClass::pool"][::std::mem::offset_of!(_GstBinClass, pool) - 488usize];
    ["Offset of field: _GstBinClass::element_added"]
        [::std::mem::offset_of!(_GstBinClass, element_added) - 496usize];
    ["Offset of field: _GstBinClass::element_removed"]
        [::std::mem::offset_of!(_GstBinClass, element_removed) - 504usize];
    ["Offset of field: _GstBinClass::add_element"]
        [::std::mem::offset_of!(_GstBinClass, add_element) - 512usize];
    ["Offset of field: _GstBinClass::remove_element"]
        [::std::mem::offset_of!(_GstBinClass, remove_element) - 520usize];
    ["Offset of field: _GstBinClass::handle_message"]
        [::std::mem::offset_of!(_GstBinClass, handle_message) - 528usize];
    ["Offset of field: _GstBinClass::do_latency"]
        [::std::mem::offset_of!(_GstBinClass, do_latency) - 536usize];
    ["Offset of field: _GstBinClass::deep_element_added"]
        [::std::mem::offset_of!(_GstBinClass, deep_element_added) - 544usize];
    ["Offset of field: _GstBinClass::deep_element_removed"]
        [::std::mem::offset_of!(_GstBinClass, deep_element_removed) - 552usize];
    ["Offset of field: _GstBinClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstBinClass, _gst_reserved) - 560usize];
};
unsafe extern "C" {
    pub fn gst_bin_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bin_new(name: *const gchar) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_bin_add(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bin_remove(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bin_get_by_name(bin: *mut GstBin, name: *const gchar) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_bin_get_by_name_recurse_up(bin: *mut GstBin, name: *const gchar) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_bin_get_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_elements(bin: *mut GstBin) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_sorted(bin: *mut GstBin) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_recurse(bin: *mut GstBin) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_sinks(bin: *mut GstBin) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_sources(bin: *mut GstBin) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_all_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_iterate_all_by_element_factory_name(
        bin: *mut GstBin,
        factory_name: *const gchar,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_bin_recalculate_latency(bin: *mut GstBin) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_bin_set_suppressed_flags(bin: *mut GstBin, flags: GstElementFlags);
}
unsafe extern "C" {
    pub fn gst_bin_get_suppressed_flags(bin: *mut GstBin) -> GstElementFlags;
}
pub type GstBin_autoptr = *mut GstBin;
pub type GstBin_listautoptr = *mut GList;
pub type GstBin_slistautoptr = *mut GSList;
pub type GstBin_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferPoolPrivate {
    _unused: [u8; 0],
}
pub type GstBufferPoolPrivate = _GstBufferPoolPrivate;
#[doc = " GstBufferPoolClass:\n @object_class:  Object parent class\n\n The #GstBufferPool class."]
pub type GstBufferPoolClass = _GstBufferPoolClass;
pub const GstBufferPoolAcquireFlags_GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: GstBufferPoolAcquireFlags =
    0;
pub const GstBufferPoolAcquireFlags_GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT:
    GstBufferPoolAcquireFlags = 1;
pub const GstBufferPoolAcquireFlags_GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT:
    GstBufferPoolAcquireFlags = 2;
pub const GstBufferPoolAcquireFlags_GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT:
    GstBufferPoolAcquireFlags = 4;
pub const GstBufferPoolAcquireFlags_GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: GstBufferPoolAcquireFlags =
    65536;
#[doc = " GstBufferPoolAcquireFlags:\n @GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: no flags\n @GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT: buffer is keyframe\n @GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT: when the bufferpool is empty, acquire_buffer\n will by default block until a buffer is released into the pool again. Setting\n this flag makes acquire_buffer return #GST_FLOW_EOS instead of blocking.\n @GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT: buffer is discont\n @GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: last flag, subclasses can use private flags\n    starting from this value.\n\n Additional flags to control the allocation of a buffer"]
pub type GstBufferPoolAcquireFlags = ::std::os::raw::c_uint;
#[doc = " GstBufferPoolAcquireParams:\n @format: the format of @start and @stop\n @start: the start position\n @stop: the stop position\n @flags: additional flags\n\n Parameters passed to the gst_buffer_pool_acquire_buffer() function to control the\n allocation of the buffer.\n\n The default implementation ignores the @start and @stop members but other\n implementations can use this extra information to decide what buffer to\n return."]
pub type GstBufferPoolAcquireParams = _GstBufferPoolAcquireParams;
#[doc = " GstBufferPoolAcquireParams:\n @format: the format of @start and @stop\n @start: the start position\n @stop: the stop position\n @flags: additional flags\n\n Parameters passed to the gst_buffer_pool_acquire_buffer() function to control the\n allocation of the buffer.\n\n The default implementation ignores the @start and @stop members but other\n implementations can use this extra information to decide what buffer to\n return."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferPoolAcquireParams {
    pub format: GstFormat,
    pub start: gint64,
    pub stop: gint64,
    pub flags: GstBufferPoolAcquireFlags,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBufferPoolAcquireParams"]
        [::std::mem::size_of::<_GstBufferPoolAcquireParams>() - 64usize];
    ["Alignment of _GstBufferPoolAcquireParams"]
        [::std::mem::align_of::<_GstBufferPoolAcquireParams>() - 8usize];
    ["Offset of field: _GstBufferPoolAcquireParams::format"]
        [::std::mem::offset_of!(_GstBufferPoolAcquireParams, format) - 0usize];
    ["Offset of field: _GstBufferPoolAcquireParams::start"]
        [::std::mem::offset_of!(_GstBufferPoolAcquireParams, start) - 8usize];
    ["Offset of field: _GstBufferPoolAcquireParams::stop"]
        [::std::mem::offset_of!(_GstBufferPoolAcquireParams, stop) - 16usize];
    ["Offset of field: _GstBufferPoolAcquireParams::flags"]
        [::std::mem::offset_of!(_GstBufferPoolAcquireParams, flags) - 24usize];
    ["Offset of field: _GstBufferPoolAcquireParams::_gst_reserved"]
        [::std::mem::offset_of!(_GstBufferPoolAcquireParams, _gst_reserved) - 32usize];
};
#[doc = " GstBufferPool:\n @object: the parent structure\n @flushing: whether the pool is currently gathering back outstanding buffers\n\n The structure of a #GstBufferPool. Use the associated macros to access the public\n variables."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBufferPool {
    pub object: GstObject,
    pub flushing: gint,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBufferPool"][::std::mem::size_of::<_GstBufferPool>() - 136usize];
    ["Alignment of _GstBufferPool"][::std::mem::align_of::<_GstBufferPool>() - 8usize];
    ["Offset of field: _GstBufferPool::object"]
        [::std::mem::offset_of!(_GstBufferPool, object) - 0usize];
    ["Offset of field: _GstBufferPool::flushing"]
        [::std::mem::offset_of!(_GstBufferPool, flushing) - 88usize];
    ["Offset of field: _GstBufferPool::priv_"]
        [::std::mem::offset_of!(_GstBufferPool, priv_) - 96usize];
    ["Offset of field: _GstBufferPool::_gst_reserved"]
        [::std::mem::offset_of!(_GstBufferPool, _gst_reserved) - 104usize];
};
#[doc = " GstBufferPoolClass:\n @object_class:  Object parent class\n\n The #GstBufferPool class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferPoolClass {
    pub object_class: GstObjectClass,
    #[doc = " GstBufferPoolClass::get_options:\n @pool: the #GstBufferPool\n\n Get a list of options supported by this pool\n\n Returns: (array zero-terminated=1) (transfer none): a %NULL terminated array\n          of strings."]
    pub get_options:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut GstBufferPool) -> *mut *const gchar>,
    #[doc = " GstBufferPoolClass::set_config:\n @pool: the #GstBufferPool\n @config: the required configuration\n\n Apply the bufferpool configuration. The default configuration will parse\n the default config parameters.\n\n Returns: whether the configuration could be set."]
    pub set_config: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut GstBufferPool, config: *mut GstStructure) -> gboolean,
    >,
    #[doc = " GstBufferPoolClass::start:\n @pool: the #GstBufferPool\n\n Start the bufferpool. The default implementation will preallocate\n min-buffers buffers and put them in the queue.\n\n Returns: whether the pool could be started."]
    pub start: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstBufferPool) -> gboolean>,
    #[doc = " GstBufferPoolClass::stop:\n @pool: the #GstBufferPool\n\n Stop the bufferpool. the default implementation will free the\n preallocated buffers. This function is called when all the buffers are\n returned to the pool.\n\n Returns: whether the pool could be stopped."]
    pub stop: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstBufferPool) -> gboolean>,
    #[doc = " GstBufferPoolClass::acquire_buffer:\n @pool: the #GstBufferPool\n @buffer: (out): a location for a #GstBuffer\n @params: (transfer none) (allow-none): parameters.\n\n Get a new buffer from the pool. The default implementation\n will take a buffer from the queue and optionally wait for a buffer to\n be released when there are no buffers available.\n\n Returns: a #GstFlowReturn such as %GST_FLOW_FLUSHING when the pool is\n inactive."]
    pub acquire_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            pool: *mut GstBufferPool,
            buffer: *mut *mut GstBuffer,
            params: *mut GstBufferPoolAcquireParams,
        ) -> GstFlowReturn,
    >,
    #[doc = " GstBufferPoolClass::alloc_buffer:\n @pool: the #GstBufferPool\n @buffer: (out): a location for a #GstBuffer\n @params: (transfer none) (allow-none): parameters.\n\n Allocate a buffer. the default implementation allocates\n buffers from the configured memory allocator and with the configured\n parameters. All metadata that is present on the allocated buffer will\n be marked as #GST_META_FLAG_POOLED and #GST_META_FLAG_LOCKED and will\n not be removed from the buffer in #GstBufferPoolClass::reset_buffer.\n The buffer should have the #GST_BUFFER_FLAG_TAG_MEMORY cleared.\n\n Returns: a #GstFlowReturn to indicate whether the allocation was\n successful."]
    pub alloc_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            pool: *mut GstBufferPool,
            buffer: *mut *mut GstBuffer,
            params: *mut GstBufferPoolAcquireParams,
        ) -> GstFlowReturn,
    >,
    #[doc = " GstBufferPoolClass::reset_buffer:\n @pool: the #GstBufferPool\n @buffer: the #GstBuffer to reset\n\n Reset the buffer to its state when it was freshly allocated.\n The default implementation will clear the flags, timestamps and\n will remove the metadata without the #GST_META_FLAG_POOLED flag (even\n the metadata with #GST_META_FLAG_LOCKED). If the\n #GST_BUFFER_FLAG_TAG_MEMORY was set, this function can also try to\n restore the memory and clear the #GST_BUFFER_FLAG_TAG_MEMORY again."]
    pub reset_buffer: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut GstBufferPool, buffer: *mut GstBuffer),
    >,
    #[doc = " GstBufferPoolClass::release_buffer:\n @pool: the #GstBufferPool\n @buffer: the #GstBuffer to release\n\n Release a buffer back in the pool. The default implementation\n will put the buffer back in the queue and notify any\n blocking #GstBufferPoolClass::acquire_buffer calls when the\n #GST_BUFFER_FLAG_TAG_MEMORY is not set on the buffer.\n If #GST_BUFFER_FLAG_TAG_MEMORY is set, the buffer will be freed with\n #GstBufferPoolClass::free_buffer."]
    pub release_buffer: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut GstBufferPool, buffer: *mut GstBuffer),
    >,
    #[doc = " GstBufferPoolClass::free_buffer:\n @pool: the #GstBufferPool\n @buffer: the #GstBuffer to free\n\n Free a buffer. The default implementation unrefs the buffer."]
    pub free_buffer: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut GstBufferPool, buffer: *mut GstBuffer),
    >,
    #[doc = " GstBufferPoolClass::flush_start:\n @pool: the #GstBufferPool\n\n Enter the flushing state.\n\n Since: 1.4"]
    pub flush_start: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstBufferPool)>,
    #[doc = " GstBufferPoolClass::flush_stop:\n @pool: the #GstBufferPool\n\n Leave the flushing state.\n\n Since: 1.4"]
    pub flush_stop: ::std::option::Option<unsafe extern "C" fn(pool: *mut GstBufferPool)>,
    pub _gst_reserved: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBufferPoolClass"][::std::mem::size_of::<_GstBufferPoolClass>() - 288usize];
    ["Alignment of _GstBufferPoolClass"][::std::mem::align_of::<_GstBufferPoolClass>() - 8usize];
    ["Offset of field: _GstBufferPoolClass::object_class"]
        [::std::mem::offset_of!(_GstBufferPoolClass, object_class) - 0usize];
    ["Offset of field: _GstBufferPoolClass::get_options"]
        [::std::mem::offset_of!(_GstBufferPoolClass, get_options) - 184usize];
    ["Offset of field: _GstBufferPoolClass::set_config"]
        [::std::mem::offset_of!(_GstBufferPoolClass, set_config) - 192usize];
    ["Offset of field: _GstBufferPoolClass::start"]
        [::std::mem::offset_of!(_GstBufferPoolClass, start) - 200usize];
    ["Offset of field: _GstBufferPoolClass::stop"]
        [::std::mem::offset_of!(_GstBufferPoolClass, stop) - 208usize];
    ["Offset of field: _GstBufferPoolClass::acquire_buffer"]
        [::std::mem::offset_of!(_GstBufferPoolClass, acquire_buffer) - 216usize];
    ["Offset of field: _GstBufferPoolClass::alloc_buffer"]
        [::std::mem::offset_of!(_GstBufferPoolClass, alloc_buffer) - 224usize];
    ["Offset of field: _GstBufferPoolClass::reset_buffer"]
        [::std::mem::offset_of!(_GstBufferPoolClass, reset_buffer) - 232usize];
    ["Offset of field: _GstBufferPoolClass::release_buffer"]
        [::std::mem::offset_of!(_GstBufferPoolClass, release_buffer) - 240usize];
    ["Offset of field: _GstBufferPoolClass::free_buffer"]
        [::std::mem::offset_of!(_GstBufferPoolClass, free_buffer) - 248usize];
    ["Offset of field: _GstBufferPoolClass::flush_start"]
        [::std::mem::offset_of!(_GstBufferPoolClass, flush_start) - 256usize];
    ["Offset of field: _GstBufferPoolClass::flush_stop"]
        [::std::mem::offset_of!(_GstBufferPoolClass, flush_stop) - 264usize];
    ["Offset of field: _GstBufferPoolClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstBufferPoolClass, _gst_reserved) - 272usize];
};
unsafe extern "C" {
    pub fn gst_buffer_pool_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_new() -> *mut GstBufferPool;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_set_active(pool: *mut GstBufferPool, active: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_is_active(pool: *mut GstBufferPool) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_set_config(
        pool: *mut GstBufferPool,
        config: *mut GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_get_config(pool: *mut GstBufferPool) -> *mut GstStructure;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_get_options(pool: *mut GstBufferPool) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_has_option(pool: *mut GstBufferPool, option: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_set_flushing(pool: *mut GstBufferPool, flushing: gboolean);
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_set_params(
        config: *mut GstStructure,
        caps: *mut GstCaps,
        size: guint,
        min_buffers: guint,
        max_buffers: guint,
    );
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_get_params(
        config: *mut GstStructure,
        caps: *mut *mut GstCaps,
        size: *mut guint,
        min_buffers: *mut guint,
        max_buffers: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_set_allocator(
        config: *mut GstStructure,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_get_allocator(
        config: *mut GstStructure,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_n_options(config: *mut GstStructure) -> guint;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_add_option(config: *mut GstStructure, option: *const gchar);
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_get_option(
        config: *mut GstStructure,
        index: guint,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_has_option(
        config: *mut GstStructure,
        option: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_validate_params(
        config: *mut GstStructure,
        caps: *mut GstCaps,
        size: guint,
        min_buffers: guint,
        max_buffers: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_acquire_buffer(
        pool: *mut GstBufferPool,
        buffer: *mut *mut GstBuffer,
        params: *mut GstBufferPoolAcquireParams,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_release_buffer(pool: *mut GstBufferPool, buffer: *mut GstBuffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstChildProxy {
    _unused: [u8; 0],
}
#[doc = " GstChildProxy:\n\n Opaque #GstChildProxy data structure."]
pub type GstChildProxy = _GstChildProxy;
#[doc = " GstChildProxyInterface:\n @parent: parent interface type.\n\n #GstChildProxy interface."]
pub type GstChildProxyInterface = _GstChildProxyInterface;
#[doc = " GstChildProxyInterface:\n @parent: parent interface type.\n\n #GstChildProxy interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstChildProxyInterface {
    pub parent: GTypeInterface,
    #[doc = " GstChildProxyInterface.get_child_by_name:\n @parent: the #GstChildProxy\n @name: the name of the child to fetch\n\n Fetch a child object by name\n\n Returns: (transfer full) (nullable): the child object"]
    pub get_child_by_name: ::std::option::Option<
        unsafe extern "C" fn(parent: *mut GstChildProxy, name: *const gchar) -> *mut GObject,
    >,
    #[doc = " GstChildProxyInterface.get_child_by_index:\n @parent: the #GstChildProxy\n @index: the index of the child to fetch\n\n Fetch a child object by index\n\n Returns: (transfer full) (nullable): the child object"]
    pub get_child_by_index: ::std::option::Option<
        unsafe extern "C" fn(parent: *mut GstChildProxy, index: guint) -> *mut GObject,
    >,
    #[doc = " GstChildProxyInterface.get_children_count:\n @parent: the #GstChildProxy\n\n Get the number of children in @parent\n\n Returns: the number of children"]
    pub get_children_count:
        ::std::option::Option<unsafe extern "C" fn(parent: *mut GstChildProxy) -> guint>,
    #[doc = " GstChildProxyInterface.child_added:\n @parent: the #GstChildProxy\n @child: the child object\n @name: the name of the child object\n\n Called when @child is added to @parent"]
    pub child_added: ::std::option::Option<
        unsafe extern "C" fn(parent: *mut GstChildProxy, child: *mut GObject, name: *const gchar),
    >,
    #[doc = " GstChildProxyInterface.child_removed:\n @parent: the #GstChildProxy\n @child: the child object\n @name: the name of the child object\n\n Called when @child is removed from @parent"]
    pub child_removed: ::std::option::Option<
        unsafe extern "C" fn(parent: *mut GstChildProxy, child: *mut GObject, name: *const gchar),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstChildProxyInterface"][::std::mem::size_of::<_GstChildProxyInterface>() - 88usize];
    ["Alignment of _GstChildProxyInterface"]
        [::std::mem::align_of::<_GstChildProxyInterface>() - 8usize];
    ["Offset of field: _GstChildProxyInterface::parent"]
        [::std::mem::offset_of!(_GstChildProxyInterface, parent) - 0usize];
    ["Offset of field: _GstChildProxyInterface::get_child_by_name"]
        [::std::mem::offset_of!(_GstChildProxyInterface, get_child_by_name) - 16usize];
    ["Offset of field: _GstChildProxyInterface::get_child_by_index"]
        [::std::mem::offset_of!(_GstChildProxyInterface, get_child_by_index) - 24usize];
    ["Offset of field: _GstChildProxyInterface::get_children_count"]
        [::std::mem::offset_of!(_GstChildProxyInterface, get_children_count) - 32usize];
    ["Offset of field: _GstChildProxyInterface::child_added"]
        [::std::mem::offset_of!(_GstChildProxyInterface, child_added) - 40usize];
    ["Offset of field: _GstChildProxyInterface::child_removed"]
        [::std::mem::offset_of!(_GstChildProxyInterface, child_removed) - 48usize];
    ["Offset of field: _GstChildProxyInterface::_gst_reserved"]
        [::std::mem::offset_of!(_GstChildProxyInterface, _gst_reserved) - 56usize];
};
unsafe extern "C" {
    pub fn gst_child_proxy_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_child_proxy_get_child_by_name(
        parent: *mut GstChildProxy,
        name: *const gchar,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn gst_child_proxy_get_children_count(parent: *mut GstChildProxy) -> guint;
}
unsafe extern "C" {
    pub fn gst_child_proxy_get_child_by_index(
        parent: *mut GstChildProxy,
        index: guint,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn gst_child_proxy_lookup(
        object: *mut GstChildProxy,
        name: *const gchar,
        target: *mut *mut GObject,
        pspec: *mut *mut GParamSpec,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_child_proxy_get_property(
        object: *mut GstChildProxy,
        name: *const gchar,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn gst_child_proxy_get_valist(
        object: *mut GstChildProxy,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_child_proxy_get(object: *mut GstChildProxy, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_child_proxy_set_property(
        object: *mut GstChildProxy,
        name: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_child_proxy_set_valist(
        object: *mut GstChildProxy,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_child_proxy_set(object: *mut GstChildProxy, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_child_proxy_child_added(
        parent: *mut GstChildProxy,
        child: *mut GObject,
        name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_child_proxy_child_removed(
        parent: *mut GstChildProxy,
        child: *mut GObject,
        name: *const gchar,
    );
}
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: GstDebugGraphDetails = 1;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: GstDebugGraphDetails = 2;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: GstDebugGraphDetails = 4;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_STATES: GstDebugGraphDetails = 8;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_FULL_PARAMS: GstDebugGraphDetails = 16;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_ALL: GstDebugGraphDetails = 15;
pub const GstDebugGraphDetails_GST_DEBUG_GRAPH_SHOW_VERBOSE: GstDebugGraphDetails = -1;
#[doc = " GstDebugGraphDetails:\n @GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: show caps-name on edges\n @GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: show caps-details on edges\n @GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: show modified parameters on\n                                           elements\n @GST_DEBUG_GRAPH_SHOW_STATES: show element states\n @GST_DEBUG_GRAPH_SHOW_FULL_PARAMS: show full element parameter values even\n                                    if they are very long\n @GST_DEBUG_GRAPH_SHOW_ALL: show all the typical details that one might want\n @GST_DEBUG_GRAPH_SHOW_VERBOSE: show all details regardless of how large or\n                                verbose they make the resulting output\n\n Available details for pipeline graphs produced by GST_DEBUG_BIN_TO_DOT_FILE()\n and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()."]
pub type GstDebugGraphDetails = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " pipeline graphs"]
    pub fn gst_debug_bin_to_dot_data(bin: *mut GstBin, details: GstDebugGraphDetails)
    -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_debug_bin_to_dot_file(
        bin: *mut GstBin,
        details: GstDebugGraphDetails,
        file_name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_debug_bin_to_dot_file_with_ts(
        bin: *mut GstBin,
        details: GstDebugGraphDetails,
        file_name: *const gchar,
    );
}
#[doc = " GstDeviceProvider:\n @parent: The parent #GstObject\n @devices: a #GList of the #GstDevice objects\n\n The structure of the base #GstDeviceProvider\n\n Since: 1.4"]
pub type GstDeviceProvider = _GstDeviceProvider;
#[doc = " GstDeviceProviderClass:\n @parent_class: the parent #GstObjectClass structure\n @factory: a pointer to the #GstDeviceProviderFactory that creates this\n  provider\n @probe: Returns a list of devices that are currently available.\n  This should never block. The devices should not have a parent and should\n  be floating.\n @start: Starts monitoring for new devices. Only subclasses that can know\n  that devices have been added or remove need to implement this method.\n @stop: Stops monitoring for new devices. Only subclasses that implement\n  the start() method need to implement this method.\n\n The structure of the base #GstDeviceProviderClass\n\n Since: 1.4"]
pub type GstDeviceProviderClass = _GstDeviceProviderClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceProviderPrivate {
    _unused: [u8; 0],
}
pub type GstDeviceProviderPrivate = _GstDeviceProviderPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceProviderFactory {
    _unused: [u8; 0],
}
#[doc = " GstDeviceProviderFactoryClass:\n\n The opaque #GstDeviceProviderFactoryClass data structure.\n\n Since: 1.4"]
pub type GstDeviceProviderFactory = _GstDeviceProviderFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceProviderFactoryClass {
    _unused: [u8; 0],
}
pub type GstDeviceProviderFactoryClass = _GstDeviceProviderFactoryClass;
unsafe extern "C" {
    pub fn gst_device_provider_factory_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_find(name: *const gchar) -> *mut GstDeviceProviderFactory;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_get_device_provider_type(
        factory: *mut GstDeviceProviderFactory,
    ) -> GType;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_get_metadata(
        factory: *mut GstDeviceProviderFactory,
        key: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_get_metadata_keys(
        factory: *mut GstDeviceProviderFactory,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_get(
        factory: *mut GstDeviceProviderFactory,
    ) -> *mut GstDeviceProvider;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_get_by_name(
        factoryname: *const gchar,
    ) -> *mut GstDeviceProvider;
}
unsafe extern "C" {
    pub fn gst_device_provider_register(
        plugin: *mut GstPlugin,
        name: *const gchar,
        rank: guint,
        type_: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_has_classesv(
        factory: *mut GstDeviceProviderFactory,
        classes: *mut *mut gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_has_classes(
        factory: *mut GstDeviceProviderFactory,
        classes: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_factory_list_get_device_providers(minrank: GstRank) -> *mut GList;
}
pub type GstDeviceProviderFactory_autoptr = *mut GstDeviceProviderFactory;
pub type GstDeviceProviderFactory_listautoptr = *mut GList;
pub type GstDeviceProviderFactory_slistautoptr = *mut GSList;
pub type GstDeviceProviderFactory_queueautoptr = *mut GQueue;
#[doc = " GstDeviceProvider:\n @parent: The parent #GstObject\n @devices: a #GList of the #GstDevice objects\n\n The structure of the base #GstDeviceProvider\n\n Since: 1.4"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstDeviceProvider {
    pub parent: GstObject,
    pub devices: *mut GList,
    pub priv_: *mut GstDeviceProviderPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDeviceProvider"][::std::mem::size_of::<_GstDeviceProvider>() - 136usize];
    ["Alignment of _GstDeviceProvider"][::std::mem::align_of::<_GstDeviceProvider>() - 8usize];
    ["Offset of field: _GstDeviceProvider::parent"]
        [::std::mem::offset_of!(_GstDeviceProvider, parent) - 0usize];
    ["Offset of field: _GstDeviceProvider::devices"]
        [::std::mem::offset_of!(_GstDeviceProvider, devices) - 88usize];
    ["Offset of field: _GstDeviceProvider::priv_"]
        [::std::mem::offset_of!(_GstDeviceProvider, priv_) - 96usize];
    ["Offset of field: _GstDeviceProvider::_gst_reserved"]
        [::std::mem::offset_of!(_GstDeviceProvider, _gst_reserved) - 104usize];
};
#[doc = " GstDeviceProviderClass:\n @parent_class: the parent #GstObjectClass structure\n @factory: a pointer to the #GstDeviceProviderFactory that creates this\n  provider\n @probe: Returns a list of devices that are currently available.\n  This should never block. The devices should not have a parent and should\n  be floating.\n @start: Starts monitoring for new devices. Only subclasses that can know\n  that devices have been added or remove need to implement this method.\n @stop: Stops monitoring for new devices. Only subclasses that implement\n  the start() method need to implement this method.\n\n The structure of the base #GstDeviceProviderClass\n\n Since: 1.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceProviderClass {
    pub parent_class: GstObjectClass,
    pub factory: *mut GstDeviceProviderFactory,
    pub probe:
        ::std::option::Option<unsafe extern "C" fn(provider: *mut GstDeviceProvider) -> *mut GList>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(provider: *mut GstDeviceProvider) -> gboolean>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(provider: *mut GstDeviceProvider)>,
    pub metadata: gpointer,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDeviceProviderClass"]
        [::std::mem::size_of::<_GstDeviceProviderClass>() - 256usize];
    ["Alignment of _GstDeviceProviderClass"]
        [::std::mem::align_of::<_GstDeviceProviderClass>() - 8usize];
    ["Offset of field: _GstDeviceProviderClass::parent_class"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, parent_class) - 0usize];
    ["Offset of field: _GstDeviceProviderClass::factory"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, factory) - 184usize];
    ["Offset of field: _GstDeviceProviderClass::probe"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, probe) - 192usize];
    ["Offset of field: _GstDeviceProviderClass::start"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, start) - 200usize];
    ["Offset of field: _GstDeviceProviderClass::stop"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, stop) - 208usize];
    ["Offset of field: _GstDeviceProviderClass::metadata"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, metadata) - 216usize];
    ["Offset of field: _GstDeviceProviderClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstDeviceProviderClass, _gst_reserved) - 224usize];
};
unsafe extern "C" {
    pub fn gst_device_provider_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_device_provider_get_devices(provider: *mut GstDeviceProvider) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_device_provider_start(provider: *mut GstDeviceProvider) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_stop(provider: *mut GstDeviceProvider);
}
unsafe extern "C" {
    pub fn gst_device_provider_can_monitor(provider: *mut GstDeviceProvider) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_get_bus(provider: *mut GstDeviceProvider) -> *mut GstBus;
}
unsafe extern "C" {
    pub fn gst_device_provider_device_add(provider: *mut GstDeviceProvider, device: *mut GstDevice);
}
unsafe extern "C" {
    pub fn gst_device_provider_device_remove(
        provider: *mut GstDeviceProvider,
        device: *mut GstDevice,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_get_hidden_providers(
        provider: *mut GstDeviceProvider,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_device_provider_hide_provider(provider: *mut GstDeviceProvider, name: *const gchar);
}
unsafe extern "C" {
    pub fn gst_device_provider_unhide_provider(
        provider: *mut GstDeviceProvider,
        name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_get_metadata(
        provider: *mut GstDeviceProvider,
        key: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_device_provider_is_started(provider: *mut GstDeviceProvider) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_provider_class_set_metadata(
        klass: *mut GstDeviceProviderClass,
        longname: *const gchar,
        classification: *const gchar,
        description: *const gchar,
        author: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_class_set_static_metadata(
        klass: *mut GstDeviceProviderClass,
        longname: *const gchar,
        classification: *const gchar,
        description: *const gchar,
        author: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_class_add_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_class_add_static_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_class_get_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_device_provider_device_changed(
        provider: *mut GstDeviceProvider,
        device: *mut GstDevice,
        changed_device: *mut GstDevice,
    );
}
unsafe extern "C" {
    pub fn gst_device_provider_get_factory(
        provider: *mut GstDeviceProvider,
    ) -> *mut GstDeviceProviderFactory;
}
pub type GstDeviceProvider_autoptr = *mut GstDeviceProvider;
pub type GstDeviceProvider_listautoptr = *mut GList;
pub type GstDeviceProvider_slistautoptr = *mut GSList;
pub type GstDeviceProvider_queueautoptr = *mut GQueue;
#[doc = " GstDeviceMonitor:\n @parent: the parent #GstObject structure\n\n Opaque device monitor object structure.\n\n Since: 1.4"]
pub type GstDeviceMonitor = _GstDeviceMonitor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceMonitorPrivate {
    _unused: [u8; 0],
}
pub type GstDeviceMonitorPrivate = _GstDeviceMonitorPrivate;
#[doc = " GstDeviceMonitorClass:\n @parent_class: the parent #GstObjectClass structure\n\n Opaque device monitor class structure.\n\n Since: 1.4"]
pub type GstDeviceMonitorClass = _GstDeviceMonitorClass;
#[doc = " GstDeviceMonitor:\n @parent: the parent #GstObject structure\n\n Opaque device monitor object structure.\n\n Since: 1.4"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstDeviceMonitor {
    pub parent: GstObject,
    pub priv_: *mut GstDeviceMonitorPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDeviceMonitor"][::std::mem::size_of::<_GstDeviceMonitor>() - 128usize];
    ["Alignment of _GstDeviceMonitor"][::std::mem::align_of::<_GstDeviceMonitor>() - 8usize];
    ["Offset of field: _GstDeviceMonitor::parent"]
        [::std::mem::offset_of!(_GstDeviceMonitor, parent) - 0usize];
    ["Offset of field: _GstDeviceMonitor::priv_"]
        [::std::mem::offset_of!(_GstDeviceMonitor, priv_) - 88usize];
    ["Offset of field: _GstDeviceMonitor::_gst_reserved"]
        [::std::mem::offset_of!(_GstDeviceMonitor, _gst_reserved) - 96usize];
};
#[doc = " GstDeviceMonitorClass:\n @parent_class: the parent #GstObjectClass structure\n\n Opaque device monitor class structure.\n\n Since: 1.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDeviceMonitorClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDeviceMonitorClass"][::std::mem::size_of::<_GstDeviceMonitorClass>() - 216usize];
    ["Alignment of _GstDeviceMonitorClass"]
        [::std::mem::align_of::<_GstDeviceMonitorClass>() - 8usize];
    ["Offset of field: _GstDeviceMonitorClass::parent_class"]
        [::std::mem::offset_of!(_GstDeviceMonitorClass, parent_class) - 0usize];
    ["Offset of field: _GstDeviceMonitorClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstDeviceMonitorClass, _gst_reserved) - 184usize];
};
unsafe extern "C" {
    pub fn gst_device_monitor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_device_monitor_new() -> *mut GstDeviceMonitor;
}
unsafe extern "C" {
    pub fn gst_device_monitor_get_bus(monitor: *mut GstDeviceMonitor) -> *mut GstBus;
}
unsafe extern "C" {
    pub fn gst_device_monitor_get_devices(monitor: *mut GstDeviceMonitor) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_device_monitor_start(monitor: *mut GstDeviceMonitor) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_monitor_stop(monitor: *mut GstDeviceMonitor);
}
unsafe extern "C" {
    pub fn gst_device_monitor_add_filter(
        monitor: *mut GstDeviceMonitor,
        classes: *const gchar,
        caps: *mut GstCaps,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_device_monitor_remove_filter(
        monitor: *mut GstDeviceMonitor,
        filter_id: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_device_monitor_get_providers(monitor: *mut GstDeviceMonitor) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_device_monitor_set_show_all_devices(
        monitor: *mut GstDeviceMonitor,
        show_all: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_device_monitor_get_show_all_devices(monitor: *mut GstDeviceMonitor) -> gboolean;
}
pub type GstDeviceMonitor_autoptr = *mut GstDeviceMonitor;
pub type GstDeviceMonitor_listautoptr = *mut GList;
pub type GstDeviceMonitor_slistautoptr = *mut GSList;
pub type GstDeviceMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDynamicTypeFactory {
    _unused: [u8; 0],
}
#[doc = " GstDynamicTypeFactory:\n\n The opaque #GstDynamicTypeFactory data structure.\n\n Since: 1.12"]
pub type GstDynamicTypeFactory = _GstDynamicTypeFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDynamicTypeFactoryClass {
    _unused: [u8; 0],
}
pub type GstDynamicTypeFactoryClass = _GstDynamicTypeFactoryClass;
unsafe extern "C" {
    pub fn gst_dynamic_type_factory_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_dynamic_type_factory_load(factoryname: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn gst_dynamic_type_register(plugin: *mut GstPlugin, type_: GType) -> gboolean;
}
pub const GstCoreError_GST_CORE_ERROR_FAILED: GstCoreError = 1;
pub const GstCoreError_GST_CORE_ERROR_TOO_LAZY: GstCoreError = 2;
pub const GstCoreError_GST_CORE_ERROR_NOT_IMPLEMENTED: GstCoreError = 3;
pub const GstCoreError_GST_CORE_ERROR_STATE_CHANGE: GstCoreError = 4;
pub const GstCoreError_GST_CORE_ERROR_PAD: GstCoreError = 5;
pub const GstCoreError_GST_CORE_ERROR_THREAD: GstCoreError = 6;
pub const GstCoreError_GST_CORE_ERROR_NEGOTIATION: GstCoreError = 7;
pub const GstCoreError_GST_CORE_ERROR_EVENT: GstCoreError = 8;
pub const GstCoreError_GST_CORE_ERROR_SEEK: GstCoreError = 9;
pub const GstCoreError_GST_CORE_ERROR_CAPS: GstCoreError = 10;
pub const GstCoreError_GST_CORE_ERROR_TAG: GstCoreError = 11;
pub const GstCoreError_GST_CORE_ERROR_MISSING_PLUGIN: GstCoreError = 12;
pub const GstCoreError_GST_CORE_ERROR_CLOCK: GstCoreError = 13;
pub const GstCoreError_GST_CORE_ERROR_DISABLED: GstCoreError = 14;
pub const GstCoreError_GST_CORE_ERROR_NUM_ERRORS: GstCoreError = 15;
#[doc = " GstCoreError:\n @GST_CORE_ERROR_FAILED: a general error which doesn't fit in any other\n category.  Make sure you add a custom message to the error call.\n @GST_CORE_ERROR_TOO_LAZY: do not use this except as a placeholder for\n deciding where to go while developing code.\n @GST_CORE_ERROR_NOT_IMPLEMENTED: use this when you do not want to implement\n this functionality yet.\n @GST_CORE_ERROR_STATE_CHANGE: used for state change errors.\n @GST_CORE_ERROR_PAD: used for pad-related errors.\n @GST_CORE_ERROR_THREAD: used for thread-related errors.\n @GST_CORE_ERROR_NEGOTIATION: used for negotiation-related errors.\n @GST_CORE_ERROR_EVENT: used for event-related errors.\n @GST_CORE_ERROR_SEEK: used for seek-related errors.\n @GST_CORE_ERROR_CAPS: used for caps-related errors.\n @GST_CORE_ERROR_TAG: used for negotiation-related errors.\n @GST_CORE_ERROR_MISSING_PLUGIN: used if a plugin is missing.\n @GST_CORE_ERROR_CLOCK: used for clock related errors.\n @GST_CORE_ERROR_DISABLED: used if functionality has been disabled at\n                           compile time.\n @GST_CORE_ERROR_NUM_ERRORS: the number of core error types.\n\n Core errors are errors inside the core GStreamer library."]
pub type GstCoreError = ::std::os::raw::c_uint;
pub const GstLibraryError_GST_LIBRARY_ERROR_FAILED: GstLibraryError = 1;
pub const GstLibraryError_GST_LIBRARY_ERROR_TOO_LAZY: GstLibraryError = 2;
pub const GstLibraryError_GST_LIBRARY_ERROR_INIT: GstLibraryError = 3;
pub const GstLibraryError_GST_LIBRARY_ERROR_SHUTDOWN: GstLibraryError = 4;
pub const GstLibraryError_GST_LIBRARY_ERROR_SETTINGS: GstLibraryError = 5;
pub const GstLibraryError_GST_LIBRARY_ERROR_ENCODE: GstLibraryError = 6;
pub const GstLibraryError_GST_LIBRARY_ERROR_NUM_ERRORS: GstLibraryError = 7;
#[doc = " GstLibraryError:\n @GST_LIBRARY_ERROR_FAILED: a general error which doesn't fit in any other\n category.  Make sure you add a custom message to the error call.\n @GST_LIBRARY_ERROR_TOO_LAZY: do not use this except as a placeholder for\n deciding where to go while developing code.\n @GST_LIBRARY_ERROR_INIT: used when the library could not be opened.\n @GST_LIBRARY_ERROR_SHUTDOWN: used when the library could not be closed.\n @GST_LIBRARY_ERROR_SETTINGS: used when the library doesn't accept settings.\n @GST_LIBRARY_ERROR_ENCODE: used when the library generated an encoding error.\n @GST_LIBRARY_ERROR_NUM_ERRORS: the number of library error types.\n\n Library errors are for errors from the library being used by elements\n (initializing, finalizing, settings, ...)"]
pub type GstLibraryError = ::std::os::raw::c_uint;
pub const GstResourceError_GST_RESOURCE_ERROR_FAILED: GstResourceError = 1;
pub const GstResourceError_GST_RESOURCE_ERROR_TOO_LAZY: GstResourceError = 2;
pub const GstResourceError_GST_RESOURCE_ERROR_NOT_FOUND: GstResourceError = 3;
pub const GstResourceError_GST_RESOURCE_ERROR_BUSY: GstResourceError = 4;
pub const GstResourceError_GST_RESOURCE_ERROR_OPEN_READ: GstResourceError = 5;
pub const GstResourceError_GST_RESOURCE_ERROR_OPEN_WRITE: GstResourceError = 6;
pub const GstResourceError_GST_RESOURCE_ERROR_OPEN_READ_WRITE: GstResourceError = 7;
pub const GstResourceError_GST_RESOURCE_ERROR_CLOSE: GstResourceError = 8;
pub const GstResourceError_GST_RESOURCE_ERROR_READ: GstResourceError = 9;
pub const GstResourceError_GST_RESOURCE_ERROR_WRITE: GstResourceError = 10;
pub const GstResourceError_GST_RESOURCE_ERROR_SEEK: GstResourceError = 11;
pub const GstResourceError_GST_RESOURCE_ERROR_SYNC: GstResourceError = 12;
pub const GstResourceError_GST_RESOURCE_ERROR_SETTINGS: GstResourceError = 13;
pub const GstResourceError_GST_RESOURCE_ERROR_NO_SPACE_LEFT: GstResourceError = 14;
pub const GstResourceError_GST_RESOURCE_ERROR_NOT_AUTHORIZED: GstResourceError = 15;
pub const GstResourceError_GST_RESOURCE_ERROR_NUM_ERRORS: GstResourceError = 16;
#[doc = " GstResourceError:\n @GST_RESOURCE_ERROR_FAILED: a general error which doesn't fit in any other\n category.  Make sure you add a custom message to the error call.\n @GST_RESOURCE_ERROR_TOO_LAZY: do not use this except as a placeholder for\n deciding where to go while developing code.\n @GST_RESOURCE_ERROR_NOT_FOUND: used when the resource could not be found.\n @GST_RESOURCE_ERROR_BUSY: used when resource is busy.\n @GST_RESOURCE_ERROR_OPEN_READ: used when resource fails to open for reading.\n @GST_RESOURCE_ERROR_OPEN_WRITE: used when resource fails to open for writing.\n @GST_RESOURCE_ERROR_OPEN_READ_WRITE: used when resource cannot be opened for\n both reading and writing, or either (but unspecified which).\n @GST_RESOURCE_ERROR_CLOSE: used when the resource can't be closed.\n @GST_RESOURCE_ERROR_READ: used when the resource can't be read from.\n @GST_RESOURCE_ERROR_WRITE: used when the resource can't be written to.\n @GST_RESOURCE_ERROR_SEEK: used when a seek on the resource fails.\n @GST_RESOURCE_ERROR_SYNC: used when a synchronize on the resource fails.\n @GST_RESOURCE_ERROR_SETTINGS: used when settings can't be manipulated on.\n @GST_RESOURCE_ERROR_NO_SPACE_LEFT: used when the resource has no space left.\n @GST_RESOURCE_ERROR_NOT_AUTHORIZED: used when the resource can't be opened\n                                     due to missing authorization.\n                                     (Since: 1.2.4)\n @GST_RESOURCE_ERROR_NUM_ERRORS: the number of resource error types.\n\n Resource errors are for any resource used by an element:\n memory, files, network connections, process space, ...\n They're typically used by source and sink elements."]
pub type GstResourceError = ::std::os::raw::c_uint;
pub const GstStreamError_GST_STREAM_ERROR_FAILED: GstStreamError = 1;
pub const GstStreamError_GST_STREAM_ERROR_TOO_LAZY: GstStreamError = 2;
pub const GstStreamError_GST_STREAM_ERROR_NOT_IMPLEMENTED: GstStreamError = 3;
pub const GstStreamError_GST_STREAM_ERROR_TYPE_NOT_FOUND: GstStreamError = 4;
pub const GstStreamError_GST_STREAM_ERROR_WRONG_TYPE: GstStreamError = 5;
pub const GstStreamError_GST_STREAM_ERROR_CODEC_NOT_FOUND: GstStreamError = 6;
pub const GstStreamError_GST_STREAM_ERROR_DECODE: GstStreamError = 7;
pub const GstStreamError_GST_STREAM_ERROR_ENCODE: GstStreamError = 8;
pub const GstStreamError_GST_STREAM_ERROR_DEMUX: GstStreamError = 9;
pub const GstStreamError_GST_STREAM_ERROR_MUX: GstStreamError = 10;
pub const GstStreamError_GST_STREAM_ERROR_FORMAT: GstStreamError = 11;
pub const GstStreamError_GST_STREAM_ERROR_DECRYPT: GstStreamError = 12;
pub const GstStreamError_GST_STREAM_ERROR_DECRYPT_NOKEY: GstStreamError = 13;
pub const GstStreamError_GST_STREAM_ERROR_NUM_ERRORS: GstStreamError = 14;
#[doc = " GstStreamError:\n @GST_STREAM_ERROR_FAILED: a general error which doesn't fit in any other\n category.  Make sure you add a custom message to the error call.\n @GST_STREAM_ERROR_TOO_LAZY: do not use this except as a placeholder for\n deciding where to go while developing code.\n @GST_STREAM_ERROR_NOT_IMPLEMENTED: use this when you do not want to implement\n this functionality yet.\n @GST_STREAM_ERROR_TYPE_NOT_FOUND: used when the element doesn't know the\n stream's type.\n @GST_STREAM_ERROR_WRONG_TYPE: used when the element doesn't handle this type\n of stream.\n @GST_STREAM_ERROR_CODEC_NOT_FOUND: used when there's no codec to handle the\n stream's type.\n @GST_STREAM_ERROR_DECODE: used when decoding fails.\n @GST_STREAM_ERROR_ENCODE: used when encoding fails.\n @GST_STREAM_ERROR_DEMUX: used when demuxing fails.\n @GST_STREAM_ERROR_MUX: used when muxing fails.\n @GST_STREAM_ERROR_FORMAT: used when the stream is of the wrong format\n (for example, wrong caps).\n @GST_STREAM_ERROR_DECRYPT: used when the stream is encrypted and can't be\n decrypted because this is not supported by the element.\n @GST_STREAM_ERROR_DECRYPT_NOKEY: used when the stream is encrypted and\n can't be decrypted because no suitable key is available.\n @GST_STREAM_ERROR_NUM_ERRORS: the number of stream error types.\n\n Stream errors are for anything related to the stream being processed:\n format errors, media type errors, ...\n They're typically used by decoders, demuxers, converters, ..."]
pub type GstStreamError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_error_get_message(domain: GQuark, code: gint) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " gst_stream_error_quark: (attributes doc.skip=true)"]
    pub fn gst_stream_error_quark() -> GQuark;
}
unsafe extern "C" {
    #[doc = " gst_core_error_quark: (attributes doc.skip=true)"]
    pub fn gst_core_error_quark() -> GQuark;
}
unsafe extern "C" {
    #[doc = " gst_resource_error_quark: (attributes doc.skip=true)"]
    pub fn gst_resource_error_quark() -> GQuark;
}
unsafe extern "C" {
    #[doc = " gst_library_error_quark: (attributes doc.skip=true)"]
    pub fn gst_library_error_quark() -> GQuark;
}
pub type GstProxyPad = _GstProxyPad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstProxyPadPrivate {
    _unused: [u8; 0],
}
pub type GstProxyPadPrivate = _GstProxyPadPrivate;
pub type GstProxyPadClass = _GstProxyPadClass;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstProxyPad {
    pub pad: GstPad,
    pub priv_: *mut GstProxyPadPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstProxyPad"][::std::mem::size_of::<_GstProxyPad>() - 528usize];
    ["Alignment of _GstProxyPad"][::std::mem::align_of::<_GstProxyPad>() - 8usize];
    ["Offset of field: _GstProxyPad::pad"][::std::mem::offset_of!(_GstProxyPad, pad) - 0usize];
    ["Offset of field: _GstProxyPad::priv_"]
        [::std::mem::offset_of!(_GstProxyPad, priv_) - 520usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstProxyPadClass {
    pub parent_class: GstPadClass,
    pub _gst_reserved: [gpointer; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstProxyPadClass"][::std::mem::size_of::<_GstProxyPadClass>() - 240usize];
    ["Alignment of _GstProxyPadClass"][::std::mem::align_of::<_GstProxyPadClass>() - 8usize];
    ["Offset of field: _GstProxyPadClass::parent_class"]
        [::std::mem::offset_of!(_GstProxyPadClass, parent_class) - 0usize];
    ["Offset of field: _GstProxyPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstProxyPadClass, _gst_reserved) - 232usize];
};
unsafe extern "C" {
    pub fn gst_proxy_pad_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_proxy_pad_get_internal(pad: *mut GstProxyPad) -> *mut GstProxyPad;
}
unsafe extern "C" {
    pub fn gst_proxy_pad_iterate_internal_links_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
    ) -> *mut GstIterator;
}
unsafe extern "C" {
    pub fn gst_proxy_pad_chain_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        buffer: *mut GstBuffer,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_proxy_pad_chain_list_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        list: *mut GstBufferList,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_proxy_pad_getrange_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        offset: guint64,
        size: guint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
}
#[doc = " GstGhostPad:\n\n Opaque #GstGhostPad structure."]
pub type GstGhostPad = _GstGhostPad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstGhostPadPrivate {
    _unused: [u8; 0],
}
pub type GstGhostPadPrivate = _GstGhostPadPrivate;
pub type GstGhostPadClass = _GstGhostPadClass;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstGhostPad {
    pub pad: GstProxyPad,
    pub priv_: *mut GstGhostPadPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstGhostPad"][::std::mem::size_of::<_GstGhostPad>() - 536usize];
    ["Alignment of _GstGhostPad"][::std::mem::align_of::<_GstGhostPad>() - 8usize];
    ["Offset of field: _GstGhostPad::pad"][::std::mem::offset_of!(_GstGhostPad, pad) - 0usize];
    ["Offset of field: _GstGhostPad::priv_"]
        [::std::mem::offset_of!(_GstGhostPad, priv_) - 528usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstGhostPadClass {
    pub parent_class: GstProxyPadClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstGhostPadClass"][::std::mem::size_of::<_GstGhostPadClass>() - 272usize];
    ["Alignment of _GstGhostPadClass"][::std::mem::align_of::<_GstGhostPadClass>() - 8usize];
    ["Offset of field: _GstGhostPadClass::parent_class"]
        [::std::mem::offset_of!(_GstGhostPadClass, parent_class) - 0usize];
    ["Offset of field: _GstGhostPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstGhostPadClass, _gst_reserved) - 240usize];
};
unsafe extern "C" {
    pub fn gst_ghost_pad_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_new(name: *const gchar, target: *mut GstPad) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_new_no_target(name: *const gchar, dir: GstPadDirection) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_new_from_template(
        name: *const gchar,
        target: *mut GstPad,
        templ: *mut GstPadTemplate,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_new_no_target_from_template(
        name: *const gchar,
        templ: *mut GstPadTemplate,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_get_target(gpad: *mut GstGhostPad) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_set_target(gpad: *mut GstGhostPad, newtarget: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_construct(gpad: *mut GstGhostPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_activate_mode_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        mode: GstPadMode,
        active: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_ghost_pad_internal_activate_mode_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        mode: GstPadMode,
        active: gboolean,
    ) -> gboolean;
}
pub type GstGhostPad_autoptr = *mut GstGhostPad;
pub type GstGhostPad_listautoptr = *mut GList;
pub type GstGhostPad_slistautoptr = *mut GSList;
pub type GstGhostPad_queueautoptr = *mut GQueue;
pub type GstProxyPad_autoptr = *mut GstProxyPad;
pub type GstProxyPad_listautoptr = *mut GList;
pub type GstProxyPad_slistautoptr = *mut GSList;
pub type GstProxyPad_queueautoptr = *mut GQueue;
pub const GstDebugLevel_GST_LEVEL_NONE: GstDebugLevel = 0;
pub const GstDebugLevel_GST_LEVEL_ERROR: GstDebugLevel = 1;
pub const GstDebugLevel_GST_LEVEL_WARNING: GstDebugLevel = 2;
pub const GstDebugLevel_GST_LEVEL_FIXME: GstDebugLevel = 3;
pub const GstDebugLevel_GST_LEVEL_INFO: GstDebugLevel = 4;
pub const GstDebugLevel_GST_LEVEL_DEBUG: GstDebugLevel = 5;
pub const GstDebugLevel_GST_LEVEL_LOG: GstDebugLevel = 6;
pub const GstDebugLevel_GST_LEVEL_TRACE: GstDebugLevel = 7;
pub const GstDebugLevel_GST_LEVEL_MEMDUMP: GstDebugLevel = 9;
pub const GstDebugLevel_GST_LEVEL_COUNT: GstDebugLevel = 10;
#[doc = " GstDebugLevel:\n @GST_LEVEL_NONE: No debugging level specified or desired. Used to deactivate\n  debugging output.\n @GST_LEVEL_ERROR: Error messages are to be used only when an error occurred\n  that stops the application from keeping working correctly.\n  An examples is gst_element_error, which outputs a message with this priority.\n  It does not mean that the application is terminating as with g_error.\n @GST_LEVEL_WARNING: Warning messages are to inform about abnormal behaviour\n  that could lead to problems or weird behaviour later on. An example of this\n  would be clocking issues (\"your computer is pretty slow\") or broken input\n  data (\"Can't synchronize to stream.\")\n @GST_LEVEL_FIXME: Fixme messages are messages that indicate that something\n  in the executed code path is not fully implemented or handled yet. Note\n  that this does not replace proper error handling in any way, the purpose\n  of this message is to make it easier to spot incomplete/unfinished pieces\n  of code when reading the debug log.\n @GST_LEVEL_INFO: Informational messages should be used to keep the developer\n  updated about what is happening.\n  Examples where this should be used are when a typefind function has\n  successfully determined the type of the stream or when an mp3 plugin detects\n  the format to be used. (\"This file has mono sound.\")\n @GST_LEVEL_DEBUG: Debugging messages should be used when something common\n  happens that is not the expected default behavior, or something that's\n  useful to know but doesn't happen all the time (ie. per loop iteration or\n  buffer processed or event handled).\n  An example would be notifications about state changes or receiving/sending\n  of events.\n @GST_LEVEL_LOG: Log messages are messages that are very common but might be\n  useful to know. As a rule of thumb a pipeline that is running as expected\n  should never output anything else but LOG messages whilst processing data.\n  Use this log level to log recurring information in chain functions and\n  loop functions, for example.\n @GST_LEVEL_TRACE: Tracing-related messages.\n  Examples for this are referencing/dereferencing of objects.\n @GST_LEVEL_MEMDUMP: memory dump messages are used to log (small) chunks of\n  data as memory dumps in the log. They will be displayed as hexdump with\n  ASCII characters.\n @GST_LEVEL_COUNT: The number of defined debugging levels.\n\n The level defines the importance of a debugging message. The more important a\n message is, the greater the probability that the debugging system outputs it."]
pub type GstDebugLevel = ::std::os::raw::c_uint;
pub const GstDebugColorFlags_GST_DEBUG_FG_BLACK: GstDebugColorFlags = 0;
pub const GstDebugColorFlags_GST_DEBUG_FG_RED: GstDebugColorFlags = 1;
pub const GstDebugColorFlags_GST_DEBUG_FG_GREEN: GstDebugColorFlags = 2;
pub const GstDebugColorFlags_GST_DEBUG_FG_YELLOW: GstDebugColorFlags = 3;
pub const GstDebugColorFlags_GST_DEBUG_FG_BLUE: GstDebugColorFlags = 4;
pub const GstDebugColorFlags_GST_DEBUG_FG_MAGENTA: GstDebugColorFlags = 5;
pub const GstDebugColorFlags_GST_DEBUG_FG_CYAN: GstDebugColorFlags = 6;
pub const GstDebugColorFlags_GST_DEBUG_FG_WHITE: GstDebugColorFlags = 7;
pub const GstDebugColorFlags_GST_DEBUG_BG_BLACK: GstDebugColorFlags = 0;
pub const GstDebugColorFlags_GST_DEBUG_BG_RED: GstDebugColorFlags = 16;
pub const GstDebugColorFlags_GST_DEBUG_BG_GREEN: GstDebugColorFlags = 32;
pub const GstDebugColorFlags_GST_DEBUG_BG_YELLOW: GstDebugColorFlags = 48;
pub const GstDebugColorFlags_GST_DEBUG_BG_BLUE: GstDebugColorFlags = 64;
pub const GstDebugColorFlags_GST_DEBUG_BG_MAGENTA: GstDebugColorFlags = 80;
pub const GstDebugColorFlags_GST_DEBUG_BG_CYAN: GstDebugColorFlags = 96;
pub const GstDebugColorFlags_GST_DEBUG_BG_WHITE: GstDebugColorFlags = 112;
pub const GstDebugColorFlags_GST_DEBUG_BOLD: GstDebugColorFlags = 256;
pub const GstDebugColorFlags_GST_DEBUG_UNDERLINE: GstDebugColorFlags = 512;
#[doc = " GstDebugColorFlags:\n @GST_DEBUG_FG_BLACK: Use black as foreground color.\n @GST_DEBUG_FG_RED: Use red as foreground color.\n @GST_DEBUG_FG_GREEN: Use green as foreground color.\n @GST_DEBUG_FG_YELLOW: Use yellow as foreground color.\n @GST_DEBUG_FG_BLUE: Use blue as foreground color.\n @GST_DEBUG_FG_MAGENTA: Use magenta as foreground color.\n @GST_DEBUG_FG_CYAN: Use cyan as foreground color.\n @GST_DEBUG_FG_WHITE: Use white as foreground color.\n @GST_DEBUG_BG_BLACK: Use black as background color.\n @GST_DEBUG_BG_RED: Use red as background color.\n @GST_DEBUG_BG_GREEN: Use green as background color.\n @GST_DEBUG_BG_YELLOW: Use yellow as background color.\n @GST_DEBUG_BG_BLUE: Use blue as background color.\n @GST_DEBUG_BG_MAGENTA: Use magenta as background color.\n @GST_DEBUG_BG_CYAN: Use cyan as background color.\n @GST_DEBUG_BG_WHITE: Use white as background color.\n @GST_DEBUG_BOLD: Make the output bold.\n @GST_DEBUG_UNDERLINE: Underline the output.\n\n These are some terminal style flags you can use when creating your\n debugging categories to make them stand out in debugging output."]
pub type GstDebugColorFlags = ::std::os::raw::c_uint;
pub const GstStackTraceFlags_GST_STACK_TRACE_SHOW_NONE: GstStackTraceFlags = 0;
pub const GstStackTraceFlags_GST_STACK_TRACE_SHOW_FULL: GstStackTraceFlags = 1;
#[doc = " GstStackTraceFlags:\n @GST_STACK_TRACE_SHOW_NONE: Try to retrieve the minimum information\n                             available, which may be none on some platforms\n                             (Since: 1.18)\n @GST_STACK_TRACE_SHOW_FULL: Try to retrieve as much information as possible,\n                             including source information when getting the\n                             stack trace\n\n Since: 1.12"]
pub type GstStackTraceFlags = ::std::os::raw::c_uint;
pub const GstDebugColorMode_GST_DEBUG_COLOR_MODE_OFF: GstDebugColorMode = 0;
pub const GstDebugColorMode_GST_DEBUG_COLOR_MODE_ON: GstDebugColorMode = 1;
pub const GstDebugColorMode_GST_DEBUG_COLOR_MODE_UNIX: GstDebugColorMode = 2;
#[doc = " GstDebugColorMode:\n @GST_DEBUG_COLOR_MODE_OFF: Do not use colors in logs.\n @GST_DEBUG_COLOR_MODE_ON: Paint logs in a platform-specific way.\n @GST_DEBUG_COLOR_MODE_UNIX: Paint logs with UNIX terminal color codes\n                             no matter what platform GStreamer is running on."]
pub type GstDebugColorMode = ::std::os::raw::c_uint;
#[doc = " GstDebugCategory:\n\n This is the struct that describes the categories. Once initialized with\n #GST_DEBUG_CATEGORY_INIT, its values can't be changed anymore."]
pub type GstDebugCategory = _GstDebugCategory;
#[doc = " GstDebugCategory:\n\n This is the struct that describes the categories. Once initialized with\n #GST_DEBUG_CATEGORY_INIT, its values can't be changed anymore."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDebugCategory {
    pub threshold: gint,
    pub color: guint,
    pub name: *const gchar,
    pub description: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstDebugCategory"][::std::mem::size_of::<_GstDebugCategory>() - 24usize];
    ["Alignment of _GstDebugCategory"][::std::mem::align_of::<_GstDebugCategory>() - 8usize];
    ["Offset of field: _GstDebugCategory::threshold"]
        [::std::mem::offset_of!(_GstDebugCategory, threshold) - 0usize];
    ["Offset of field: _GstDebugCategory::color"]
        [::std::mem::offset_of!(_GstDebugCategory, color) - 4usize];
    ["Offset of field: _GstDebugCategory::name"]
        [::std::mem::offset_of!(_GstDebugCategory, name) - 8usize];
    ["Offset of field: _GstDebugCategory::description"]
        [::std::mem::offset_of!(_GstDebugCategory, description) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstDebugMessage {
    _unused: [u8; 0],
}
pub type GstDebugMessage = _GstDebugMessage;
#[doc = " GstLogFunction:\n @category: a #GstDebugCategory\n @level: a #GstDebugLevel\n @file: file name\n @function: function name\n @line: line number\n @object: a #GObject\n @message: the message\n @user_data: user data for the log function\n\n Function prototype for a logging function that can be registered with\n gst_debug_add_log_function().\n Use G_GNUC_NO_INSTRUMENT on that function."]
pub type GstLogFunction = ::std::option::Option<
    unsafe extern "C" fn(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        message: *mut GstDebugMessage,
        user_data: gpointer,
    ),
>;
unsafe extern "C" {
    pub fn gst_debug_log(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn gst_debug_log_valist(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_debug_log_literal(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        message_string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn _gst_debug_category_new(
        name: *const gchar,
        color: guint,
        description: *const gchar,
    ) -> *mut GstDebugCategory;
}
unsafe extern "C" {
    pub fn _gst_debug_get_category(name: *const gchar) -> *mut GstDebugCategory;
}
unsafe extern "C" {
    pub fn _gst_debug_dump_mem(
        cat: *mut GstDebugCategory,
        file: *const gchar,
        func: *const gchar,
        line: gint,
        obj: *mut GObject,
        msg: *const gchar,
        data: *const guint8,
        length: guint,
    );
}
#[doc = " GstDebugFuncPtr: (attributes doc.skip=true)\n we define this to avoid a compiler warning regarding a cast from a function\n pointer to a void pointer\n (see https://bugzilla.gnome.org/show_bug.cgi?id=309253)"]
pub type GstDebugFuncPtr = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn _gst_debug_register_funcptr(func: GstDebugFuncPtr, ptrname: *const gchar);
}
unsafe extern "C" {
    pub fn _gst_debug_nameof_funcptr(func: GstDebugFuncPtr) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_debug_message_get(message: *mut GstDebugMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_debug_log_get_line(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        message: *mut GstDebugMessage,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_debug_log_default(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const gchar,
        function: *const gchar,
        line: gint,
        object: *mut GObject,
        message: *mut GstDebugMessage,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn gst_debug_level_get_name(level: GstDebugLevel) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_debug_add_log_function(
        func: GstLogFunction,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_debug_remove_log_function(func: GstLogFunction) -> guint;
}
unsafe extern "C" {
    pub fn gst_debug_remove_log_function_by_data(data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn gst_debug_set_active(active: gboolean);
}
unsafe extern "C" {
    pub fn gst_debug_is_active() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_debug_set_colored(colored: gboolean);
}
unsafe extern "C" {
    pub fn gst_debug_set_color_mode(mode: GstDebugColorMode);
}
unsafe extern "C" {
    pub fn gst_debug_set_color_mode_from_string(mode: *const gchar);
}
unsafe extern "C" {
    pub fn gst_debug_is_colored() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_debug_get_color_mode() -> GstDebugColorMode;
}
unsafe extern "C" {
    pub fn gst_debug_set_default_threshold(level: GstDebugLevel);
}
unsafe extern "C" {
    pub fn gst_debug_get_default_threshold() -> GstDebugLevel;
}
unsafe extern "C" {
    pub fn gst_debug_set_threshold_for_name(name: *const gchar, level: GstDebugLevel);
}
unsafe extern "C" {
    pub fn gst_debug_set_threshold_from_string(list: *const gchar, reset: gboolean);
}
unsafe extern "C" {
    pub fn gst_debug_unset_threshold_for_name(name: *const gchar);
}
unsafe extern "C" {
    pub fn gst_debug_category_free(category: *mut GstDebugCategory);
}
unsafe extern "C" {
    pub fn gst_debug_category_set_threshold(category: *mut GstDebugCategory, level: GstDebugLevel);
}
unsafe extern "C" {
    pub fn gst_debug_category_reset_threshold(category: *mut GstDebugCategory);
}
unsafe extern "C" {
    pub fn gst_debug_category_get_threshold(category: *mut GstDebugCategory) -> GstDebugLevel;
}
unsafe extern "C" {
    pub fn gst_debug_category_get_name(category: *mut GstDebugCategory) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_debug_category_get_color(category: *mut GstDebugCategory) -> guint;
}
unsafe extern "C" {
    pub fn gst_debug_category_get_description(category: *mut GstDebugCategory) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_debug_get_all_categories() -> *mut GSList;
}
unsafe extern "C" {
    pub fn gst_debug_construct_term_color(colorinfo: guint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_debug_construct_win_color(colorinfo: guint) -> gint;
}
unsafe extern "C" {
    pub fn gst_info_vasprintf(
        result: *mut *mut gchar,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_info_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_info_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_print(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_println(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_printerr(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn gst_printerrln(format: *const gchar, ...);
}
unsafe extern "C" {
    #[doc = " GST_CAT_DEFAULT:\n\n Default gstreamer core debug log category. Please define your own."]
    pub static mut GST_CAT_DEFAULT: *mut GstDebugCategory;
}
unsafe extern "C" {
    pub static mut _gst_debug_enabled: gboolean;
}
unsafe extern "C" {
    pub static mut _gst_debug_min: GstDebugLevel;
}
unsafe extern "C" {
    pub fn gst_debug_print_stack_trace();
}
unsafe extern "C" {
    pub fn gst_debug_get_stack_trace(flags: GstStackTraceFlags) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_debug_add_ring_buffer_logger(max_size_per_thread: guint, thread_timeout: guint);
}
unsafe extern "C" {
    pub fn gst_debug_remove_ring_buffer_logger();
}
unsafe extern "C" {
    pub fn gst_debug_ring_buffer_logger_get_logs() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub static mut _gst_int_range_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_int64_range_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_double_range_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_fraction_range_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_value_list_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_value_array_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_fraction_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_bitmask_type: GType;
}
unsafe extern "C" {
    pub static mut _gst_flagset_type: GType;
}
#[doc = " GstValueCompareFunc:\n @value1: first value for comparison\n @value2: second value for comparison\n\n Used together with gst_value_compare() to compare #GValue items.\n\n Returns: one of GST_VALUE_LESS_THAN, GST_VALUE_EQUAL, GST_VALUE_GREATER_THAN\n or GST_VALUE_UNORDERED"]
pub type GstValueCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(value1: *const GValue, value2: *const GValue) -> gint,
>;
#[doc = " GstValueSerializeFunc:\n @value1: a #GValue\n\n Used by gst_value_serialize() to obtain a non-binary form of the #GValue.\n\n Free-function: g_free\n\n Returns: (transfer full): the string representation of the value"]
pub type GstValueSerializeFunc =
    ::std::option::Option<unsafe extern "C" fn(value1: *const GValue) -> *mut gchar>;
#[doc = " GstValueDeserializeFunc:\n @dest: a #GValue\n @s: a string\n\n Used by gst_value_deserialize() to parse a non-binary form into the #GValue.\n\n Returns: %TRUE for success"]
pub type GstValueDeserializeFunc =
    ::std::option::Option<unsafe extern "C" fn(dest: *mut GValue, s: *const gchar) -> gboolean>;
#[doc = " GstValueDeserializeWithPSpecFunc:\n @dest: a #GValue\n @s: a string\n @pspec: a #GParamSpec describing the expected value\n\n Used by gst_value_deserialize_with_pspec() to parse a non-binary form into the #GValue.\n\n Returns: %TRUE for success\n Since: 1.20"]
pub type GstValueDeserializeWithPSpecFunc = ::std::option::Option<
    unsafe extern "C" fn(dest: *mut GValue, s: *const gchar, pspec: *mut GParamSpec) -> gboolean,
>;
#[doc = " GstValueTable:\n @type: a #GType\n @compare: a #GstValueCompareFunc\n @serialize: a #GstValueSerializeFunc\n @deserialize: a #GstValueDeserializeFunc\n @deserialize_with_pspec: a #GstValueDeserializeWithPSpecFunc\n\n VTable for the #GValue @type."]
pub type GstValueTable = _GstValueTable;
#[doc = " GstValueTable:\n @type: a #GType\n @compare: a #GstValueCompareFunc\n @serialize: a #GstValueSerializeFunc\n @deserialize: a #GstValueDeserializeFunc\n @deserialize_with_pspec: a #GstValueDeserializeWithPSpecFunc\n\n VTable for the #GValue @type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstValueTable {
    pub type_: GType,
    pub compare: GstValueCompareFunc,
    pub serialize: GstValueSerializeFunc,
    pub deserialize: GstValueDeserializeFunc,
    #[doc = " GstValueTable.deserialize_with_pspec:\n\n a #GstValueDeserializeWithPSpecFunc\n\n Since: 1.20"]
    pub deserialize_with_pspec: GstValueDeserializeWithPSpecFunc,
    pub _gst_reserved: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstValueTable"][::std::mem::size_of::<_GstValueTable>() - 64usize];
    ["Alignment of _GstValueTable"][::std::mem::align_of::<_GstValueTable>() - 8usize];
    ["Offset of field: _GstValueTable::type_"]
        [::std::mem::offset_of!(_GstValueTable, type_) - 0usize];
    ["Offset of field: _GstValueTable::compare"]
        [::std::mem::offset_of!(_GstValueTable, compare) - 8usize];
    ["Offset of field: _GstValueTable::serialize"]
        [::std::mem::offset_of!(_GstValueTable, serialize) - 16usize];
    ["Offset of field: _GstValueTable::deserialize"]
        [::std::mem::offset_of!(_GstValueTable, deserialize) - 24usize];
    ["Offset of field: _GstValueTable::deserialize_with_pspec"]
        [::std::mem::offset_of!(_GstValueTable, deserialize_with_pspec) - 32usize];
    ["Offset of field: _GstValueTable::_gst_reserved"]
        [::std::mem::offset_of!(_GstValueTable, _gst_reserved) - 40usize];
};
unsafe extern "C" {
    pub fn gst_int_range_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_int64_range_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_double_range_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_fraction_range_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_fraction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_value_list_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_value_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_bitmask_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_flagset_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_g_thread_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_value_register(table: *const GstValueTable);
}
unsafe extern "C" {
    pub fn gst_value_init_and_copy(dest: *mut GValue, src: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_serialize(value: *const GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_value_deserialize(dest: *mut GValue, src: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_deserialize_with_pspec(
        dest: *mut GValue,
        src: *const gchar,
        pspec: *mut GParamSpec,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_list_append_value(value: *mut GValue, append_value: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_list_append_and_take_value(value: *mut GValue, append_value: *mut GValue);
}
unsafe extern "C" {
    pub fn gst_value_list_prepend_value(value: *mut GValue, prepend_value: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_list_concat(dest: *mut GValue, value1: *const GValue, value2: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_list_merge(dest: *mut GValue, value1: *const GValue, value2: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_list_get_size(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn gst_value_list_get_value(value: *const GValue, index: guint) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_value_list_init(value: *mut GValue, prealloc: guint) -> *mut GValue;
}
unsafe extern "C" {
    pub fn gst_value_array_append_value(value: *mut GValue, append_value: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_array_append_and_take_value(value: *mut GValue, append_value: *mut GValue);
}
unsafe extern "C" {
    pub fn gst_value_array_prepend_value(value: *mut GValue, prepend_value: *const GValue);
}
unsafe extern "C" {
    pub fn gst_value_array_get_size(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn gst_value_array_get_value(value: *const GValue, index: guint) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_value_array_init(value: *mut GValue, prealloc: guint) -> *mut GValue;
}
unsafe extern "C" {
    pub fn gst_value_set_int_range(value: *mut GValue, start: gint, end: gint);
}
unsafe extern "C" {
    pub fn gst_value_set_int_range_step(value: *mut GValue, start: gint, end: gint, step: gint);
}
unsafe extern "C" {
    pub fn gst_value_get_int_range_min(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_get_int_range_max(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_get_int_range_step(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_set_int64_range(value: *mut GValue, start: gint64, end: gint64);
}
unsafe extern "C" {
    pub fn gst_value_set_int64_range_step(
        value: *mut GValue,
        start: gint64,
        end: gint64,
        step: gint64,
    );
}
unsafe extern "C" {
    pub fn gst_value_get_int64_range_min(value: *const GValue) -> gint64;
}
unsafe extern "C" {
    pub fn gst_value_get_int64_range_max(value: *const GValue) -> gint64;
}
unsafe extern "C" {
    pub fn gst_value_get_int64_range_step(value: *const GValue) -> gint64;
}
unsafe extern "C" {
    pub fn gst_value_set_double_range(value: *mut GValue, start: gdouble, end: gdouble);
}
unsafe extern "C" {
    pub fn gst_value_get_double_range_min(value: *const GValue) -> gdouble;
}
unsafe extern "C" {
    pub fn gst_value_get_double_range_max(value: *const GValue) -> gdouble;
}
unsafe extern "C" {
    pub fn gst_value_get_caps(value: *const GValue) -> *const GstCaps;
}
unsafe extern "C" {
    pub fn gst_value_set_caps(value: *mut GValue, caps: *const GstCaps);
}
unsafe extern "C" {
    pub fn gst_value_get_structure(value: *const GValue) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_value_set_structure(value: *mut GValue, structure: *const GstStructure);
}
unsafe extern "C" {
    pub fn gst_value_get_caps_features(value: *const GValue) -> *const GstCapsFeatures;
}
unsafe extern "C" {
    pub fn gst_value_set_caps_features(value: *mut GValue, features: *const GstCapsFeatures);
}
unsafe extern "C" {
    pub fn gst_value_set_fraction(value: *mut GValue, numerator: gint, denominator: gint);
}
unsafe extern "C" {
    pub fn gst_value_get_fraction_numerator(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_get_fraction_denominator(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_fraction_multiply(
        product: *mut GValue,
        factor1: *const GValue,
        factor2: *const GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_fraction_subtract(
        dest: *mut GValue,
        minuend: *const GValue,
        subtrahend: *const GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_set_fraction_range(
        value: *mut GValue,
        start: *const GValue,
        end: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_value_set_fraction_range_full(
        value: *mut GValue,
        numerator_start: gint,
        denominator_start: gint,
        numerator_end: gint,
        denominator_end: gint,
    );
}
unsafe extern "C" {
    pub fn gst_value_get_fraction_range_min(value: *const GValue) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_value_get_fraction_range_max(value: *const GValue) -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_value_get_bitmask(value: *const GValue) -> guint64;
}
unsafe extern "C" {
    pub fn gst_value_set_bitmask(value: *mut GValue, bitmask: guint64);
}
unsafe extern "C" {
    pub fn gst_value_set_flagset(value: *mut GValue, flags: guint, mask: guint);
}
unsafe extern "C" {
    pub fn gst_value_get_flagset_flags(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn gst_value_get_flagset_mask(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn gst_value_compare(value1: *const GValue, value2: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn gst_value_can_compare(value1: *const GValue, value2: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_is_subset(value1: *const GValue, value2: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_union(
        dest: *mut GValue,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_can_union(value1: *const GValue, value2: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_intersect(
        dest: *mut GValue,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_can_intersect(value1: *const GValue, value2: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_subtract(
        dest: *mut GValue,
        minuend: *const GValue,
        subtrahend: *const GValue,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_can_subtract(minuend: *const GValue, subtrahend: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_is_fixed(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_value_fixate(dest: *mut GValue, src: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_flagset_register(flags_type: GType) -> GType;
}
unsafe extern "C" {
    pub fn gst_param_spec_fraction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_param_spec_array_get_type() -> GType;
}
#[doc = " GstParamSpecFraction:\n @parent_instance: super class\n @min_num: minimal numerator\n @min_den: minimal denominator\n @max_num: maximal numerator\n @max_den: maximal denominator\n @def_num: default numerator\n @def_den: default denominator\n\n A GParamSpec derived structure that contains the meta data for fractional\n properties."]
pub type GstParamSpecFraction = _GstParamSpecFraction;
#[doc = " GstParamSpecArray:\n @parent_instance: super class\n @element_spec: the #GParamSpec of the type of values in the array\n\n A GParamSpec derived structure for arrays of values."]
pub type GstParamSpecArray = _GstParamSpecArray;
#[doc = " GstParamSpecFraction:\n @parent_instance: super class\n @min_num: minimal numerator\n @min_den: minimal denominator\n @max_num: maximal numerator\n @max_den: maximal denominator\n @def_num: default numerator\n @def_den: default denominator\n\n A GParamSpec derived structure that contains the meta data for fractional\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstParamSpecFraction {
    pub parent_instance: GParamSpec,
    pub min_num: gint,
    pub min_den: gint,
    pub max_num: gint,
    pub max_den: gint,
    pub def_num: gint,
    pub def_den: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstParamSpecFraction"][::std::mem::size_of::<_GstParamSpecFraction>() - 96usize];
    ["Alignment of _GstParamSpecFraction"]
        [::std::mem::align_of::<_GstParamSpecFraction>() - 8usize];
    ["Offset of field: _GstParamSpecFraction::parent_instance"]
        [::std::mem::offset_of!(_GstParamSpecFraction, parent_instance) - 0usize];
    ["Offset of field: _GstParamSpecFraction::min_num"]
        [::std::mem::offset_of!(_GstParamSpecFraction, min_num) - 72usize];
    ["Offset of field: _GstParamSpecFraction::min_den"]
        [::std::mem::offset_of!(_GstParamSpecFraction, min_den) - 76usize];
    ["Offset of field: _GstParamSpecFraction::max_num"]
        [::std::mem::offset_of!(_GstParamSpecFraction, max_num) - 80usize];
    ["Offset of field: _GstParamSpecFraction::max_den"]
        [::std::mem::offset_of!(_GstParamSpecFraction, max_den) - 84usize];
    ["Offset of field: _GstParamSpecFraction::def_num"]
        [::std::mem::offset_of!(_GstParamSpecFraction, def_num) - 88usize];
    ["Offset of field: _GstParamSpecFraction::def_den"]
        [::std::mem::offset_of!(_GstParamSpecFraction, def_den) - 92usize];
};
#[doc = " GstParamSpecArray:\n @parent_instance: super class\n @element_spec: the #GParamSpec of the type of values in the array\n\n A GParamSpec derived structure for arrays of values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstParamSpecArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstParamSpecArray"][::std::mem::size_of::<_GstParamSpecArray>() - 80usize];
    ["Alignment of _GstParamSpecArray"][::std::mem::align_of::<_GstParamSpecArray>() - 8usize];
    ["Offset of field: _GstParamSpecArray::parent_instance"]
        [::std::mem::offset_of!(_GstParamSpecArray, parent_instance) - 0usize];
    ["Offset of field: _GstParamSpecArray::element_spec"]
        [::std::mem::offset_of!(_GstParamSpecArray, element_spec) - 72usize];
};
unsafe extern "C" {
    pub fn gst_param_spec_fraction(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        min_num: gint,
        min_denom: gint,
        max_num: gint,
        max_denom: gint,
        default_num: gint,
        default_denom: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn gst_param_spec_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
#[doc = " GstPipeline:\n @fixed_clock: The fixed clock of the pipeline, used when\n               GST_PIPELINE_FLAG_FIXED_CLOCK is set.\n @stream_time: The stream time of the pipeline. A better name for this\n         property would be the running_time, the total time spent in the\n         PLAYING state without being flushed. (deprecated, use the start_time\n         on GstElement).\n @delay: Extra delay added to base_time to compensate for computing delays\n         when setting elements to PLAYING.\n\n The #GstPipeline structure."]
pub type GstPipeline = _GstPipeline;
pub type GstPipelineClass = _GstPipelineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPipelinePrivate {
    _unused: [u8; 0],
}
pub type GstPipelinePrivate = _GstPipelinePrivate;
pub const GstPipelineFlags_GST_PIPELINE_FLAG_FIXED_CLOCK: GstPipelineFlags = 524288;
pub const GstPipelineFlags_GST_PIPELINE_FLAG_LAST: GstPipelineFlags = 8388608;
#[doc = " GstPipelineFlags:\n @GST_PIPELINE_FLAG_FIXED_CLOCK: this pipeline works with a fixed clock\n @GST_PIPELINE_FLAG_LAST: offset to define more flags\n\n Pipeline flags"]
pub type GstPipelineFlags = ::std::os::raw::c_uint;
#[doc = " GstPipeline:\n @fixed_clock: The fixed clock of the pipeline, used when\n               GST_PIPELINE_FLAG_FIXED_CLOCK is set.\n @stream_time: The stream time of the pipeline. A better name for this\n         property would be the running_time, the total time spent in the\n         PLAYING state without being flushed. (deprecated, use the start_time\n         on GstElement).\n @delay: Extra delay added to base_time to compensate for computing delays\n         when setting elements to PLAYING.\n\n The #GstPipeline structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstPipeline {
    pub bin: GstBin,
    pub fixed_clock: *mut GstClock,
    pub stream_time: GstClockTime,
    pub delay: GstClockTime,
    pub priv_: *mut GstPipelinePrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPipeline"][::std::mem::size_of::<_GstPipeline>() - 440usize];
    ["Alignment of _GstPipeline"][::std::mem::align_of::<_GstPipeline>() - 8usize];
    ["Offset of field: _GstPipeline::bin"][::std::mem::offset_of!(_GstPipeline, bin) - 0usize];
    ["Offset of field: _GstPipeline::fixed_clock"]
        [::std::mem::offset_of!(_GstPipeline, fixed_clock) - 376usize];
    ["Offset of field: _GstPipeline::stream_time"]
        [::std::mem::offset_of!(_GstPipeline, stream_time) - 384usize];
    ["Offset of field: _GstPipeline::delay"]
        [::std::mem::offset_of!(_GstPipeline, delay) - 392usize];
    ["Offset of field: _GstPipeline::priv_"]
        [::std::mem::offset_of!(_GstPipeline, priv_) - 400usize];
    ["Offset of field: _GstPipeline::_gst_reserved"]
        [::std::mem::offset_of!(_GstPipeline, _gst_reserved) - 408usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPipelineClass {
    pub parent_class: GstBinClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPipelineClass"][::std::mem::size_of::<_GstPipelineClass>() - 608usize];
    ["Alignment of _GstPipelineClass"][::std::mem::align_of::<_GstPipelineClass>() - 8usize];
    ["Offset of field: _GstPipelineClass::parent_class"]
        [::std::mem::offset_of!(_GstPipelineClass, parent_class) - 0usize];
    ["Offset of field: _GstPipelineClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstPipelineClass, _gst_reserved) - 576usize];
};
unsafe extern "C" {
    pub fn gst_pipeline_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_pipeline_new(name: *const gchar) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_pipeline_get_bus(pipeline: *mut GstPipeline) -> *mut GstBus;
}
unsafe extern "C" {
    pub fn gst_pipeline_use_clock(pipeline: *mut GstPipeline, clock: *mut GstClock);
}
unsafe extern "C" {
    pub fn gst_pipeline_set_clock(pipeline: *mut GstPipeline, clock: *mut GstClock) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pipeline_get_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_pipeline_get_pipeline_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_pipeline_auto_clock(pipeline: *mut GstPipeline);
}
unsafe extern "C" {
    pub fn gst_pipeline_set_delay(pipeline: *mut GstPipeline, delay: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_pipeline_get_delay(pipeline: *mut GstPipeline) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_pipeline_set_latency(pipeline: *mut GstPipeline, latency: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_pipeline_get_latency(pipeline: *mut GstPipeline) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_pipeline_set_auto_flush_bus(pipeline: *mut GstPipeline, auto_flush: gboolean);
}
unsafe extern "C" {
    pub fn gst_pipeline_get_auto_flush_bus(pipeline: *mut GstPipeline) -> gboolean;
}
pub type GstPipeline_autoptr = *mut GstPipeline;
pub type GstPipeline_listautoptr = *mut GList;
pub type GstPipeline_slistautoptr = *mut GSList;
pub type GstPipeline_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPoll {
    _unused: [u8; 0],
}
#[doc = " GstPoll:\n\n A set of file/network descriptors."]
pub type GstPoll = _GstPoll;
#[doc = " GstPollFD:\n @fd: a file descriptor\n\n A file descriptor object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstPollFD {
    pub fd: ::std::os::raw::c_int,
    pub idx: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstPollFD"][::std::mem::size_of::<GstPollFD>() - 8usize];
    ["Alignment of GstPollFD"][::std::mem::align_of::<GstPollFD>() - 4usize];
    ["Offset of field: GstPollFD::fd"][::std::mem::offset_of!(GstPollFD, fd) - 0usize];
    ["Offset of field: GstPollFD::idx"][::std::mem::offset_of!(GstPollFD, idx) - 4usize];
};
unsafe extern "C" {
    pub fn gst_poll_new(controllable: gboolean) -> *mut GstPoll;
}
unsafe extern "C" {
    pub fn gst_poll_new_timer() -> *mut GstPoll;
}
unsafe extern "C" {
    pub fn gst_poll_free(set: *mut GstPoll);
}
unsafe extern "C" {
    pub fn gst_poll_get_read_gpollfd(set: *mut GstPoll, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn gst_poll_fd_init(fd: *mut GstPollFD);
}
unsafe extern "C" {
    pub fn gst_poll_add_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_remove_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_ctl_write(
        set: *mut GstPoll,
        fd: *mut GstPollFD,
        active: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_ctl_read(
        set: *mut GstPoll,
        fd: *mut GstPollFD,
        active: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_ctl_pri(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean)
    -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_ignored(set: *mut GstPoll, fd: *mut GstPollFD);
}
unsafe extern "C" {
    pub fn gst_poll_fd_has_closed(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_has_error(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_can_read(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_can_write(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_fd_has_pri(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_wait(set: *mut GstPoll, timeout: GstClockTime) -> gint;
}
unsafe extern "C" {
    pub fn gst_poll_set_controllable(set: *mut GstPoll, controllable: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_restart(set: *mut GstPoll);
}
unsafe extern "C" {
    pub fn gst_poll_set_flushing(set: *mut GstPoll, flushing: gboolean);
}
unsafe extern "C" {
    pub fn gst_poll_write_control(set: *mut GstPoll) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_poll_read_control(set: *mut GstPoll) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPreset {
    _unused: [u8; 0],
}
#[doc = " GstPreset:\n\n Opaque #GstPreset data structure."]
pub type GstPreset = _GstPreset;
#[doc = " GstPresetInterface:\n @parent: parent interface type.\n @get_preset_names: virtual method to get list of presets\n @get_property_names: virtual methods to get properties that are persistent\n @load_preset: virtual methods to load a preset into properties\n @save_preset: virtual methods to save properties into a preset\n @rename_preset: virtual methods to rename a preset\n @delete_preset: virtual methods to remove a preset\n @set_meta: virtual methods to set textual meta data to a preset\n @get_meta: virtual methods to get textual meta data from a preset\n\n #GstPreset interface."]
pub type GstPresetInterface = _GstPresetInterface;
#[doc = " GstPresetInterface:\n @parent: parent interface type.\n @get_preset_names: virtual method to get list of presets\n @get_property_names: virtual methods to get properties that are persistent\n @load_preset: virtual methods to load a preset into properties\n @save_preset: virtual methods to save properties into a preset\n @rename_preset: virtual methods to rename a preset\n @delete_preset: virtual methods to remove a preset\n @set_meta: virtual methods to set textual meta data to a preset\n @get_meta: virtual methods to get textual meta data from a preset\n\n #GstPreset interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPresetInterface {
    pub parent: GTypeInterface,
    pub get_preset_names:
        ::std::option::Option<unsafe extern "C" fn(preset: *mut GstPreset) -> *mut *mut gchar>,
    pub get_property_names:
        ::std::option::Option<unsafe extern "C" fn(preset: *mut GstPreset) -> *mut *mut gchar>,
    pub load_preset: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut GstPreset, name: *const gchar) -> gboolean,
    >,
    pub save_preset: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut GstPreset, name: *const gchar) -> gboolean,
    >,
    pub rename_preset: ::std::option::Option<
        unsafe extern "C" fn(
            preset: *mut GstPreset,
            old_name: *const gchar,
            new_name: *const gchar,
        ) -> gboolean,
    >,
    pub delete_preset: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut GstPreset, name: *const gchar) -> gboolean,
    >,
    pub set_meta: ::std::option::Option<
        unsafe extern "C" fn(
            preset: *mut GstPreset,
            name: *const gchar,
            tag: *const gchar,
            value: *const gchar,
        ) -> gboolean,
    >,
    pub get_meta: ::std::option::Option<
        unsafe extern "C" fn(
            preset: *mut GstPreset,
            name: *const gchar,
            tag: *const gchar,
            value: *mut *mut gchar,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPresetInterface"][::std::mem::size_of::<_GstPresetInterface>() - 112usize];
    ["Alignment of _GstPresetInterface"][::std::mem::align_of::<_GstPresetInterface>() - 8usize];
    ["Offset of field: _GstPresetInterface::parent"]
        [::std::mem::offset_of!(_GstPresetInterface, parent) - 0usize];
    ["Offset of field: _GstPresetInterface::get_preset_names"]
        [::std::mem::offset_of!(_GstPresetInterface, get_preset_names) - 16usize];
    ["Offset of field: _GstPresetInterface::get_property_names"]
        [::std::mem::offset_of!(_GstPresetInterface, get_property_names) - 24usize];
    ["Offset of field: _GstPresetInterface::load_preset"]
        [::std::mem::offset_of!(_GstPresetInterface, load_preset) - 32usize];
    ["Offset of field: _GstPresetInterface::save_preset"]
        [::std::mem::offset_of!(_GstPresetInterface, save_preset) - 40usize];
    ["Offset of field: _GstPresetInterface::rename_preset"]
        [::std::mem::offset_of!(_GstPresetInterface, rename_preset) - 48usize];
    ["Offset of field: _GstPresetInterface::delete_preset"]
        [::std::mem::offset_of!(_GstPresetInterface, delete_preset) - 56usize];
    ["Offset of field: _GstPresetInterface::set_meta"]
        [::std::mem::offset_of!(_GstPresetInterface, set_meta) - 64usize];
    ["Offset of field: _GstPresetInterface::get_meta"]
        [::std::mem::offset_of!(_GstPresetInterface, get_meta) - 72usize];
    ["Offset of field: _GstPresetInterface::_gst_reserved"]
        [::std::mem::offset_of!(_GstPresetInterface, _gst_reserved) - 80usize];
};
unsafe extern "C" {
    pub fn gst_preset_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_preset_get_preset_names(preset: *mut GstPreset) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_preset_get_property_names(preset: *mut GstPreset) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_preset_load_preset(preset: *mut GstPreset, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_save_preset(preset: *mut GstPreset, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_rename_preset(
        preset: *mut GstPreset,
        old_name: *const gchar,
        new_name: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_delete_preset(preset: *mut GstPreset, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_set_meta(
        preset: *mut GstPreset,
        name: *const gchar,
        tag: *const gchar,
        value: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_get_meta(
        preset: *mut GstPreset,
        name: *const gchar,
        tag: *const gchar,
        value: *mut *mut gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_set_app_dir(app_dir: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_preset_get_app_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_preset_is_editable(preset: *mut GstPreset) -> gboolean;
}
#[doc = " GstProtectionMeta:\n @meta: the parent #GstMeta.\n @info: the cryptographic information needed to decrypt the sample.\n\n Metadata type that holds information about a sample from a protection-protected\n track, including the information needed to decrypt it (if it is encrypted).\n\n Since: 1.6"]
pub type GstProtectionMeta = _GstProtectionMeta;
#[doc = " GstProtectionMeta:\n @meta: the parent #GstMeta.\n @info: the cryptographic information needed to decrypt the sample.\n\n Metadata type that holds information about a sample from a protection-protected\n track, including the information needed to decrypt it (if it is encrypted).\n\n Since: 1.6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstProtectionMeta {
    pub meta: GstMeta,
    pub info: *mut GstStructure,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstProtectionMeta"][::std::mem::size_of::<_GstProtectionMeta>() - 24usize];
    ["Alignment of _GstProtectionMeta"][::std::mem::align_of::<_GstProtectionMeta>() - 8usize];
    ["Offset of field: _GstProtectionMeta::meta"]
        [::std::mem::offset_of!(_GstProtectionMeta, meta) - 0usize];
    ["Offset of field: _GstProtectionMeta::info"]
        [::std::mem::offset_of!(_GstProtectionMeta, info) - 16usize];
};
unsafe extern "C" {
    #[doc = " gst_protection_meta_api_get_type: (attributes doc.skip=true)"]
    pub fn gst_protection_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_protection_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_protection_meta(
        buffer: *mut GstBuffer,
        info: *mut GstStructure,
    ) -> *mut GstProtectionMeta;
}
unsafe extern "C" {
    pub fn gst_protection_select_system(system_identifiers: *mut *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_protection_filter_systems_by_available_decryptors(
        system_identifiers: *mut *const gchar,
    ) -> *mut *mut gchar;
}
#[doc = " GstRegistry:\n\n Opaque #GstRegistry structure."]
pub type GstRegistry = _GstRegistry;
pub type GstRegistryClass = _GstRegistryClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstRegistryPrivate {
    _unused: [u8; 0],
}
pub type GstRegistryPrivate = _GstRegistryPrivate;
#[doc = " GstRegistry:\n\n Opaque #GstRegistry structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstRegistry {
    pub object: GstObject,
    pub priv_: *mut GstRegistryPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstRegistry"][::std::mem::size_of::<_GstRegistry>() - 96usize];
    ["Alignment of _GstRegistry"][::std::mem::align_of::<_GstRegistry>() - 8usize];
    ["Offset of field: _GstRegistry::object"]
        [::std::mem::offset_of!(_GstRegistry, object) - 0usize];
    ["Offset of field: _GstRegistry::priv_"][::std::mem::offset_of!(_GstRegistry, priv_) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstRegistryClass {
    pub parent_class: GstObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstRegistryClass"][::std::mem::size_of::<_GstRegistryClass>() - 184usize];
    ["Alignment of _GstRegistryClass"][::std::mem::align_of::<_GstRegistryClass>() - 8usize];
    ["Offset of field: _GstRegistryClass::parent_class"]
        [::std::mem::offset_of!(_GstRegistryClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn gst_registry_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_registry_get() -> *mut GstRegistry;
}
unsafe extern "C" {
    pub fn gst_registry_scan_path(registry: *mut GstRegistry, path: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_registry_add_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_registry_remove_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin);
}
unsafe extern "C" {
    pub fn gst_registry_add_feature(
        registry: *mut GstRegistry,
        feature: *mut GstPluginFeature,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_registry_remove_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature);
}
unsafe extern "C" {
    pub fn gst_registry_get_plugin_list(registry: *mut GstRegistry) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_registry_plugin_filter(
        registry: *mut GstRegistry,
        filter: GstPluginFilter,
        first: gboolean,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_registry_feature_filter(
        registry: *mut GstRegistry,
        filter: GstPluginFeatureFilter,
        first: gboolean,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_registry_get_feature_list(registry: *mut GstRegistry, type_: GType) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_registry_get_feature_list_by_plugin(
        registry: *mut GstRegistry,
        name: *const gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_registry_get_feature_list_cookie(registry: *mut GstRegistry) -> guint32;
}
unsafe extern "C" {
    pub fn gst_registry_find_plugin(
        registry: *mut GstRegistry,
        name: *const gchar,
    ) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_registry_find_feature(
        registry: *mut GstRegistry,
        name: *const gchar,
        type_: GType,
    ) -> *mut GstPluginFeature;
}
unsafe extern "C" {
    pub fn gst_registry_lookup(
        registry: *mut GstRegistry,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut GstPlugin;
}
unsafe extern "C" {
    pub fn gst_registry_lookup_feature(
        registry: *mut GstRegistry,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GstPluginFeature;
}
unsafe extern "C" {
    pub fn gst_registry_check_feature_version(
        registry: *mut GstRegistry,
        feature_name: *const gchar,
        min_major: guint,
        min_minor: guint,
        min_micro: guint,
    ) -> gboolean;
}
pub type GstRegistry_autoptr = *mut GstRegistry;
pub type GstRegistry_listautoptr = *mut GList;
pub type GstRegistry_slistautoptr = *mut GSList;
pub type GstRegistry_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_promise_get_type() -> GType;
}
#[doc = " GstPromise:\n @parent: parent #GstMiniObject\n\n Since: 1.14"]
pub type GstPromise = _GstPromise;
pub const GstPromiseResult_GST_PROMISE_RESULT_PENDING: GstPromiseResult = 0;
pub const GstPromiseResult_GST_PROMISE_RESULT_INTERRUPTED: GstPromiseResult = 1;
pub const GstPromiseResult_GST_PROMISE_RESULT_REPLIED: GstPromiseResult = 2;
pub const GstPromiseResult_GST_PROMISE_RESULT_EXPIRED: GstPromiseResult = 3;
#[doc = " GstPromiseResult:\n @GST_PROMISE_RESULT_PENDING: Initial state. Waiting for transition to any\n \tother state.\n @GST_PROMISE_RESULT_INTERRUPTED: Interrupted by the consumer as it doesn't\n \twant the value anymore.\n @GST_PROMISE_RESULT_REPLIED: A producer marked a reply\n @GST_PROMISE_RESULT_EXPIRED: The promise expired (the carrying object\n \tlost all refs) and the promise will never be fulfilled.\n\n The result of a #GstPromise\n\n Since: 1.14"]
pub type GstPromiseResult = ::std::os::raw::c_uint;
#[doc = " GstPromiseChangeFunc:\n @promise: a #GstPromise\n @user_data: (closure): user data\n\n Since: 1.14"]
pub type GstPromiseChangeFunc =
    ::std::option::Option<unsafe extern "C" fn(promise: *mut GstPromise, user_data: gpointer)>;
#[doc = " GstPromise:\n @parent: parent #GstMiniObject\n\n Since: 1.14"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstPromise {
    pub parent: GstMiniObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstPromise"][::std::mem::size_of::<_GstPromise>() - 64usize];
    ["Alignment of _GstPromise"][::std::mem::align_of::<_GstPromise>() - 8usize];
    ["Offset of field: _GstPromise::parent"][::std::mem::offset_of!(_GstPromise, parent) - 0usize];
};
unsafe extern "C" {
    pub fn gst_promise_new() -> *mut GstPromise;
}
unsafe extern "C" {
    pub fn gst_promise_new_with_change_func(
        func: GstPromiseChangeFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GstPromise;
}
unsafe extern "C" {
    pub fn gst_promise_wait(promise: *mut GstPromise) -> GstPromiseResult;
}
unsafe extern "C" {
    pub fn gst_promise_reply(promise: *mut GstPromise, s: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_promise_interrupt(promise: *mut GstPromise);
}
unsafe extern "C" {
    pub fn gst_promise_expire(promise: *mut GstPromise);
}
unsafe extern "C" {
    pub fn gst_promise_get_reply(promise: *mut GstPromise) -> *const GstStructure;
}
pub type GstPromise_autoptr = *mut GstPromise;
pub type GstPromise_listautoptr = *mut GList;
pub type GstPromise_slistautoptr = *mut GSList;
pub type GstPromise_queueautoptr = *mut GQueue;
#[doc = " GstSystemClock:\n\n The default implementation of a #GstClock that uses the system time."]
pub type GstSystemClock = _GstSystemClock;
pub type GstSystemClockClass = _GstSystemClockClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSystemClockPrivate {
    _unused: [u8; 0],
}
pub type GstSystemClockPrivate = _GstSystemClockPrivate;
pub const GstClockType_GST_CLOCK_TYPE_REALTIME: GstClockType = 0;
pub const GstClockType_GST_CLOCK_TYPE_MONOTONIC: GstClockType = 1;
pub const GstClockType_GST_CLOCK_TYPE_OTHER: GstClockType = 2;
pub const GstClockType_GST_CLOCK_TYPE_TAI: GstClockType = 3;
#[doc = " GstClockType:\n @GST_CLOCK_TYPE_REALTIME: time since Epoch\n @GST_CLOCK_TYPE_MONOTONIC: monotonic time since some unspecified starting\n                            point\n @GST_CLOCK_TYPE_OTHER: some other time source is used (Since: 1.0.5)\n @GST_CLOCK_TYPE_TAI: time since Epoch, but using International Atomic Time\n                      as reference (Since: 1.18)\n\n The different kind of clocks."]
pub type GstClockType = ::std::os::raw::c_uint;
#[doc = " GstSystemClock:\n\n The default implementation of a #GstClock that uses the system time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstSystemClock {
    pub clock: GstClock,
    pub priv_: *mut GstSystemClockPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstSystemClock"][::std::mem::size_of::<_GstSystemClock>() - 168usize];
    ["Alignment of _GstSystemClock"][::std::mem::align_of::<_GstSystemClock>() - 8usize];
    ["Offset of field: _GstSystemClock::clock"]
        [::std::mem::offset_of!(_GstSystemClock, clock) - 0usize];
    ["Offset of field: _GstSystemClock::priv_"]
        [::std::mem::offset_of!(_GstSystemClock, priv_) - 128usize];
    ["Offset of field: _GstSystemClock::_gst_reserved"]
        [::std::mem::offset_of!(_GstSystemClock, _gst_reserved) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstSystemClockClass {
    pub parent_class: GstClockClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstSystemClockClass"][::std::mem::size_of::<_GstSystemClockClass>() - 296usize];
    ["Alignment of _GstSystemClockClass"][::std::mem::align_of::<_GstSystemClockClass>() - 8usize];
    ["Offset of field: _GstSystemClockClass::parent_class"]
        [::std::mem::offset_of!(_GstSystemClockClass, parent_class) - 0usize];
    ["Offset of field: _GstSystemClockClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstSystemClockClass, _gst_reserved) - 264usize];
};
unsafe extern "C" {
    pub fn gst_system_clock_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_system_clock_obtain() -> *mut GstClock;
}
unsafe extern "C" {
    pub fn gst_system_clock_set_default(new_clock: *mut GstClock);
}
pub type GstSystemClock_autoptr = *mut GstSystemClock;
pub type GstSystemClock_listautoptr = *mut GList;
pub type GstSystemClock_slistautoptr = *mut GSList;
pub type GstSystemClock_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTagSetter {
    _unused: [u8; 0],
}
#[doc = " GstTagSetter:\n\n Opaque #GstTagSetter data structure."]
pub type GstTagSetter = _GstTagSetter;
#[doc = " GstTagSetterInterface:\n @g_iface: parent interface type.\n\n #GstTagSetterInterface interface."]
pub type GstTagSetterInterface = _GstTagSetterInterface;
#[doc = " GstTagSetterInterface:\n @g_iface: parent interface type.\n\n #GstTagSetterInterface interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTagSetterInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTagSetterInterface"][::std::mem::size_of::<_GstTagSetterInterface>() - 16usize];
    ["Alignment of _GstTagSetterInterface"]
        [::std::mem::align_of::<_GstTagSetterInterface>() - 8usize];
    ["Offset of field: _GstTagSetterInterface::g_iface"]
        [::std::mem::offset_of!(_GstTagSetterInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn gst_tag_setter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tag_setter_reset_tags(setter: *mut GstTagSetter);
}
unsafe extern "C" {
    pub fn gst_tag_setter_merge_tags(
        setter: *mut GstTagSetter,
        list: *const GstTagList,
        mode: GstTagMergeMode,
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_add_tags(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_add_tag_values(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_add_tag_valist(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_add_tag_valist_values(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_add_tag_value(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn gst_tag_setter_get_tag_list(setter: *mut GstTagSetter) -> *const GstTagList;
}
unsafe extern "C" {
    pub fn gst_tag_setter_set_tag_merge_mode(setter: *mut GstTagSetter, mode: GstTagMergeMode);
}
unsafe extern "C" {
    pub fn gst_tag_setter_get_tag_merge_mode(setter: *mut GstTagSetter) -> GstTagMergeMode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTocSetter {
    _unused: [u8; 0],
}
#[doc = " GstTocSetter:\n\n Opaque #GstTocSetter data structure."]
pub type GstTocSetter = _GstTocSetter;
#[doc = " GstTocSetterInterface:\n @g_iface: parent interface type.\n\n #GstTocSetterInterface interface."]
pub type GstTocSetterInterface = _GstTocSetterInterface;
#[doc = " GstTocSetterInterface:\n @g_iface: parent interface type.\n\n #GstTocSetterInterface interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTocSetterInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTocSetterInterface"][::std::mem::size_of::<_GstTocSetterInterface>() - 16usize];
    ["Alignment of _GstTocSetterInterface"]
        [::std::mem::align_of::<_GstTocSetterInterface>() - 8usize];
    ["Offset of field: _GstTocSetterInterface::g_iface"]
        [::std::mem::offset_of!(_GstTocSetterInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn gst_toc_setter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_toc_setter_reset(setter: *mut GstTocSetter);
}
unsafe extern "C" {
    pub fn gst_toc_setter_get_toc(setter: *mut GstTocSetter) -> *mut GstToc;
}
unsafe extern "C" {
    pub fn gst_toc_setter_set_toc(setter: *mut GstTocSetter, toc: *mut GstToc);
}
#[doc = " GstTracer:\n\n The opaque GstTracer instance structure"]
pub type GstTracer = _GstTracer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerPrivate {
    _unused: [u8; 0],
}
pub type GstTracerPrivate = _GstTracerPrivate;
pub type GstTracerClass = _GstTracerClass;
#[doc = " GstTracer:\n\n The opaque GstTracer instance structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstTracer {
    pub parent: GstObject,
    pub priv_: *mut GstTracerPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTracer"][::std::mem::size_of::<_GstTracer>() - 128usize];
    ["Alignment of _GstTracer"][::std::mem::align_of::<_GstTracer>() - 8usize];
    ["Offset of field: _GstTracer::parent"][::std::mem::offset_of!(_GstTracer, parent) - 0usize];
    ["Offset of field: _GstTracer::priv_"][::std::mem::offset_of!(_GstTracer, priv_) - 88usize];
    ["Offset of field: _GstTracer::_gst_reserved"]
        [::std::mem::offset_of!(_GstTracer, _gst_reserved) - 96usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTracerClass"][::std::mem::size_of::<_GstTracerClass>() - 216usize];
    ["Alignment of _GstTracerClass"][::std::mem::align_of::<_GstTracerClass>() - 8usize];
    ["Offset of field: _GstTracerClass::parent_class"]
        [::std::mem::offset_of!(_GstTracerClass, parent_class) - 0usize];
    ["Offset of field: _GstTracerClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstTracerClass, _gst_reserved) - 184usize];
};
unsafe extern "C" {
    pub fn gst_tracer_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tracing_register_hook(tracer: *mut GstTracer, detail: *const gchar, func: GCallback);
}
unsafe extern "C" {
    pub fn gst_tracer_register(
        plugin: *mut GstPlugin,
        name: *const gchar,
        type_: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_tracing_get_active_tracers() -> *mut GList;
}
pub type GstTracer_autoptr = *mut GstTracer;
pub type GstTracer_listautoptr = *mut GList;
pub type GstTracer_slistautoptr = *mut GSList;
pub type GstTracer_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerFactory {
    _unused: [u8; 0],
}
#[doc = " GstTracerFactory:\n\n Opaque object that stores information about a tracer function.\n\n Since: 1.8"]
pub type GstTracerFactory = _GstTracerFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerFactoryClass {
    _unused: [u8; 0],
}
pub type GstTracerFactoryClass = _GstTracerFactoryClass;
unsafe extern "C" {
    pub fn gst_tracer_factory_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_tracer_factory_get_list() -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_tracer_factory_get_tracer_type(factory: *mut GstTracerFactory) -> GType;
}
pub type GstTracerFactory_autoptr = *mut GstTracerFactory;
pub type GstTracerFactory_listautoptr = *mut GList;
pub type GstTracerFactory_slistautoptr = *mut GSList;
pub type GstTracerFactory_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerRecord {
    _unused: [u8; 0],
}
#[doc = " GstTracerRecord:\n\n The opaque GstTracerRecord instance structure\n\n Since: 1.8"]
pub type GstTracerRecord = _GstTracerRecord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTracerRecordClass {
    _unused: [u8; 0],
}
pub type GstTracerRecordClass = _GstTracerRecordClass;
unsafe extern "C" {
    pub fn gst_tracer_record_get_type() -> GType;
}
pub type GstTracerRecord_autoptr = *mut GstTracerRecord;
pub type GstTracerRecord_listautoptr = *mut GList;
pub type GstTracerRecord_slistautoptr = *mut GSList;
pub type GstTracerRecord_queueautoptr = *mut GQueue;
pub const GstTracerValueScope_GST_TRACER_VALUE_SCOPE_PROCESS: GstTracerValueScope = 0;
pub const GstTracerValueScope_GST_TRACER_VALUE_SCOPE_THREAD: GstTracerValueScope = 1;
pub const GstTracerValueScope_GST_TRACER_VALUE_SCOPE_ELEMENT: GstTracerValueScope = 2;
pub const GstTracerValueScope_GST_TRACER_VALUE_SCOPE_PAD: GstTracerValueScope = 3;
#[doc = " GstTracerValueScope:\n @GST_TRACER_VALUE_SCOPE_PROCESS: the value is related to the process\n @GST_TRACER_VALUE_SCOPE_THREAD: the value is related to a thread\n @GST_TRACER_VALUE_SCOPE_ELEMENT: the value is related to an #GstElement\n @GST_TRACER_VALUE_SCOPE_PAD: the value is related to a #GstPad\n\n Tracing record will contain fields that contain a measured value or extra\n meta-data. One such meta data are values that tell where a measurement was\n taken. This enumerating declares to which scope such a meta data field\n relates to. If it is e.g. %GST_TRACER_VALUE_SCOPE_PAD, then each of the log\n events may contain values for different #GstPads.\n\n Since: 1.8"]
pub type GstTracerValueScope = ::std::os::raw::c_uint;
pub const GstTracerValueFlags_GST_TRACER_VALUE_FLAGS_NONE: GstTracerValueFlags = 0;
pub const GstTracerValueFlags_GST_TRACER_VALUE_FLAGS_OPTIONAL: GstTracerValueFlags = 1;
pub const GstTracerValueFlags_GST_TRACER_VALUE_FLAGS_AGGREGATED: GstTracerValueFlags = 2;
#[doc = " GstTracerValueFlags:\n @GST_TRACER_VALUE_FLAGS_NONE: no flags\n @GST_TRACER_VALUE_FLAGS_OPTIONAL: the value is optional. When using this flag\n   one need to have an additional boolean arg before this value in the\n   var-args list passed to  gst_tracer_record_log().\n @GST_TRACER_VALUE_FLAGS_AGGREGATED: the value is a combined figure, since the\n   start of tracing. Examples are averages or timestamps.\n\n Flag that describe the value. These flags help applications processing the\n logs to understand the values."]
pub type GstTracerValueFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_tracer_record_new(
        name: *const gchar,
        firstfield: *const gchar,
        ...
    ) -> *mut GstTracerRecord;
}
unsafe extern "C" {
    pub fn gst_tracer_record_log(self_: *mut GstTracerRecord, ...);
}
#[doc = " GstTypeFind:\n @peek: Method to peek data.\n @suggest: Method to suggest #GstCaps with a given probability.\n @data: The data used by the caller of the typefinding function.\n @get_length: Returns the length of current data.\n\n Object that stores typefind callbacks. To use with #GstTypeFindFactory."]
pub type GstTypeFind = _GstTypeFind;
#[doc = " GstTypeFindFunction:\n @find: A #GstTypeFind structure\n @user_data: optional data to pass to the function\n\n A function that will be called by typefinding."]
pub type GstTypeFindFunction =
    ::std::option::Option<unsafe extern "C" fn(find: *mut GstTypeFind, user_data: gpointer)>;
pub const GstTypeFindProbability_GST_TYPE_FIND_NONE: GstTypeFindProbability = 0;
pub const GstTypeFindProbability_GST_TYPE_FIND_MINIMUM: GstTypeFindProbability = 1;
pub const GstTypeFindProbability_GST_TYPE_FIND_POSSIBLE: GstTypeFindProbability = 50;
pub const GstTypeFindProbability_GST_TYPE_FIND_LIKELY: GstTypeFindProbability = 80;
pub const GstTypeFindProbability_GST_TYPE_FIND_NEARLY_CERTAIN: GstTypeFindProbability = 99;
pub const GstTypeFindProbability_GST_TYPE_FIND_MAXIMUM: GstTypeFindProbability = 100;
#[doc = " GstTypeFindProbability:\n @GST_TYPE_FIND_NONE: type undetected.\n @GST_TYPE_FIND_MINIMUM: unlikely typefind.\n @GST_TYPE_FIND_POSSIBLE: possible type detected.\n @GST_TYPE_FIND_LIKELY: likely a type was detected.\n @GST_TYPE_FIND_NEARLY_CERTAIN: nearly certain that a type was detected.\n @GST_TYPE_FIND_MAXIMUM: very certain a type was detected.\n\n The probability of the typefind function. Higher values have more certainty\n in doing a reliable typefind."]
pub type GstTypeFindProbability = ::std::os::raw::c_uint;
#[doc = " GstTypeFind:\n @peek: Method to peek data.\n @suggest: Method to suggest #GstCaps with a given probability.\n @data: The data used by the caller of the typefinding function.\n @get_length: Returns the length of current data.\n\n Object that stores typefind callbacks. To use with #GstTypeFindFactory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTypeFind {
    pub peek: ::std::option::Option<
        unsafe extern "C" fn(data: gpointer, offset: gint64, size: guint) -> *const guint8,
    >,
    pub suggest: ::std::option::Option<
        unsafe extern "C" fn(data: gpointer, probability: guint, caps: *mut GstCaps),
    >,
    pub data: gpointer,
    pub get_length: ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> guint64>,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstTypeFind"][::std::mem::size_of::<_GstTypeFind>() - 64usize];
    ["Alignment of _GstTypeFind"][::std::mem::align_of::<_GstTypeFind>() - 8usize];
    ["Offset of field: _GstTypeFind::peek"][::std::mem::offset_of!(_GstTypeFind, peek) - 0usize];
    ["Offset of field: _GstTypeFind::suggest"]
        [::std::mem::offset_of!(_GstTypeFind, suggest) - 8usize];
    ["Offset of field: _GstTypeFind::data"][::std::mem::offset_of!(_GstTypeFind, data) - 16usize];
    ["Offset of field: _GstTypeFind::get_length"]
        [::std::mem::offset_of!(_GstTypeFind, get_length) - 24usize];
    ["Offset of field: _GstTypeFind::_gst_reserved"]
        [::std::mem::offset_of!(_GstTypeFind, _gst_reserved) - 32usize];
};
unsafe extern "C" {
    #[doc = " gst_type_find_get_type: (attributes doc.skip=true)"]
    pub fn gst_type_find_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_type_find_peek(find: *mut GstTypeFind, offset: gint64, size: guint)
    -> *const guint8;
}
unsafe extern "C" {
    pub fn gst_type_find_suggest(find: *mut GstTypeFind, probability: guint, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_type_find_suggest_empty_simple(
        find: *mut GstTypeFind,
        probability: guint,
        media_type: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn gst_type_find_suggest_simple(
        find: *mut GstTypeFind,
        probability: guint,
        media_type: *const ::std::os::raw::c_char,
        fieldname: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn gst_type_find_get_length(find: *mut GstTypeFind) -> guint64;
}
unsafe extern "C" {
    pub fn gst_type_find_register(
        plugin: *mut GstPlugin,
        name: *const gchar,
        rank: guint,
        func: GstTypeFindFunction,
        extensions: *const gchar,
        possible_caps: *mut GstCaps,
        data: gpointer,
        data_notify: GDestroyNotify,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTypeFindFactory {
    _unused: [u8; 0],
}
#[doc = " GstTypeFindFactory:\n\n Opaque object that stores information about a typefind function."]
pub type GstTypeFindFactory = _GstTypeFindFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstTypeFindFactoryClass {
    _unused: [u8; 0],
}
pub type GstTypeFindFactoryClass = _GstTypeFindFactoryClass;
unsafe extern "C" {
    pub fn gst_type_find_factory_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_type_find_factory_get_list() -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_type_find_factory_get_extensions(
        factory: *mut GstTypeFindFactory,
    ) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn gst_type_find_factory_get_caps(factory: *mut GstTypeFindFactory) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_type_find_factory_has_function(factory: *mut GstTypeFindFactory) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_type_find_factory_call_function(
        factory: *mut GstTypeFindFactory,
        find: *mut GstTypeFind,
    );
}
pub type GstTypeFindFactory_autoptr = *mut GstTypeFindFactory;
pub type GstTypeFindFactory_listautoptr = *mut GList;
pub type GstTypeFindFactory_slistautoptr = *mut GSList;
pub type GstTypeFindFactory_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_parse_error_quark() -> GQuark;
}
pub const GstParseError_GST_PARSE_ERROR_SYNTAX: GstParseError = 0;
pub const GstParseError_GST_PARSE_ERROR_NO_SUCH_ELEMENT: GstParseError = 1;
pub const GstParseError_GST_PARSE_ERROR_NO_SUCH_PROPERTY: GstParseError = 2;
pub const GstParseError_GST_PARSE_ERROR_LINK: GstParseError = 3;
pub const GstParseError_GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: GstParseError = 4;
pub const GstParseError_GST_PARSE_ERROR_EMPTY_BIN: GstParseError = 5;
pub const GstParseError_GST_PARSE_ERROR_EMPTY: GstParseError = 6;
pub const GstParseError_GST_PARSE_ERROR_DELAYED_LINK: GstParseError = 7;
#[doc = " GstParseError:\n @GST_PARSE_ERROR_SYNTAX: A syntax error occurred.\n @GST_PARSE_ERROR_NO_SUCH_ELEMENT: The description contained an unknown element\n @GST_PARSE_ERROR_NO_SUCH_PROPERTY: An element did not have a specified property\n @GST_PARSE_ERROR_LINK: There was an error linking two pads.\n @GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: There was an error setting a property\n @GST_PARSE_ERROR_EMPTY_BIN: An empty bin was specified.\n @GST_PARSE_ERROR_EMPTY: An empty description was specified\n @GST_PARSE_ERROR_DELAYED_LINK: A delayed link did not get resolved.\n\n The different parsing errors that can occur."]
pub type GstParseError = ::std::os::raw::c_uint;
pub const GstParseFlags_GST_PARSE_FLAG_NONE: GstParseFlags = 0;
pub const GstParseFlags_GST_PARSE_FLAG_FATAL_ERRORS: GstParseFlags = 1;
pub const GstParseFlags_GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: GstParseFlags = 2;
pub const GstParseFlags_GST_PARSE_FLAG_PLACE_IN_BIN: GstParseFlags = 4;
#[doc = " GstParseFlags:\n @GST_PARSE_FLAG_NONE: Do not use any special parsing options.\n @GST_PARSE_FLAG_FATAL_ERRORS: Always return %NULL when an error occurs\n     (default behaviour is to return partially constructed bins or elements\n      in some cases)\n @GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: If a bin only has a single element,\n     just return the element.\n @GST_PARSE_FLAG_PLACE_IN_BIN: If more than one toplevel element is described\n     by the pipeline description string, put them in a #GstBin instead of a\n     #GstPipeline. (Since: 1.10)\n\n Parsing options."]
pub type GstParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstParseContext {
    _unused: [u8; 0],
}
#[doc = " GstParseContext:\n\n Opaque structure."]
pub type GstParseContext = _GstParseContext;
unsafe extern "C" {
    pub fn gst_parse_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_parse_context_new() -> *mut GstParseContext;
}
unsafe extern "C" {
    pub fn gst_parse_context_get_missing_elements(context: *mut GstParseContext)
    -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn gst_parse_context_free(context: *mut GstParseContext);
}
unsafe extern "C" {
    pub fn gst_parse_context_copy(context: *const GstParseContext) -> *mut GstParseContext;
}
unsafe extern "C" {
    pub fn gst_parse_launch(
        pipeline_description: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_parse_launchv(argv: *mut *const gchar, error: *mut *mut GError) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_parse_launch_full(
        pipeline_description: *const gchar,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        error: *mut *mut GError,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_parse_launchv_full(
        argv: *mut *const gchar,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        error: *mut *mut GError,
    ) -> *mut GstElement;
}
pub type GstParseContext_autoptr = *mut GstParseContext;
pub type GstParseContext_listautoptr = *mut GList;
pub type GstParseContext_slistautoptr = *mut GSList;
pub type GstParseContext_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_util_set_value_from_string(value: *mut GValue, value_str: *const gchar);
}
unsafe extern "C" {
    pub fn gst_util_set_object_arg(object: *mut GObject, name: *const gchar, value: *const gchar);
}
unsafe extern "C" {
    pub fn gst_util_set_object_array(
        object: *mut GObject,
        name: *const gchar,
        array: *const GValueArray,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_util_get_object_array(
        object: *mut GObject,
        name: *const gchar,
        array: *mut *mut GValueArray,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_util_dump_mem(mem: *const guchar, size: guint);
}
unsafe extern "C" {
    pub fn gst_util_dump_buffer(buf: *mut GstBuffer);
}
unsafe extern "C" {
    pub fn gst_util_gdouble_to_guint64(value: gdouble) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_guint64_to_gdouble(value: guint64) -> gdouble;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale(val: guint64, num: guint64, denom: guint64) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale_round(val: guint64, num: guint64, denom: guint64) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale_ceil(val: guint64, num: guint64, denom: guint64) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale_int(val: guint64, num: gint, denom: gint) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale_int_round(val: guint64, num: gint, denom: gint) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_uint64_scale_int_ceil(val: guint64, num: gint, denom: gint) -> guint64;
}
unsafe extern "C" {
    pub fn gst_util_seqnum_next() -> guint32;
}
unsafe extern "C" {
    pub fn gst_util_seqnum_compare(s1: guint32, s2: guint32) -> gint32;
}
unsafe extern "C" {
    pub fn gst_util_group_id_next() -> guint;
}
unsafe extern "C" {
    pub fn gst_object_default_error(
        source: *mut GstObject,
        error: *const GError,
        debug: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_create_all_pads(element: *mut GstElement);
}
unsafe extern "C" {
    pub fn gst_element_get_compatible_pad(
        element: *mut GstElement,
        pad: *mut GstPad,
        caps: *mut GstCaps,
    ) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_element_get_compatible_pad_template(
        element: *mut GstElement,
        compattempl: *mut GstPadTemplate,
    ) -> *mut GstPadTemplate;
}
unsafe extern "C" {
    pub fn gst_element_state_get_name(state: GstState) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_element_state_change_return_get_name(
        state_ret: GstStateChangeReturn,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_state_change_get_name(transition: GstStateChange) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_element_link(src: *mut GstElement, dest: *mut GstElement) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_link_many(
        element_1: *mut GstElement,
        element_2: *mut GstElement,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_link_filtered(
        src: *mut GstElement,
        dest: *mut GstElement,
        filter: *mut GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_unlink(src: *mut GstElement, dest: *mut GstElement);
}
unsafe extern "C" {
    pub fn gst_element_unlink_many(element_1: *mut GstElement, element_2: *mut GstElement, ...);
}
unsafe extern "C" {
    pub fn gst_element_link_pads(
        src: *mut GstElement,
        srcpadname: *const gchar,
        dest: *mut GstElement,
        destpadname: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_link_pads_full(
        src: *mut GstElement,
        srcpadname: *const gchar,
        dest: *mut GstElement,
        destpadname: *const gchar,
        flags: GstPadLinkCheck,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_unlink_pads(
        src: *mut GstElement,
        srcpadname: *const gchar,
        dest: *mut GstElement,
        destpadname: *const gchar,
    );
}
unsafe extern "C" {
    pub fn gst_element_link_pads_filtered(
        src: *mut GstElement,
        srcpadname: *const gchar,
        dest: *mut GstElement,
        destpadname: *const gchar,
        filter: *mut GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_seek_simple(
        element: *mut GstElement,
        format: GstFormat,
        seek_flags: GstSeekFlags,
        seek_pos: gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_can_sink_all_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_can_src_all_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_can_sink_any_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_factory_can_src_any_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_query_position(
        element: *mut GstElement,
        format: GstFormat,
        cur: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_query_duration(
        element: *mut GstElement,
        format: GstFormat,
        duration: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_element_query_convert(
        element: *mut GstElement,
        src_format: GstFormat,
        src_val: gint64,
        dest_format: GstFormat,
        dest_val: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_use_fixed_caps(pad: *mut GstPad);
}
unsafe extern "C" {
    pub fn gst_pad_get_parent_element(pad: *mut GstPad) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_pad_proxy_query_accept_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_proxy_query_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_query_position(
        pad: *mut GstPad,
        format: GstFormat,
        cur: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_query_duration(
        pad: *mut GstPad,
        format: GstFormat,
        duration: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_query_convert(
        pad: *mut GstPad,
        src_format: GstFormat,
        src_val: gint64,
        dest_format: GstFormat,
        dest_val: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_link_maybe_ghosting(src: *mut GstPad, sink: *mut GstPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_link_maybe_ghosting_full(
        src: *mut GstPad,
        sink: *mut GstPad,
        flags: GstPadLinkCheck,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query_position(
        pad: *mut GstPad,
        format: GstFormat,
        cur: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query_duration(
        pad: *mut GstPad,
        format: GstFormat,
        duration: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query_convert(
        pad: *mut GstPad,
        src_format: GstFormat,
        src_val: gint64,
        dest_format: GstFormat,
        dest_val: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_pad_peer_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_pad_create_stream_id(
        pad: *mut GstPad,
        parent: *mut GstElement,
        stream_id: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_pad_create_stream_id_printf(
        pad: *mut GstPad,
        parent: *mut GstElement,
        stream_id: *const gchar,
        ...
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_pad_create_stream_id_printf_valist(
        pad: *mut GstPad,
        parent: *mut GstElement,
        stream_id: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_pad_get_stream_id(pad: *mut GstPad) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_pad_get_stream(pad: *mut GstPad) -> *mut GstStream;
}
unsafe extern "C" {
    pub fn gst_bin_add_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
}
unsafe extern "C" {
    pub fn gst_bin_remove_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
}
unsafe extern "C" {
    pub fn gst_bin_find_unlinked_pad(bin: *mut GstBin, direction: GstPadDirection) -> *mut GstPad;
}
unsafe extern "C" {
    pub fn gst_bin_sync_children_states(bin: *mut GstBin) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_parse_bin_from_description(
        bin_description: *const gchar,
        ghost_unlinked_pads: gboolean,
        err: *mut *mut GError,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_parse_bin_from_description_full(
        bin_description: *const gchar,
        ghost_unlinked_pads: gboolean,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        err: *mut *mut GError,
    ) -> *mut GstElement;
}
unsafe extern "C" {
    pub fn gst_util_get_timestamp() -> GstClockTime;
}
pub const GstSearchMode_GST_SEARCH_MODE_EXACT: GstSearchMode = 0;
pub const GstSearchMode_GST_SEARCH_MODE_BEFORE: GstSearchMode = 1;
pub const GstSearchMode_GST_SEARCH_MODE_AFTER: GstSearchMode = 2;
#[doc = " GstSearchMode:\n @GST_SEARCH_MODE_EXACT : Only search for exact matches.\n @GST_SEARCH_MODE_BEFORE: Search for an exact match or the element just before.\n @GST_SEARCH_MODE_AFTER : Search for an exact match or the element just after.\n\n The different search modes."]
pub type GstSearchMode = ::std::os::raw::c_uint;
pub const GstPluginAPIFlags_GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS: GstPluginAPIFlags = 1;
#[doc = " GstPluginAPIFlags:\n @GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS: Ignore enum members when generating\n   the plugins cache. This is useful if the members of the enum are generated\n   dynamically, in order not to expose incorrect documentation to the end user.\n\n Since: 1.18"]
pub type GstPluginAPIFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_util_array_binary_search(
        array: gpointer,
        num_elements: guint,
        element_size: gsize,
        search_func: GCompareDataFunc,
        mode: GstSearchMode,
        search_data: gconstpointer,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_util_greatest_common_divisor(a: gint, b: gint) -> gint;
}
unsafe extern "C" {
    pub fn gst_util_greatest_common_divisor_int64(a: gint64, b: gint64) -> gint64;
}
unsafe extern "C" {
    pub fn gst_util_fraction_to_double(src_n: gint, src_d: gint, dest: *mut gdouble);
}
unsafe extern "C" {
    pub fn gst_util_double_to_fraction(src: gdouble, dest_n: *mut gint, dest_d: *mut gint);
}
unsafe extern "C" {
    pub fn gst_util_fraction_multiply(
        a_n: gint,
        a_d: gint,
        b_n: gint,
        b_d: gint,
        res_n: *mut gint,
        res_d: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_util_fraction_add(
        a_n: gint,
        a_d: gint,
        b_n: gint,
        b_d: gint,
        res_n: *mut gint,
        res_d: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_util_fraction_compare(a_n: gint, a_d: gint, b_n: gint, b_d: gint) -> gint;
}
unsafe extern "C" {
    pub fn gst_calculate_linear_regression(
        xy: *const GstClockTime,
        temp: *mut GstClockTime,
        n: guint,
        m_num: *mut GstClockTime,
        m_denom: *mut GstClockTime,
        b: *mut GstClockTime,
        xbase: *mut GstClockTime,
        r_squared: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_type_mark_as_plugin_api(type_: GType, flags: GstPluginAPIFlags);
}
unsafe extern "C" {
    pub fn gst_type_is_plugin_api(type_: GType, flags: *mut GstPluginAPIFlags) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_init(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gst_init_check(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_is_initialized() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_init_get_option_group() -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn gst_deinit();
}
unsafe extern "C" {
    pub fn gst_version(major: *mut guint, minor: *mut guint, micro: *mut guint, nano: *mut guint);
}
unsafe extern "C" {
    pub fn gst_version_string() -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_segtrap_is_enabled() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_segtrap_set_enabled(enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_registry_fork_is_enabled() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_registry_fork_set_enabled(enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_update_registry() -> gboolean;
}
unsafe extern "C" {
    pub fn gst_get_main_executable_path() -> *const gchar;
}
#[doc = " GstVideoAlignment:\n @padding_left: extra pixels on the left side\n @padding_right: extra pixels on the right side\n @padding_top: extra pixels on the top\n @padding_bottom: extra pixels on the bottom\n @stride_align: array with extra alignment requirements for the strides\n\n Extra alignment parameters for the memory of video buffers. This\n structure is usually used to configure the bufferpool if it supports the\n #GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT."]
pub type GstVideoAlignment = _GstVideoAlignment;
unsafe extern "C" {
    pub fn gst_color_balance_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_decoder_request_sync_point_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_gl_texture_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_gl_texture_orientation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_time_code_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_navigation_command_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_navigation_query_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_navigation_message_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_navigation_event_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_ancillary_did_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_ancillary_di_d16_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_afd_value_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_afd_spec_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_caption_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_vbi_parser_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_chroma_site_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_chroma_method_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_chroma_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_color_range_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_color_matrix_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_color_primaries_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_alpha_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_chroma_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_matrix_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_gamma_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_primaries_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_dither_method_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_dither_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_format_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_pack_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_frame_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_buffer_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_frame_map_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_interlace_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_multiview_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_multiview_frame_packing_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_multiview_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_field_order_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_overlay_format_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_resampler_method_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_resampler_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_scaler_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_tile_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_tile_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_orientation_method_get_type() -> GType;
}
pub const GstVideoTileType_GST_VIDEO_TILE_TYPE_INDEXED: GstVideoTileType = 0;
#[doc = " GstVideoTileType:\n @GST_VIDEO_TILE_TYPE_INDEXED: Tiles are indexed. Use\n   gst_video_tile_get_index () to retrieve the tile at the requested\n   coordinates.\n\n Enum value describing the most common tiling types."]
pub type GstVideoTileType = ::std::os::raw::c_uint;
pub const GstVideoTileMode_GST_VIDEO_TILE_MODE_UNKNOWN: GstVideoTileMode = 0;
pub const GstVideoTileMode_GST_VIDEO_TILE_MODE_ZFLIPZ_2X2: GstVideoTileMode = 65536;
#[doc = " GST_VIDEO_TILE_MODE_LINEAR:\n\n Tiles are in row order.\n\n Since: 1.18"]
pub const GstVideoTileMode_GST_VIDEO_TILE_MODE_LINEAR: GstVideoTileMode = 131072;
#[doc = " GstVideoTileMode:\n @GST_VIDEO_TILE_MODE_UNKNOWN: Unknown or unset tile mode\n @GST_VIDEO_TILE_MODE_ZFLIPZ_2X2: Every four adjacent blocks - two\n    horizontally and two vertically are grouped together and are located\n    in memory in Z or flipped Z order. In case of odd rows, the last row\n    of blocks is arranged in linear order.\n @GST_VIDEO_TILE_MODE_LINEAR: Tiles are in row order. (Since: 1.18)\n\n Enum value describing the available tiling modes."]
pub type GstVideoTileMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_tile_get_index(
        mode: GstVideoTileMode,
        x: gint,
        y: gint,
        x_tiles: gint,
        y_tiles: gint,
    ) -> guint;
}
pub const GstVideoFormat_GST_VIDEO_FORMAT_UNKNOWN: GstVideoFormat = 0;
pub const GstVideoFormat_GST_VIDEO_FORMAT_ENCODED: GstVideoFormat = 1;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I420: GstVideoFormat = 2;
pub const GstVideoFormat_GST_VIDEO_FORMAT_YV12: GstVideoFormat = 3;
pub const GstVideoFormat_GST_VIDEO_FORMAT_YUY2: GstVideoFormat = 4;
pub const GstVideoFormat_GST_VIDEO_FORMAT_UYVY: GstVideoFormat = 5;
pub const GstVideoFormat_GST_VIDEO_FORMAT_AYUV: GstVideoFormat = 6;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGBx: GstVideoFormat = 7;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGRx: GstVideoFormat = 8;
pub const GstVideoFormat_GST_VIDEO_FORMAT_xRGB: GstVideoFormat = 9;
pub const GstVideoFormat_GST_VIDEO_FORMAT_xBGR: GstVideoFormat = 10;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGBA: GstVideoFormat = 11;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGRA: GstVideoFormat = 12;
pub const GstVideoFormat_GST_VIDEO_FORMAT_ARGB: GstVideoFormat = 13;
pub const GstVideoFormat_GST_VIDEO_FORMAT_ABGR: GstVideoFormat = 14;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGB: GstVideoFormat = 15;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGR: GstVideoFormat = 16;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y41B: GstVideoFormat = 17;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y42B: GstVideoFormat = 18;
pub const GstVideoFormat_GST_VIDEO_FORMAT_YVYU: GstVideoFormat = 19;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444: GstVideoFormat = 20;
pub const GstVideoFormat_GST_VIDEO_FORMAT_v210: GstVideoFormat = 21;
pub const GstVideoFormat_GST_VIDEO_FORMAT_v216: GstVideoFormat = 22;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12: GstVideoFormat = 23;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV21: GstVideoFormat = 24;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GRAY8: GstVideoFormat = 25;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GRAY16_BE: GstVideoFormat = 26;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GRAY16_LE: GstVideoFormat = 27;
pub const GstVideoFormat_GST_VIDEO_FORMAT_v308: GstVideoFormat = 28;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGB16: GstVideoFormat = 29;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGR16: GstVideoFormat = 30;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGB15: GstVideoFormat = 31;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGR15: GstVideoFormat = 32;
pub const GstVideoFormat_GST_VIDEO_FORMAT_UYVP: GstVideoFormat = 33;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A420: GstVideoFormat = 34;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGB8P: GstVideoFormat = 35;
pub const GstVideoFormat_GST_VIDEO_FORMAT_YUV9: GstVideoFormat = 36;
pub const GstVideoFormat_GST_VIDEO_FORMAT_YVU9: GstVideoFormat = 37;
pub const GstVideoFormat_GST_VIDEO_FORMAT_IYU1: GstVideoFormat = 38;
pub const GstVideoFormat_GST_VIDEO_FORMAT_ARGB64: GstVideoFormat = 39;
pub const GstVideoFormat_GST_VIDEO_FORMAT_AYUV64: GstVideoFormat = 40;
pub const GstVideoFormat_GST_VIDEO_FORMAT_r210: GstVideoFormat = 41;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I420_10BE: GstVideoFormat = 42;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I420_10LE: GstVideoFormat = 43;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I422_10BE: GstVideoFormat = 44;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I422_10LE: GstVideoFormat = 45;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_10BE: GstVideoFormat = 46;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_10LE: GstVideoFormat = 47;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBR: GstVideoFormat = 48;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBR_10BE: GstVideoFormat = 49;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBR_10LE: GstVideoFormat = 50;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV16: GstVideoFormat = 51;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV24: GstVideoFormat = 52;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12_64Z32: GstVideoFormat = 53;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A420_10BE: GstVideoFormat = 54;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A420_10LE: GstVideoFormat = 55;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A422_10BE: GstVideoFormat = 56;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A422_10LE: GstVideoFormat = 57;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A444_10BE: GstVideoFormat = 58;
pub const GstVideoFormat_GST_VIDEO_FORMAT_A444_10LE: GstVideoFormat = 59;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV61: GstVideoFormat = 60;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P010_10BE: GstVideoFormat = 61;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P010_10LE: GstVideoFormat = 62;
pub const GstVideoFormat_GST_VIDEO_FORMAT_IYU2: GstVideoFormat = 63;
pub const GstVideoFormat_GST_VIDEO_FORMAT_VYUY: GstVideoFormat = 64;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBRA: GstVideoFormat = 65;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBRA_10BE: GstVideoFormat = 66;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBRA_10LE: GstVideoFormat = 67;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBR_12BE: GstVideoFormat = 68;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBR_12LE: GstVideoFormat = 69;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBRA_12BE: GstVideoFormat = 70;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GBRA_12LE: GstVideoFormat = 71;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I420_12BE: GstVideoFormat = 72;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I420_12LE: GstVideoFormat = 73;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I422_12BE: GstVideoFormat = 74;
pub const GstVideoFormat_GST_VIDEO_FORMAT_I422_12LE: GstVideoFormat = 75;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_12BE: GstVideoFormat = 76;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_12LE: GstVideoFormat = 77;
pub const GstVideoFormat_GST_VIDEO_FORMAT_GRAY10_LE32: GstVideoFormat = 78;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12_10LE32: GstVideoFormat = 79;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV16_10LE32: GstVideoFormat = 80;
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12_10LE40: GstVideoFormat = 81;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y210: GstVideoFormat = 82;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y410: GstVideoFormat = 83;
pub const GstVideoFormat_GST_VIDEO_FORMAT_VUYA: GstVideoFormat = 84;
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGR10A2_LE: GstVideoFormat = 85;
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGB10A2_LE: GstVideoFormat = 86;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_16BE: GstVideoFormat = 87;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y444_16LE: GstVideoFormat = 88;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P016_BE: GstVideoFormat = 89;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P016_LE: GstVideoFormat = 90;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P012_BE: GstVideoFormat = 91;
pub const GstVideoFormat_GST_VIDEO_FORMAT_P012_LE: GstVideoFormat = 92;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y212_BE: GstVideoFormat = 93;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y212_LE: GstVideoFormat = 94;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y412_BE: GstVideoFormat = 95;
pub const GstVideoFormat_GST_VIDEO_FORMAT_Y412_LE: GstVideoFormat = 96;
#[doc = " GST_VIDEO_FORMAT_NV12_4L4:\n\n NV12 with 4x4 tiles in linear order.\n\n Since: 1.18"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12_4L4: GstVideoFormat = 97;
#[doc = " GST_VIDEO_FORMAT_NV12_32L32:\n\n NV12 with 32x32 tiles in linear order.\n\n Since: 1.18"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_NV12_32L32: GstVideoFormat = 98;
#[doc = " GST_VIDEO_FORMAT_RGBP:\n\n Planar 4:4:4 RGB, R-G-B order\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGBP: GstVideoFormat = 99;
#[doc = " GST_VIDEO_FORMAT_BGRP:\n\n Planar 4:4:4 RGB, B-G-R order\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGRP: GstVideoFormat = 100;
#[doc = " GST_VIDEO_FORMAT_AV12:\n\n Planar 4:2:0 YUV with interleaved UV plane with alpha as\n 3rd plane.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_AV12: GstVideoFormat = 101;
#[doc = " GST_VIDEO_FORMAT_ARGB64_LE:\n\n RGB with alpha channel first, 16 bits (little endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_ARGB64_LE: GstVideoFormat = 102;
#[doc = " GST_VIDEO_FORMAT_ARGB64_BE:\n\n RGB with alpha channel first, 16 bits (big endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_ARGB64_BE: GstVideoFormat = 103;
#[doc = " GST_VIDEO_FORMAT_RGBA64_LE:\n\n RGB with alpha channel last, 16 bits (little endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGBA64_LE: GstVideoFormat = 104;
#[doc = " GST_VIDEO_FORMAT_RGBA64_BE:\n\n RGB with alpha channel last, 16 bits (big endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_RGBA64_BE: GstVideoFormat = 105;
#[doc = " GST_VIDEO_FORMAT_BGRA64_LE:\n\n Reverse RGB with alpha channel last, 16 bits (little endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGRA64_LE: GstVideoFormat = 106;
#[doc = " GST_VIDEO_FORMAT_BGRA64_BE:\n\n Reverse RGB with alpha channel last, 16 bits (big endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_BGRA64_BE: GstVideoFormat = 107;
#[doc = " GST_VIDEO_FORMAT_ABGR64_LE:\n\n Reverse RGB with alpha channel first, 16 bits (little endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_ABGR64_LE: GstVideoFormat = 108;
#[doc = " GST_VIDEO_FORMAT_ABGR64_BE:\n\n Reverse RGB with alpha channel first, 16 bits (big endian)\n per channel.\n\n Since: 1.20"]
pub const GstVideoFormat_GST_VIDEO_FORMAT_ABGR64_BE: GstVideoFormat = 109;
#[doc = " GstVideoFormat:\n @GST_VIDEO_FORMAT_UNKNOWN: Unknown or unset video format id\n @GST_VIDEO_FORMAT_ENCODED: Encoded video format. Only ever use that in caps for\n                            special video formats in combination with non-system\n                            memory GstCapsFeatures where it does not make sense\n                            to specify a real video format.\n @GST_VIDEO_FORMAT_I420: planar 4:2:0 YUV\n @GST_VIDEO_FORMAT_YV12: planar 4:2:0 YVU (like I420 but UV planes swapped)\n @GST_VIDEO_FORMAT_YUY2: packed 4:2:2 YUV (Y0-U0-Y1-V0 Y2-U2-Y3-V2 Y4 ...)\n @GST_VIDEO_FORMAT_UYVY: packed 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4 ...)\n @GST_VIDEO_FORMAT_VYUY: packed 4:2:2 YUV (V0-Y0-U0-Y1 V2-Y2-U2-Y3 V4 ...)\n @GST_VIDEO_FORMAT_AYUV: packed 4:4:4 YUV with alpha channel (A0-Y0-U0-V0 ...)\n @GST_VIDEO_FORMAT_RGBx: sparse rgb packed into 32 bit, space last\n @GST_VIDEO_FORMAT_BGRx: sparse reverse rgb packed into 32 bit, space last\n @GST_VIDEO_FORMAT_xRGB: sparse rgb packed into 32 bit, space first\n @GST_VIDEO_FORMAT_xBGR: sparse reverse rgb packed into 32 bit, space first\n @GST_VIDEO_FORMAT_RGBA: rgb with alpha channel last\n @GST_VIDEO_FORMAT_BGRA: reverse rgb with alpha channel last\n @GST_VIDEO_FORMAT_ARGB: rgb with alpha channel first\n @GST_VIDEO_FORMAT_ABGR: reverse rgb with alpha channel first\n @GST_VIDEO_FORMAT_RGB: RGB packed into 24 bits without padding (`R-G-B-R-G-B`)\n @GST_VIDEO_FORMAT_BGR: reverse RGB packed into 24 bits without padding (`B-G-R-B-G-R`)\n @GST_VIDEO_FORMAT_Y41B: planar 4:1:1 YUV\n @GST_VIDEO_FORMAT_Y42B: planar 4:2:2 YUV\n @GST_VIDEO_FORMAT_YVYU: packed 4:2:2 YUV (Y0-V0-Y1-U0 Y2-V2-Y3-U2 Y4 ...)\n @GST_VIDEO_FORMAT_Y444: planar 4:4:4 YUV\n @GST_VIDEO_FORMAT_v210: packed 4:2:2 10-bit YUV, complex format\n @GST_VIDEO_FORMAT_v216: packed 4:2:2 16-bit YUV, Y0-U0-Y1-V1 order\n @GST_VIDEO_FORMAT_NV12: planar 4:2:0 YUV with interleaved UV plane\n @GST_VIDEO_FORMAT_NV21: planar 4:2:0 YUV with interleaved VU plane\n @GST_VIDEO_FORMAT_NV12_10LE32: 10-bit variant of @GST_VIDEO_FORMAT_NV12, packed into 32bit words (MSB 2 bits padding) (Since: 1.14)\n @GST_VIDEO_FORMAT_GRAY8: 8-bit grayscale\n @GST_VIDEO_FORMAT_GRAY10_LE32: 10-bit grayscale, packed into 32bit words (2 bits padding) (Since: 1.14)\n @GST_VIDEO_FORMAT_GRAY16_BE: 16-bit grayscale, most significant byte first\n @GST_VIDEO_FORMAT_GRAY16_LE: 16-bit grayscale, least significant byte first\n @GST_VIDEO_FORMAT_v308: packed 4:4:4 YUV (Y-U-V ...)\n @GST_VIDEO_FORMAT_IYU2: packed 4:4:4 YUV (U-Y-V ...) (Since: 1.10)\n @GST_VIDEO_FORMAT_RGB16: rgb 5-6-5 bits per component\n @GST_VIDEO_FORMAT_BGR16: reverse rgb 5-6-5 bits per component\n @GST_VIDEO_FORMAT_RGB15: rgb 5-5-5 bits per component\n @GST_VIDEO_FORMAT_BGR15: reverse rgb 5-5-5 bits per component\n @GST_VIDEO_FORMAT_UYVP: packed 10-bit 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4 ...)\n @GST_VIDEO_FORMAT_A420: planar 4:4:2:0 AYUV\n @GST_VIDEO_FORMAT_RGB8P: 8-bit paletted RGB\n @GST_VIDEO_FORMAT_YUV9: planar 4:1:0 YUV\n @GST_VIDEO_FORMAT_YVU9: planar 4:1:0 YUV (like YUV9 but UV planes swapped)\n @GST_VIDEO_FORMAT_IYU1: packed 4:1:1 YUV (Cb-Y0-Y1-Cr-Y2-Y3 ...)\n @GST_VIDEO_FORMAT_ARGB64: rgb with alpha channel first, 16 bits (native endianness) per channel\n @GST_VIDEO_FORMAT_AYUV64: packed 4:4:4 YUV with alpha channel, 16 bits (native endianness) per channel (A0-Y0-U0-V0 ...)\n @GST_VIDEO_FORMAT_r210: packed 4:4:4 RGB, 10 bits per channel\n @GST_VIDEO_FORMAT_I420_10BE: planar 4:2:0 YUV, 10 bits per channel\n @GST_VIDEO_FORMAT_I420_10LE: planar 4:2:0 YUV, 10 bits per channel\n @GST_VIDEO_FORMAT_I422_10BE: planar 4:2:2 YUV, 10 bits per channel\n @GST_VIDEO_FORMAT_I422_10LE: planar 4:2:2 YUV, 10 bits per channel\n @GST_VIDEO_FORMAT_Y444_10BE: planar 4:4:4 YUV, 10 bits per channel (Since: 1.2)\n @GST_VIDEO_FORMAT_Y444_10LE: planar 4:4:4 YUV, 10 bits per channel (Since: 1.2)\n @GST_VIDEO_FORMAT_GBR: planar 4:4:4 RGB, 8 bits per channel (Since: 1.2)\n @GST_VIDEO_FORMAT_GBR_10BE: planar 4:4:4 RGB, 10 bits per channel (Since: 1.2)\n @GST_VIDEO_FORMAT_GBR_10LE: planar 4:4:4 RGB, 10 bits per channel (Since: 1.2)\n @GST_VIDEO_FORMAT_NV16: planar 4:2:2 YUV with interleaved UV plane (Since: 1.2)\n @GST_VIDEO_FORMAT_NV16_10LE32: 10-bit variant of @GST_VIDEO_FORMAT_NV16, packed into 32bit words (MSB 2 bits padding) (Since: 1.14)\n @GST_VIDEO_FORMAT_NV24: planar 4:4:4 YUV with interleaved UV plane (Since: 1.2)\n @GST_VIDEO_FORMAT_NV12_64Z32: NV12 with 64x32 tiling in zigzag pattern (Since: 1.4)\n @GST_VIDEO_FORMAT_A420_10BE: planar 4:4:2:0 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_A420_10LE: planar 4:4:2:0 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_A422_10BE: planar 4:4:2:2 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_A422_10LE: planar 4:4:2:2 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_A444_10BE: planar 4:4:4:4 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_A444_10LE: planar 4:4:4:4 YUV, 10 bits per channel (Since: 1.6)\n @GST_VIDEO_FORMAT_NV61: planar 4:2:2 YUV with interleaved VU plane (Since: 1.6)\n @GST_VIDEO_FORMAT_P010_10BE: planar 4:2:0 YUV with interleaved UV plane, 10 bits per channel (Since: 1.10)\n @GST_VIDEO_FORMAT_P010_10LE: planar 4:2:0 YUV with interleaved UV plane, 10 bits per channel (Since: 1.10)\n @GST_VIDEO_FORMAT_GBRA: planar 4:4:4:4 ARGB, 8 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBRA_10BE: planar 4:4:4:4 ARGB, 10 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBRA_10LE: planar 4:4:4:4 ARGB, 10 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBR_12BE: planar 4:4:4 RGB, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBR_12LE: planar 4:4:4 RGB, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBRA_12BE: planar 4:4:4:4 ARGB, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_GBRA_12LE: planar 4:4:4:4 ARGB, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_I420_12BE: planar 4:2:0 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_I420_12LE: planar 4:2:0 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_I422_12BE: planar 4:2:2 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_I422_12LE: planar 4:2:2 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_Y444_12BE: planar 4:4:4 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_Y444_12LE: planar 4:4:4 YUV, 12 bits per channel (Since: 1.12)\n @GST_VIDEO_FORMAT_NV12_10LE40: Fully packed variant of NV12_10LE32 (Since: 1.16)\n @GST_VIDEO_FORMAT_Y210: packed 4:2:2 YUV, 10 bits per channel (Since: 1.16)\n @GST_VIDEO_FORMAT_Y410: packed 4:4:4 YUV, 10 bits per channel(A-V-Y-U...) (Since: 1.16)\n @GST_VIDEO_FORMAT_VUYA: packed 4:4:4 YUV with alpha channel (V0-U0-Y0-A0...) (Since: 1.16)\n @GST_VIDEO_FORMAT_BGR10A2_LE: packed 4:4:4 RGB with alpha channel(B-G-R-A), 10 bits for R/G/B channel and MSB 2 bits for alpha channel (Since: 1.16)\n @GST_VIDEO_FORMAT_RGB10A2_LE: packed 4:4:4 RGB with alpha channel(R-G-B-A), 10 bits for R/G/B channel and MSB 2 bits for alpha channel (Since: 1.18)\n @GST_VIDEO_FORMAT_Y444_16BE: planar 4:4:4 YUV, 16 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_Y444_16LE: planar 4:4:4 YUV, 16 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_P016_BE: planar 4:2:0 YUV with interleaved UV plane, 16 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_P016_LE: planar 4:2:0 YUV with interleaved UV plane, 16 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_P012_BE: planar 4:2:0 YUV with interleaved UV plane, 12 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_P012_LE: planar 4:2:0 YUV with interleaved UV plane, 12 bits per channel (Since: 1.18)\n @GST_VIDEO_FORMAT_Y212_BE: packed 4:2:2 YUV, 12 bits per channel (Y-U-Y-V) (Since: 1.18)\n @GST_VIDEO_FORMAT_Y212_LE: packed 4:2:2 YUV, 12 bits per channel (Y-U-Y-V) (Since: 1.18)\n @GST_VIDEO_FORMAT_Y412_BE: packed 4:4:4:4 YUV, 12 bits per channel(U-Y-V-A...) (Since: 1.18)\n @GST_VIDEO_FORMAT_Y412_LE: packed 4:4:4:4 YUV, 12 bits per channel(U-Y-V-A...) (Since: 1.18)\n @GST_VIDEO_FORMAT_NV12_4L4: NV12 with 4x4 tiles in linear order (Since: 1.18)\n @GST_VIDEO_FORMAT_NV12_32L32: NV12 with 32x32 tiles in linear order (Since: 1.18)\n @GST_VIDEO_FORMAT_RGBP: planar 4:4:4 RGB, 8 bits per channel (Since: 1.20)\n @GST_VIDEO_FORMAT_BGRP: planar 4:4:4 RGB, 8 bits per channel (Since: 1.20)\n @GST_VIDEO_FORMAT_AV12: Planar 4:2:0 YUV with interleaved UV plane with alpha as 3rd plane (Since: 1.20)\n @GST_VIDEO_FORMAT_ARGB64_LE: RGB with alpha channel first, 16 bits per channel\n @GST_VIDEO_FORMAT_ARGB64_BE: RGB with alpha channel first, 16 bits per channel\n @GST_VIDEO_FORMAT_RGBA64_LE: RGB with alpha channel last, 16 bits per channel\n @GST_VIDEO_FORMAT_RGBA64_BE: RGB with alpha channel last, 16 bits per channel\n @GST_VIDEO_FORMAT_BGRA64_LE: reverse RGB with alpha channel last, 16 bits per channel\n @GST_VIDEO_FORMAT_BGRA64_BE: reverse RGB with alpha channel last, 16 bits per channel\n @GST_VIDEO_FORMAT_ABGR64_LE: reverse RGB with alpha channel first, 16 bits per channel\n @GST_VIDEO_FORMAT_ABGR64_BE: reverse RGB with alpha channel first, 16 bits per channel\n\n Enum value describing the most common video formats.\n\n See the [GStreamer raw video format design document](https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats)\n for details about the layout and packing of these formats in memory."]
pub type GstVideoFormat = ::std::os::raw::c_uint;
#[doc = " GstVideoFormatInfo:\n @format: #GstVideoFormat\n @name: string representation of the format\n @description: use readable description of the format\n @flags: #GstVideoFormatFlags\n @bits: The number of bits used to pack data items. This can be less than 8\n    when multiple pixels are stored in a byte. for values > 8 multiple bytes\n    should be read according to the endianness flag before applying the shift\n    and mask.\n @n_components: the number of components in the video format.\n @shift: the number of bits to shift away to get the component data\n @depth: the depth in bits for each component\n @pixel_stride: the pixel stride of each component. This is the amount of\n    bytes to the pixel immediately to the right. When bits < 8, the stride is\n    expressed in bits. For 24-bit RGB, this would be 3 bytes, for example,\n    while it would be 4 bytes for RGBx or ARGB.\n @n_planes: the number of planes for this format. The number of planes can be\n    less than the amount of components when multiple components are packed into\n    one plane.\n @plane: the plane number where a component can be found\n @poffset: the offset in the plane where the first pixel of the components\n    can be found.\n @w_sub: subsampling factor of the width for the component. Use\n     GST_VIDEO_SUB_SCALE to scale a width.\n @h_sub: subsampling factor of the height for the component. Use\n     GST_VIDEO_SUB_SCALE to scale a height.\n @unpack_format: the format of the unpacked pixels. This format must have the\n     #GST_VIDEO_FORMAT_FLAG_UNPACK flag set.\n @unpack_func: an unpack function for this format\n @pack_lines: the amount of lines that will be packed\n @pack_func: an pack function for this format\n @tile_mode: The tiling mode\n @tile_ws: The width of a tile, in bytes, represented as a shift\n @tile_hs: The height of a tile, in bytes, represented as a shift\n\n Information for a video format."]
pub type GstVideoFormatInfo = _GstVideoFormatInfo;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_YUV: GstVideoFormatFlags = 1;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_RGB: GstVideoFormatFlags = 2;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_GRAY: GstVideoFormatFlags = 4;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_ALPHA: GstVideoFormatFlags = 8;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_LE: GstVideoFormatFlags = 16;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_PALETTE: GstVideoFormatFlags = 32;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_COMPLEX: GstVideoFormatFlags = 64;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_UNPACK: GstVideoFormatFlags = 128;
pub const GstVideoFormatFlags_GST_VIDEO_FORMAT_FLAG_TILED: GstVideoFormatFlags = 256;
#[doc = " GstVideoFormatFlags:\n @GST_VIDEO_FORMAT_FLAG_YUV: The video format is YUV, components are numbered\n   0=Y, 1=U, 2=V.\n @GST_VIDEO_FORMAT_FLAG_RGB: The video format is RGB, components are numbered\n   0=R, 1=G, 2=B.\n @GST_VIDEO_FORMAT_FLAG_GRAY: The video is gray, there is one gray component\n   with index 0.\n @GST_VIDEO_FORMAT_FLAG_ALPHA: The video format has an alpha components with\n   the number 3.\n @GST_VIDEO_FORMAT_FLAG_LE: The video format has data stored in little\n   endianness.\n @GST_VIDEO_FORMAT_FLAG_PALETTE: The video format has a palette. The palette\n   is stored in the second plane and indexes are stored in the first plane.\n @GST_VIDEO_FORMAT_FLAG_COMPLEX: The video format has a complex layout that\n   can't be described with the usual information in the #GstVideoFormatInfo.\n @GST_VIDEO_FORMAT_FLAG_UNPACK: This format can be used in a\n   #GstVideoFormatUnpack and #GstVideoFormatPack function.\n @GST_VIDEO_FORMAT_FLAG_TILED: The format is tiled, there is tiling information\n   in the last plane.\n\n The different video flags that a format info can have."]
pub type GstVideoFormatFlags = ::std::os::raw::c_uint;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_UNKNOWN: GstVideoChromaSite = 0;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_NONE: GstVideoChromaSite = 1;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_H_COSITED: GstVideoChromaSite = 2;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_V_COSITED: GstVideoChromaSite = 4;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_ALT_LINE: GstVideoChromaSite = 8;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_COSITED: GstVideoChromaSite = 6;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_JPEG: GstVideoChromaSite = 1;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_MPEG2: GstVideoChromaSite = 2;
pub const GstVideoChromaSite_GST_VIDEO_CHROMA_SITE_DV: GstVideoChromaSite = 14;
#[doc = " GstVideoChromaSite:\n @GST_VIDEO_CHROMA_SITE_UNKNOWN: unknown cositing\n @GST_VIDEO_CHROMA_SITE_NONE: no cositing\n @GST_VIDEO_CHROMA_SITE_H_COSITED: chroma is horizontally cosited\n @GST_VIDEO_CHROMA_SITE_V_COSITED: chroma is vertically cosited\n @GST_VIDEO_CHROMA_SITE_ALT_LINE: choma samples are sited on alternate lines\n @GST_VIDEO_CHROMA_SITE_COSITED: chroma samples cosited with luma samples\n @GST_VIDEO_CHROMA_SITE_JPEG: jpeg style cositing, also for mpeg1 and mjpeg\n @GST_VIDEO_CHROMA_SITE_MPEG2: mpeg2 style cositing\n @GST_VIDEO_CHROMA_SITE_DV: DV style cositing\n\n Various Chroma sitings."]
pub type GstVideoChromaSite = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_chroma_from_string(s: *const gchar) -> GstVideoChromaSite;
}
unsafe extern "C" {
    pub fn gst_video_chroma_to_string(site: GstVideoChromaSite) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_video_chroma_site_from_string(s: *const gchar) -> GstVideoChromaSite;
}
unsafe extern "C" {
    pub fn gst_video_chroma_site_to_string(site: GstVideoChromaSite) -> *mut gchar;
}
pub const GstVideoChromaMethod_GST_VIDEO_CHROMA_METHOD_NEAREST: GstVideoChromaMethod = 0;
pub const GstVideoChromaMethod_GST_VIDEO_CHROMA_METHOD_LINEAR: GstVideoChromaMethod = 1;
#[doc = " GstVideoChromaMethod:\n @GST_VIDEO_CHROMA_METHOD_NEAREST: Duplicates the chroma samples when\n    upsampling and drops when subsampling\n @GST_VIDEO_CHROMA_METHOD_LINEAR: Uses linear interpolation to reconstruct\n    missing chroma and averaging to subsample\n\n Different subsampling and upsampling methods"]
pub type GstVideoChromaMethod = ::std::os::raw::c_uint;
pub const GstVideoChromaFlags_GST_VIDEO_CHROMA_FLAG_NONE: GstVideoChromaFlags = 0;
pub const GstVideoChromaFlags_GST_VIDEO_CHROMA_FLAG_INTERLACED: GstVideoChromaFlags = 1;
#[doc = " GstVideoChromaFlags:\n @GST_VIDEO_CHROMA_FLAG_NONE: no flags\n @GST_VIDEO_CHROMA_FLAG_INTERLACED: the input is interlaced\n\n Extra flags that influence the result from gst_video_chroma_resample_new()."]
pub type GstVideoChromaFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoChromaResample {
    _unused: [u8; 0],
}
pub type GstVideoChromaResample = _GstVideoChromaResample;
unsafe extern "C" {
    pub fn gst_video_chroma_resample_new(
        method: GstVideoChromaMethod,
        site: GstVideoChromaSite,
        flags: GstVideoChromaFlags,
        format: GstVideoFormat,
        h_factor: gint,
        v_factor: gint,
    ) -> *mut GstVideoChromaResample;
}
unsafe extern "C" {
    pub fn gst_video_chroma_resample_free(resample: *mut GstVideoChromaResample);
}
unsafe extern "C" {
    pub fn gst_video_chroma_resample_get_info(
        resample: *mut GstVideoChromaResample,
        n_lines: *mut guint,
        offset: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_video_chroma_resample(
        resample: *mut GstVideoChromaResample,
        lines: *mut gpointer,
        width: gint,
    );
}
pub const GstVideoPackFlags_GST_VIDEO_PACK_FLAG_NONE: GstVideoPackFlags = 0;
pub const GstVideoPackFlags_GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE: GstVideoPackFlags = 1;
pub const GstVideoPackFlags_GST_VIDEO_PACK_FLAG_INTERLACED: GstVideoPackFlags = 2;
#[doc = " GstVideoPackFlags:\n @GST_VIDEO_PACK_FLAG_NONE: No flag\n @GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE: When the source has a smaller depth\n   than the target format, set the least significant bits of the target\n   to 0. This is likely slightly faster but less accurate. When this flag\n   is not specified, the most significant bits of the source are duplicated\n   in the least significant bits of the destination.\n @GST_VIDEO_PACK_FLAG_INTERLACED: The source is interlaced. The unpacked\n   format will be interlaced as well with each line containing\n   information from alternating fields. (Since: 1.2)\n\n The different flags that can be used when packing and unpacking."]
pub type GstVideoPackFlags = ::std::os::raw::c_uint;
#[doc = " GstVideoFormatUnpack:\n @info: a #GstVideoFormatInfo\n @flags: flags to control the unpacking\n @dest: a destination array\n @data: pointers to the data planes\n @stride: strides of the planes\n @x: the x position in the image to start from\n @y: the y position in the image to start from\n @width: the amount of pixels to unpack.\n\n Unpacks @width pixels from the given planes and strides containing data of\n format @info. The pixels will be unpacked into @dest with each component\n interleaved as per @info's unpack_format, which will usually be one of\n #GST_VIDEO_FORMAT_ARGB, #GST_VIDEO_FORMAT_AYUV, #GST_VIDEO_FORMAT_ARGB64 or\n #GST_VIDEO_FORMAT_AYUV64 depending on the format to unpack.\n @dest should at least be big enough to hold @width * bytes_per_pixel bytes\n where bytes_per_pixel relates to the unpack format and will usually be\n either 4 or 8 depending on the unpack format. bytes_per_pixel will be\n the same as the pixel stride for plane 0 for the above formats.\n\n For subsampled formats, the components will be duplicated in the destination\n array. Reconstruction of the missing components can be performed in a\n separate step after unpacking."]
pub type GstVideoFormatUnpack = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const GstVideoFormatInfo,
        flags: GstVideoPackFlags,
        dest: gpointer,
        data: *const gpointer,
        stride: *const gint,
        x: gint,
        y: gint,
        width: gint,
    ),
>;
#[doc = " GstVideoFormatPack:\n @info: a #GstVideoFormatInfo\n @flags: flags to control the packing\n @src: a source array\n @sstride: the source array stride\n @data: pointers to the destination data planes\n @stride: strides of the destination planes\n @chroma_site: the chroma siting of the target when subsampled (not used)\n @y: the y position in the image to pack to\n @width: the amount of pixels to pack.\n\n Packs @width pixels from @src to the given planes and strides in the\n format @info. The pixels from source have each component interleaved\n and will be packed into the planes in @data.\n\n This function operates on pack_lines lines, meaning that @src should\n contain at least pack_lines lines with a stride of @sstride and @y\n should be a multiple of pack_lines.\n\n Subsampled formats will use the horizontally and vertically cosited\n component from the source. Subsampling should be performed before\n packing.\n\n Because this function does not have a x coordinate, it is not possible to\n pack pixels starting from an unaligned position. For tiled images this\n means that packing should start from a tile coordinate. For subsampled\n formats this means that a complete pixel needs to be packed."]
pub type GstVideoFormatPack = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const GstVideoFormatInfo,
        flags: GstVideoPackFlags,
        src: gpointer,
        sstride: gint,
        data: *mut gpointer,
        stride: *const gint,
        chroma_site: GstVideoChromaSite,
        y: gint,
        width: gint,
    ),
>;
#[doc = " GstVideoFormatInfo:\n @format: #GstVideoFormat\n @name: string representation of the format\n @description: use readable description of the format\n @flags: #GstVideoFormatFlags\n @bits: The number of bits used to pack data items. This can be less than 8\n    when multiple pixels are stored in a byte. for values > 8 multiple bytes\n    should be read according to the endianness flag before applying the shift\n    and mask.\n @n_components: the number of components in the video format.\n @shift: the number of bits to shift away to get the component data\n @depth: the depth in bits for each component\n @pixel_stride: the pixel stride of each component. This is the amount of\n    bytes to the pixel immediately to the right. When bits < 8, the stride is\n    expressed in bits. For 24-bit RGB, this would be 3 bytes, for example,\n    while it would be 4 bytes for RGBx or ARGB.\n @n_planes: the number of planes for this format. The number of planes can be\n    less than the amount of components when multiple components are packed into\n    one plane.\n @plane: the plane number where a component can be found\n @poffset: the offset in the plane where the first pixel of the components\n    can be found.\n @w_sub: subsampling factor of the width for the component. Use\n     GST_VIDEO_SUB_SCALE to scale a width.\n @h_sub: subsampling factor of the height for the component. Use\n     GST_VIDEO_SUB_SCALE to scale a height.\n @unpack_format: the format of the unpacked pixels. This format must have the\n     #GST_VIDEO_FORMAT_FLAG_UNPACK flag set.\n @unpack_func: an unpack function for this format\n @pack_lines: the amount of lines that will be packed\n @pack_func: an pack function for this format\n @tile_mode: The tiling mode\n @tile_ws: The width of a tile, in bytes, represented as a shift\n @tile_hs: The height of a tile, in bytes, represented as a shift\n\n Information for a video format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoFormatInfo {
    pub format: GstVideoFormat,
    pub name: *const gchar,
    pub description: *const gchar,
    pub flags: GstVideoFormatFlags,
    pub bits: guint,
    pub n_components: guint,
    pub shift: [guint; 4usize],
    pub depth: [guint; 4usize],
    pub pixel_stride: [gint; 4usize],
    pub n_planes: guint,
    pub plane: [guint; 4usize],
    pub poffset: [guint; 4usize],
    pub w_sub: [guint; 4usize],
    pub h_sub: [guint; 4usize],
    pub unpack_format: GstVideoFormat,
    pub unpack_func: GstVideoFormatUnpack,
    pub pack_lines: gint,
    pub pack_func: GstVideoFormatPack,
    pub tile_mode: GstVideoTileMode,
    pub tile_ws: guint,
    pub tile_hs: guint,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoFormatInfo"][::std::mem::size_of::<_GstVideoFormatInfo>() - 232usize];
    ["Alignment of _GstVideoFormatInfo"][::std::mem::align_of::<_GstVideoFormatInfo>() - 8usize];
    ["Offset of field: _GstVideoFormatInfo::format"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, format) - 0usize];
    ["Offset of field: _GstVideoFormatInfo::name"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, name) - 8usize];
    ["Offset of field: _GstVideoFormatInfo::description"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, description) - 16usize];
    ["Offset of field: _GstVideoFormatInfo::flags"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, flags) - 24usize];
    ["Offset of field: _GstVideoFormatInfo::bits"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, bits) - 28usize];
    ["Offset of field: _GstVideoFormatInfo::n_components"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, n_components) - 32usize];
    ["Offset of field: _GstVideoFormatInfo::shift"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, shift) - 36usize];
    ["Offset of field: _GstVideoFormatInfo::depth"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, depth) - 52usize];
    ["Offset of field: _GstVideoFormatInfo::pixel_stride"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, pixel_stride) - 68usize];
    ["Offset of field: _GstVideoFormatInfo::n_planes"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, n_planes) - 84usize];
    ["Offset of field: _GstVideoFormatInfo::plane"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, plane) - 88usize];
    ["Offset of field: _GstVideoFormatInfo::poffset"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, poffset) - 104usize];
    ["Offset of field: _GstVideoFormatInfo::w_sub"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, w_sub) - 120usize];
    ["Offset of field: _GstVideoFormatInfo::h_sub"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, h_sub) - 136usize];
    ["Offset of field: _GstVideoFormatInfo::unpack_format"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, unpack_format) - 152usize];
    ["Offset of field: _GstVideoFormatInfo::unpack_func"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, unpack_func) - 160usize];
    ["Offset of field: _GstVideoFormatInfo::pack_lines"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, pack_lines) - 168usize];
    ["Offset of field: _GstVideoFormatInfo::pack_func"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, pack_func) - 176usize];
    ["Offset of field: _GstVideoFormatInfo::tile_mode"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, tile_mode) - 184usize];
    ["Offset of field: _GstVideoFormatInfo::tile_ws"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, tile_ws) - 188usize];
    ["Offset of field: _GstVideoFormatInfo::tile_hs"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, tile_hs) - 192usize];
    ["Offset of field: _GstVideoFormatInfo::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoFormatInfo, _gst_reserved) - 200usize];
};
unsafe extern "C" {
    pub fn gst_video_format_info_component(
        info: *const GstVideoFormatInfo,
        plane: guint,
        components: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_video_format_from_masks(
        depth: gint,
        bpp: gint,
        endianness: gint,
        red_mask: guint,
        green_mask: guint,
        blue_mask: guint,
        alpha_mask: guint,
    ) -> GstVideoFormat;
}
unsafe extern "C" {
    pub fn gst_video_format_from_fourcc(fourcc: guint32) -> GstVideoFormat;
}
unsafe extern "C" {
    pub fn gst_video_format_from_string(format: *const gchar) -> GstVideoFormat;
}
unsafe extern "C" {
    pub fn gst_video_format_to_fourcc(format: GstVideoFormat) -> guint32;
}
unsafe extern "C" {
    pub fn gst_video_format_to_string(format: GstVideoFormat) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_video_format_get_info(format: GstVideoFormat) -> *const GstVideoFormatInfo;
}
unsafe extern "C" {
    pub fn gst_video_format_get_palette(format: GstVideoFormat, size: *mut gsize) -> gconstpointer;
}
unsafe extern "C" {
    pub fn gst_video_formats_raw(len: *mut guint) -> *const GstVideoFormat;
}
unsafe extern "C" {
    pub fn gst_video_make_raw_caps(formats: *const GstVideoFormat, len: guint) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_video_make_raw_caps_with_features(
        formats: *const GstVideoFormat,
        len: guint,
        features: *mut GstCapsFeatures,
    ) -> *mut GstCaps;
}
pub const GstVideoColorRange_GST_VIDEO_COLOR_RANGE_UNKNOWN: GstVideoColorRange = 0;
pub const GstVideoColorRange_GST_VIDEO_COLOR_RANGE_0_255: GstVideoColorRange = 1;
pub const GstVideoColorRange_GST_VIDEO_COLOR_RANGE_16_235: GstVideoColorRange = 2;
#[doc = " GstVideoColorRange:\n @GST_VIDEO_COLOR_RANGE_UNKNOWN: unknown range\n @GST_VIDEO_COLOR_RANGE_0_255: [0..255] for 8 bit components\n @GST_VIDEO_COLOR_RANGE_16_235: [16..235] for 8 bit components. Chroma has\n                 [16..240] range.\n\n Possible color range values. These constants are defined for 8 bit color\n values and can be scaled for other bit depths."]
pub type GstVideoColorRange = ::std::os::raw::c_uint;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_UNKNOWN: GstVideoColorMatrix = 0;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_RGB: GstVideoColorMatrix = 1;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_FCC: GstVideoColorMatrix = 2;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_BT709: GstVideoColorMatrix = 3;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_BT601: GstVideoColorMatrix = 4;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_SMPTE240M: GstVideoColorMatrix = 5;
pub const GstVideoColorMatrix_GST_VIDEO_COLOR_MATRIX_BT2020: GstVideoColorMatrix = 6;
#[doc = " GstVideoColorMatrix:\n @GST_VIDEO_COLOR_MATRIX_UNKNOWN: unknown matrix\n @GST_VIDEO_COLOR_MATRIX_RGB: identity matrix. Order of coefficients is\n actually GBR, also IEC 61966-2-1 (sRGB)\n @GST_VIDEO_COLOR_MATRIX_FCC: FCC Title 47 Code of Federal Regulations 73.682 (a)(20)\n @GST_VIDEO_COLOR_MATRIX_BT709: ITU-R BT.709 color matrix, also ITU-R BT1361\n / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B\n @GST_VIDEO_COLOR_MATRIX_BT601: ITU-R BT.601 color matrix, also SMPTE170M / ITU-R BT1358 525 / ITU-R BT1700 NTSC\n @GST_VIDEO_COLOR_MATRIX_SMPTE240M: SMPTE 240M color matrix\n @GST_VIDEO_COLOR_MATRIX_BT2020: ITU-R BT.2020 color matrix. Since: 1.6\n\n The color matrix is used to convert between Y'PbPr and\n non-linear RGB (R'G'B')"]
pub type GstVideoColorMatrix = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_color_matrix_get_Kr_Kb(
        matrix: GstVideoColorMatrix,
        Kr: *mut gdouble,
        Kb: *mut gdouble,
    ) -> gboolean;
}
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_UNKNOWN: GstVideoTransferFunction = 0;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_GAMMA10: GstVideoTransferFunction = 1;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_GAMMA18: GstVideoTransferFunction = 2;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_GAMMA20: GstVideoTransferFunction = 3;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_GAMMA22: GstVideoTransferFunction = 4;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_BT709: GstVideoTransferFunction = 5;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_SMPTE240M: GstVideoTransferFunction = 6;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_SRGB: GstVideoTransferFunction = 7;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_GAMMA28: GstVideoTransferFunction = 8;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_LOG100: GstVideoTransferFunction = 9;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_LOG316: GstVideoTransferFunction = 10;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_BT2020_12: GstVideoTransferFunction = 11;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_ADOBERGB: GstVideoTransferFunction = 12;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_BT2020_10: GstVideoTransferFunction = 13;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_SMPTE2084: GstVideoTransferFunction = 14;
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_ARIB_STD_B67: GstVideoTransferFunction = 15;
#[doc = " GST_VIDEO_TRANSFER_BT601:\n\n also known as SMPTE170M / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC\n\n Since: 1.18"]
pub const GstVideoTransferFunction_GST_VIDEO_TRANSFER_BT601: GstVideoTransferFunction = 16;
#[doc = " GstVideoTransferFunction:\n @GST_VIDEO_TRANSFER_UNKNOWN: unknown transfer function\n @GST_VIDEO_TRANSFER_GAMMA10: linear RGB, gamma 1.0 curve\n @GST_VIDEO_TRANSFER_GAMMA18: Gamma 1.8 curve\n @GST_VIDEO_TRANSFER_GAMMA20: Gamma 2.0 curve\n @GST_VIDEO_TRANSFER_GAMMA22: Gamma 2.2 curve\n @GST_VIDEO_TRANSFER_BT709: Gamma 2.2 curve with a linear segment in the lower\n                           range, also ITU-R BT470M / ITU-R BT1700 625 PAL &\n                           SECAM / ITU-R BT1361\n @GST_VIDEO_TRANSFER_SMPTE240M: Gamma 2.2 curve with a linear segment in the\n                               lower range\n @GST_VIDEO_TRANSFER_SRGB: Gamma 2.4 curve with a linear segment in the lower\n                          range. IEC 61966-2-1 (sRGB or sYCC)\n @GST_VIDEO_TRANSFER_GAMMA28: Gamma 2.8 curve, also ITU-R BT470BG\n @GST_VIDEO_TRANSFER_LOG100: Logarithmic transfer characteristic\n                             100:1 range\n @GST_VIDEO_TRANSFER_LOG316: Logarithmic transfer characteristic\n                             316.22777:1 range (100 * sqrt(10) : 1)\n @GST_VIDEO_TRANSFER_BT2020_12: Gamma 2.2 curve with a linear segment in the lower\n                                range. Used for BT.2020 with 12 bits per\n                                component. Since: 1.6\n @GST_VIDEO_TRANSFER_ADOBERGB: Gamma 2.19921875. Since: 1.8\n @GST_VIDEO_TRANSFER_BT2020_10: Rec. ITU-R BT.2020-2 with 10 bits per component.\n                                (functionally the same as the values\n                                GST_VIDEO_TRANSFER_BT709 and GST_VIDEO_TRANSFER_BT601).\n                                Since: 1.18\n @GST_VIDEO_TRANSFER_SMPTE2084: SMPTE ST 2084 for 10, 12, 14, and 16-bit systems.\n                                Known as perceptual quantization (PQ)\n                                Since: 1.18\n @GST_VIDEO_TRANSFER_ARIB_STD_B67: Association of Radio Industries and Businesses (ARIB)\n                                   STD-B67 and Rec. ITU-R BT.2100-1 hybrid loggamma (HLG) system\n                                   Since: 1.18\n @GST_VIDEO_TRANSFER_BT601: also known as SMPTE170M / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC\n                            Functionally the same as the values\n                            GST_VIDEO_TRANSFER_BT709, and GST_VIDEO_TRANSFER_BT2020_10.\n                            Since: 1.18\n\n The video transfer function defines the formula for converting between\n non-linear RGB (R'G'B') and linear RGB"]
pub type GstVideoTransferFunction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_color_transfer_encode(func: GstVideoTransferFunction, val: gdouble)
    -> gdouble;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_encode(
        func: GstVideoTransferFunction,
        val: gdouble,
    ) -> gdouble;
}
unsafe extern "C" {
    pub fn gst_video_color_transfer_decode(func: GstVideoTransferFunction, val: gdouble)
    -> gdouble;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_decode(
        func: GstVideoTransferFunction,
        val: gdouble,
    ) -> gdouble;
}
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_UNKNOWN: GstVideoColorPrimaries = 0;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_BT709: GstVideoColorPrimaries = 1;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_BT470M: GstVideoColorPrimaries = 2;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_BT470BG: GstVideoColorPrimaries = 3;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_SMPTE170M: GstVideoColorPrimaries = 4;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_SMPTE240M: GstVideoColorPrimaries = 5;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_FILM: GstVideoColorPrimaries = 6;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_BT2020: GstVideoColorPrimaries = 7;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_ADOBERGB: GstVideoColorPrimaries = 8;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_SMPTEST428: GstVideoColorPrimaries = 9;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_SMPTERP431: GstVideoColorPrimaries = 10;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_SMPTEEG432: GstVideoColorPrimaries = 11;
pub const GstVideoColorPrimaries_GST_VIDEO_COLOR_PRIMARIES_EBU3213: GstVideoColorPrimaries = 12;
#[doc = " GstVideoColorPrimaries:\n @GST_VIDEO_COLOR_PRIMARIES_UNKNOWN: unknown color primaries\n @GST_VIDEO_COLOR_PRIMARIES_BT709: BT709 primaries, also ITU-R BT1361 / IEC\n 61966-2-4 / SMPTE RP177 Annex B\n @GST_VIDEO_COLOR_PRIMARIES_BT470M: BT470M primaries, also FCC Title 47 Code\n of Federal Regulations 73.682 (a)(20)\n @GST_VIDEO_COLOR_PRIMARIES_BT470BG: BT470BG primaries, also ITU-R BT601-6\n 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM\n @GST_VIDEO_COLOR_PRIMARIES_SMPTE170M: SMPTE170M primaries, also ITU-R\n BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC\n @GST_VIDEO_COLOR_PRIMARIES_SMPTE240M: SMPTE240M primaries\n @GST_VIDEO_COLOR_PRIMARIES_FILM: Generic film (colour filters using\n Illuminant C)\n @GST_VIDEO_COLOR_PRIMARIES_BT2020: ITU-R BT2020 primaries. Since: 1.6\n @GST_VIDEO_COLOR_PRIMARIES_ADOBERGB: Adobe RGB primaries. Since: 1.8\n @GST_VIDEO_COLOR_PRIMARIES_SMPTEST428: SMPTE ST 428 primaries (CIE 1931\n XYZ). Since: 1.16\n @GST_VIDEO_COLOR_PRIMARIES_SMPTERP431: SMPTE RP 431 primaries (ST 431-2\n (2011) / DCI P3). Since: 1.16\n @GST_VIDEO_COLOR_PRIMARIES_SMPTEEG432: SMPTE EG 432 primaries (ST 432-1\n (2010) / P3 D65). Since: 1.16\n @GST_VIDEO_COLOR_PRIMARIES_EBU3213: EBU 3213 primaries (JEDEC P22\n phosphors). Since: 1.16\n\n The color primaries define the how to transform linear RGB values to and from\n the CIE XYZ colorspace."]
pub type GstVideoColorPrimaries = ::std::os::raw::c_uint;
#[doc = " GstVideoColorPrimariesInfo:\n @primaries: a #GstVideoColorPrimaries\n @Wx: reference white x coordinate\n @Wy: reference white y coordinate\n @Rx: red x coordinate\n @Ry: red y coordinate\n @Gx: green x coordinate\n @Gy: green y coordinate\n @Bx: blue x coordinate\n @By: blue y coordinate\n\n Structure describing the chromaticity coordinates of an RGB system. These\n values can be used to construct a matrix to transform RGB to and from the\n XYZ colorspace.\n\n Since: 1.6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoColorPrimariesInfo {
    pub primaries: GstVideoColorPrimaries,
    pub Wx: gdouble,
    pub Wy: gdouble,
    pub Rx: gdouble,
    pub Ry: gdouble,
    pub Gx: gdouble,
    pub Gy: gdouble,
    pub Bx: gdouble,
    pub By: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoColorPrimariesInfo"]
        [::std::mem::size_of::<GstVideoColorPrimariesInfo>() - 72usize];
    ["Alignment of GstVideoColorPrimariesInfo"]
        [::std::mem::align_of::<GstVideoColorPrimariesInfo>() - 8usize];
    ["Offset of field: GstVideoColorPrimariesInfo::primaries"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, primaries) - 0usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Wx"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Wx) - 8usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Wy"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Wy) - 16usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Rx"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Rx) - 24usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Ry"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Ry) - 32usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Gx"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Gx) - 40usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Gy"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Gy) - 48usize];
    ["Offset of field: GstVideoColorPrimariesInfo::Bx"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, Bx) - 56usize];
    ["Offset of field: GstVideoColorPrimariesInfo::By"]
        [::std::mem::offset_of!(GstVideoColorPrimariesInfo, By) - 64usize];
};
unsafe extern "C" {
    pub fn gst_video_color_primaries_get_info(
        primaries: GstVideoColorPrimaries,
    ) -> *const GstVideoColorPrimariesInfo;
}
#[doc = " GstVideoColorimetry:\n @range: the color range. This is the valid range for the samples.\n         It is used to convert the samples to Y'PbPr values.\n @matrix: the color matrix. Used to convert between Y'PbPr and\n          non-linear RGB (R'G'B')\n @transfer: the transfer function. used to convert between R'G'B' and RGB\n @primaries: color primaries. used to convert between R'G'B' and CIE XYZ\n\n Structure describing the color info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoColorimetry {
    pub range: GstVideoColorRange,
    pub matrix: GstVideoColorMatrix,
    pub transfer: GstVideoTransferFunction,
    pub primaries: GstVideoColorPrimaries,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoColorimetry"][::std::mem::size_of::<GstVideoColorimetry>() - 16usize];
    ["Alignment of GstVideoColorimetry"][::std::mem::align_of::<GstVideoColorimetry>() - 4usize];
    ["Offset of field: GstVideoColorimetry::range"]
        [::std::mem::offset_of!(GstVideoColorimetry, range) - 0usize];
    ["Offset of field: GstVideoColorimetry::matrix"]
        [::std::mem::offset_of!(GstVideoColorimetry, matrix) - 4usize];
    ["Offset of field: GstVideoColorimetry::transfer"]
        [::std::mem::offset_of!(GstVideoColorimetry, transfer) - 8usize];
    ["Offset of field: GstVideoColorimetry::primaries"]
        [::std::mem::offset_of!(GstVideoColorimetry, primaries) - 12usize];
};
unsafe extern "C" {
    pub fn gst_video_colorimetry_matches(
        cinfo: *const GstVideoColorimetry,
        color: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_colorimetry_from_string(
        cinfo: *mut GstVideoColorimetry,
        color: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_colorimetry_to_string(cinfo: *const GstVideoColorimetry) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_video_colorimetry_is_equal(
        cinfo: *const GstVideoColorimetry,
        other: *const GstVideoColorimetry,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_color_range_offsets(
        range: GstVideoColorRange,
        info: *const GstVideoFormatInfo,
        offset: *mut gint,
        scale: *mut gint,
    );
}
unsafe extern "C" {
    pub fn gst_video_color_matrix_to_iso(matrix: GstVideoColorMatrix) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_to_iso(func: GstVideoTransferFunction) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_color_primaries_to_iso(primaries: GstVideoColorPrimaries) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_color_matrix_from_iso(value: guint) -> GstVideoColorMatrix;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_from_iso(value: guint) -> GstVideoTransferFunction;
}
unsafe extern "C" {
    pub fn gst_video_color_primaries_from_iso(value: guint) -> GstVideoColorPrimaries;
}
unsafe extern "C" {
    pub fn gst_video_transfer_function_is_equivalent(
        from_func: GstVideoTransferFunction,
        from_bpp: guint,
        to_func: GstVideoTransferFunction,
        to_bpp: guint,
    ) -> gboolean;
}
pub const GstVideoDitherMethod_GST_VIDEO_DITHER_NONE: GstVideoDitherMethod = 0;
pub const GstVideoDitherMethod_GST_VIDEO_DITHER_VERTERR: GstVideoDitherMethod = 1;
pub const GstVideoDitherMethod_GST_VIDEO_DITHER_FLOYD_STEINBERG: GstVideoDitherMethod = 2;
pub const GstVideoDitherMethod_GST_VIDEO_DITHER_SIERRA_LITE: GstVideoDitherMethod = 3;
pub const GstVideoDitherMethod_GST_VIDEO_DITHER_BAYER: GstVideoDitherMethod = 4;
#[doc = " GstVideoDitherMethod:\n @GST_VIDEO_DITHER_NONE: no dithering\n @GST_VIDEO_DITHER_VERTERR: propagate rounding errors downwards\n @GST_VIDEO_DITHER_FLOYD_STEINBERG: Dither with floyd-steinberg error diffusion\n @GST_VIDEO_DITHER_SIERRA_LITE: Dither with Sierra Lite error diffusion\n @GST_VIDEO_DITHER_BAYER: ordered dither using a bayer pattern\n\n Different dithering methods to use."]
pub type GstVideoDitherMethod = ::std::os::raw::c_uint;
pub const GstVideoDitherFlags_GST_VIDEO_DITHER_FLAG_NONE: GstVideoDitherFlags = 0;
pub const GstVideoDitherFlags_GST_VIDEO_DITHER_FLAG_INTERLACED: GstVideoDitherFlags = 1;
pub const GstVideoDitherFlags_GST_VIDEO_DITHER_FLAG_QUANTIZE: GstVideoDitherFlags = 2;
#[doc = " GstVideoDitherFlags:\n @GST_VIDEO_DITHER_FLAG_NONE: no flags\n @GST_VIDEO_DITHER_FLAG_INTERLACED: the input is interlaced\n @GST_VIDEO_DITHER_FLAG_QUANTIZE: quantize values in addition to adding dither.\n\n Extra flags that influence the result from gst_video_chroma_resample_new()."]
pub type GstVideoDitherFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoDither {
    _unused: [u8; 0],
}
pub type GstVideoDither = _GstVideoDither;
unsafe extern "C" {
    pub fn gst_video_dither_new(
        method: GstVideoDitherMethod,
        flags: GstVideoDitherFlags,
        format: GstVideoFormat,
        quantizer: *mut guint,
        width: guint,
    ) -> *mut GstVideoDither;
}
unsafe extern "C" {
    pub fn gst_video_dither_free(dither: *mut GstVideoDither);
}
unsafe extern "C" {
    pub fn gst_video_dither_line(
        dither: *mut GstVideoDither,
        line: gpointer,
        x: guint,
        y: guint,
        width: guint,
    );
}
#[doc = " GstVideoInfo:\n @finfo: the format info of the video\n @interlace_mode: the interlace mode\n @flags: additional video flags\n @width: the width of the video\n @height: the height of the video\n @views: the number of views for multiview video\n @size: the default size of one frame\n @chroma_site: a #GstVideoChromaSite.\n @colorimetry: the colorimetry info\n @par_n: the pixel-aspect-ratio numerator\n @par_d: the pixel-aspect-ratio denominator\n @fps_n: the framerate numerator\n @fps_d: the framerate denominator\n @offset: offsets of the planes\n @stride: strides of the planes\n @multiview_mode: delivery mode for multiple views. (Since: 1.6)\n @multiview_flags: flags for multiple views configuration (Since: 1.6)\n\n Information describing image properties. This information can be filled\n in from GstCaps with gst_video_info_from_caps(). The information is also used\n to store the specific video info when mapping a video frame with\n gst_video_frame_map().\n\n Use the provided macros to access the info in this structure."]
pub type GstVideoInfo = _GstVideoInfo;
pub const GstVideoInterlaceMode_GST_VIDEO_INTERLACE_MODE_PROGRESSIVE: GstVideoInterlaceMode = 0;
pub const GstVideoInterlaceMode_GST_VIDEO_INTERLACE_MODE_INTERLEAVED: GstVideoInterlaceMode = 1;
pub const GstVideoInterlaceMode_GST_VIDEO_INTERLACE_MODE_MIXED: GstVideoInterlaceMode = 2;
pub const GstVideoInterlaceMode_GST_VIDEO_INTERLACE_MODE_FIELDS: GstVideoInterlaceMode = 3;
pub const GstVideoInterlaceMode_GST_VIDEO_INTERLACE_MODE_ALTERNATE: GstVideoInterlaceMode = 4;
#[doc = " GstVideoInterlaceMode:\n @GST_VIDEO_INTERLACE_MODE_PROGRESSIVE: all frames are progressive\n @GST_VIDEO_INTERLACE_MODE_INTERLEAVED: 2 fields are interleaved in one video\n     frame. Extra buffer flags describe the field order.\n @GST_VIDEO_INTERLACE_MODE_MIXED: frames contains both interlaced and\n     progressive video, the buffer flags describe the frame and fields.\n @GST_VIDEO_INTERLACE_MODE_FIELDS: 2 fields are stored in one buffer, use the\n     frame ID to get access to the required field. For multiview (the\n     'views' property > 1) the fields of view N can be found at frame ID\n     (N * 2) and (N * 2) + 1.\n     Each field has only half the amount of lines as noted in the\n     height property. This mode requires multiple GstVideoMeta metadata\n     to describe the fields.\n @GST_VIDEO_INTERLACE_MODE_ALTERNATE: 1 field is stored in one buffer,\n     @GST_VIDEO_BUFFER_FLAG_TF or @GST_VIDEO_BUFFER_FLAG_BF indicates if\n     the buffer is carrying the top or bottom field, respectively. The top and\n     bottom buffers must alternate in the pipeline, with this mode\n     (Since: 1.16).\n\n The possible values of the #GstVideoInterlaceMode describing the interlace\n mode of the stream."]
pub type GstVideoInterlaceMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_interlace_mode_to_string(mode: GstVideoInterlaceMode) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_video_interlace_mode_from_string(mode: *const gchar) -> GstVideoInterlaceMode;
}
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_NONE: GstVideoMultiviewMode = -1;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_MONO: GstVideoMultiviewMode = 0;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_LEFT: GstVideoMultiviewMode = 1;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_RIGHT: GstVideoMultiviewMode = 2;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: GstVideoMultiviewMode = 3;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX:
    GstVideoMultiviewMode = 4;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED: GstVideoMultiviewMode =
    5;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED: GstVideoMultiviewMode = 6;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: GstVideoMultiviewMode = 7;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: GstVideoMultiviewMode = 8;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME: GstVideoMultiviewMode = 32;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME:
    GstVideoMultiviewMode = 33;
pub const GstVideoMultiviewMode_GST_VIDEO_MULTIVIEW_MODE_SEPARATED: GstVideoMultiviewMode = 34;
#[doc = " GstVideoMultiviewMode:\n @GST_VIDEO_MULTIVIEW_MODE_NONE: A special value indicating\n no multiview information. Used in GstVideoInfo and other places to\n indicate that no specific multiview handling has been requested or\n provided. This value is never carried on caps.\n @GST_VIDEO_MULTIVIEW_MODE_MONO: All frames are monoscopic.\n @GST_VIDEO_MULTIVIEW_MODE_LEFT: All frames represent a left-eye view.\n @GST_VIDEO_MULTIVIEW_MODE_RIGHT: All frames represent a right-eye view.\n @GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: Left and right eye views are\n provided in the left and right half of the frame respectively.\n @GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX: Left and right eye\n views are provided in the left and right half of the frame, but\n have been sampled using quincunx method, with half-pixel offset\n between the 2 views.\n @GST_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED: Alternating vertical\n columns of pixels represent the left and right eye view respectively.\n @GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED: Alternating horizontal\n rows of pixels represent the left and right eye view respectively.\n @GST_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: The top half of the frame\n contains the left eye, and the bottom half the right eye.\n @GST_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: Pixels are arranged with\n alternating pixels representing left and right eye views in a\n checkerboard fashion.\n @GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME: Left and right eye views\n are provided in separate frames alternately.\n @GST_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME: Multiple\n independent views are provided in separate frames in sequence.\n This method only applies to raw video buffers at the moment.\n Specific view identification is via the `GstVideoMultiviewMeta`\n and #GstVideoMeta(s) on raw video buffers.\n @GST_VIDEO_MULTIVIEW_MODE_SEPARATED: Multiple views are\n provided as separate #GstMemory framebuffers attached to each\n #GstBuffer, described by the `GstVideoMultiviewMeta`\n and #GstVideoMeta(s)\n\n All possible stereoscopic 3D and multiview representations.\n In conjunction with #GstVideoMultiviewFlags, describes how\n multiview content is being transported in the stream."]
pub type GstVideoMultiviewMode = ::std::os::raw::c_int;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_NONE:
    GstVideoMultiviewFramePacking = -1;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_MONO:
    GstVideoMultiviewFramePacking = 0;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_LEFT:
    GstVideoMultiviewFramePacking = 1;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_RIGHT:
    GstVideoMultiviewFramePacking = 2;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE:
    GstVideoMultiviewFramePacking = 3;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE_QUINCUNX:
    GstVideoMultiviewFramePacking = 4;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_COLUMN_INTERLEAVED:
    GstVideoMultiviewFramePacking = 5;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_ROW_INTERLEAVED:
    GstVideoMultiviewFramePacking = 6;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_TOP_BOTTOM:
    GstVideoMultiviewFramePacking = 7;
pub const GstVideoMultiviewFramePacking_GST_VIDEO_MULTIVIEW_FRAME_PACKING_CHECKERBOARD:
    GstVideoMultiviewFramePacking = 8;
#[doc = " GstVideoMultiviewFramePacking:\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_NONE: A special value indicating\n no frame packing info.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_MONO: All frames are monoscopic.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_LEFT: All frames represent a left-eye view.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_RIGHT: All frames represent a right-eye view.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE: Left and right eye views are\n provided in the left and right half of the frame respectively.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE_QUINCUNX: Left and right eye\n views are provided in the left and right half of the frame, but\n have been sampled using quincunx method, with half-pixel offset\n between the 2 views.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_COLUMN_INTERLEAVED: Alternating vertical\n columns of pixels represent the left and right eye view respectively.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_ROW_INTERLEAVED: Alternating horizontal\n rows of pixels represent the left and right eye view respectively.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_TOP_BOTTOM: The top half of the frame\n contains the left eye, and the bottom half the right eye.\n @GST_VIDEO_MULTIVIEW_FRAME_PACKING_CHECKERBOARD: Pixels are arranged with\n alternating pixels representing left and right eye views in a\n checkerboard fashion.\n\n #GstVideoMultiviewFramePacking represents the subset of #GstVideoMultiviewMode\n values that can be applied to any video frame without needing extra metadata.\n It can be used by elements that provide a property to override the\n multiview interpretation of a video stream when the video doesn't contain\n any markers.\n\n This enum is used (for example) on playbin, to re-interpret a played\n video stream as a stereoscopic video. The individual enum values are\n equivalent to and have the same value as the matching #GstVideoMultiviewMode.\n"]
pub type GstVideoMultiviewFramePacking = ::std::os::raw::c_int;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_NONE: GstVideoMultiviewFlags = 0;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST:
    GstVideoMultiviewFlags = 1;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED: GstVideoMultiviewFlags = 2;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED: GstVideoMultiviewFlags = 4;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED: GstVideoMultiviewFlags =
    8;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED: GstVideoMultiviewFlags =
    16;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT: GstVideoMultiviewFlags =
    16384;
pub const GstVideoMultiviewFlags_GST_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO: GstVideoMultiviewFlags =
    32768;
#[doc = " GstVideoMultiviewFlags:\n @GST_VIDEO_MULTIVIEW_FLAGS_NONE: No flags\n @GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST: For stereo streams, the\n     normal arrangement of left and right views is reversed.\n @GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED: The left view is vertically\n     mirrored.\n @GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED: The left view is horizontally\n     mirrored.\n @GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED: The right view is\n     vertically mirrored.\n @GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED: The right view is\n     horizontally mirrored.\n @GST_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT: For frame-packed\n     multiview modes, indicates that the individual\n     views have been encoded with half the true width or height\n     and should be scaled back up for display. This flag\n     is used for overriding input layout interpretation\n     by adjusting pixel-aspect-ratio.\n     For side-by-side, column interleaved or checkerboard packings, the\n     pixel width will be doubled. For row interleaved and top-bottom\n     encodings, pixel height will be doubled.\n @GST_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO: The video stream contains both\n     mono and multiview portions, signalled on each buffer by the\n     absence or presence of the @GST_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW\n     buffer flag.\n\n GstVideoMultiviewFlags are used to indicate extra properties of a\n stereo/multiview stream beyond the frame layout and buffer mapping\n that is conveyed in the #GstVideoMultiviewMode."]
pub type GstVideoMultiviewFlags = ::std::os::raw::c_uint;
pub const GstVideoFlags_GST_VIDEO_FLAG_NONE: GstVideoFlags = 0;
pub const GstVideoFlags_GST_VIDEO_FLAG_VARIABLE_FPS: GstVideoFlags = 1;
pub const GstVideoFlags_GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA: GstVideoFlags = 2;
#[doc = " GstVideoFlags:\n @GST_VIDEO_FLAG_NONE: no flags\n @GST_VIDEO_FLAG_VARIABLE_FPS: a variable fps is selected, fps_n and fps_d\n     denote the maximum fps of the video\n @GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA: Each color has been scaled by the alpha\n     value.\n\n Extra video flags"]
pub type GstVideoFlags = ::std::os::raw::c_uint;
pub const GstVideoFieldOrder_GST_VIDEO_FIELD_ORDER_UNKNOWN: GstVideoFieldOrder = 0;
pub const GstVideoFieldOrder_GST_VIDEO_FIELD_ORDER_TOP_FIELD_FIRST: GstVideoFieldOrder = 1;
pub const GstVideoFieldOrder_GST_VIDEO_FIELD_ORDER_BOTTOM_FIELD_FIRST: GstVideoFieldOrder = 2;
#[doc = " GstVideoFieldOrder:\n @GST_VIDEO_FIELD_ORDER_UNKNOWN: unknown field order for interlaced content.\n     The actual field order is signalled via buffer flags.\n @GST_VIDEO_FIELD_ORDER_TOP_FIELD_FIRST: top field is first\n @GST_VIDEO_FIELD_ORDER_BOTTOM_FIELD_FIRST: bottom field is first\n\n Field order of interlaced content. This is only valid for\n interlace-mode=interleaved and not interlace-mode=mixed. In the case of\n mixed or GST_VIDEO_FIELD_ORDER_UNKOWN, the field order is signalled via\n buffer flags.\n\n Since: 1.12"]
pub type GstVideoFieldOrder = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_field_order_to_string(order: GstVideoFieldOrder) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_video_field_order_from_string(order: *const gchar) -> GstVideoFieldOrder;
}
#[doc = " GstVideoInfo:\n @finfo: the format info of the video\n @interlace_mode: the interlace mode\n @flags: additional video flags\n @width: the width of the video\n @height: the height of the video\n @views: the number of views for multiview video\n @size: the default size of one frame\n @chroma_site: a #GstVideoChromaSite.\n @colorimetry: the colorimetry info\n @par_n: the pixel-aspect-ratio numerator\n @par_d: the pixel-aspect-ratio denominator\n @fps_n: the framerate numerator\n @fps_d: the framerate denominator\n @offset: offsets of the planes\n @stride: strides of the planes\n @multiview_mode: delivery mode for multiple views. (Since: 1.6)\n @multiview_flags: flags for multiple views configuration (Since: 1.6)\n\n Information describing image properties. This information can be filled\n in from GstCaps with gst_video_info_from_caps(). The information is also used\n to store the specific video info when mapping a video frame with\n gst_video_frame_map().\n\n Use the provided macros to access the info in this structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoInfo {
    pub finfo: *const GstVideoFormatInfo,
    pub interlace_mode: GstVideoInterlaceMode,
    pub flags: GstVideoFlags,
    pub width: gint,
    pub height: gint,
    pub size: gsize,
    pub views: gint,
    pub chroma_site: GstVideoChromaSite,
    pub colorimetry: GstVideoColorimetry,
    pub par_n: gint,
    pub par_d: gint,
    pub fps_n: gint,
    pub fps_d: gint,
    pub offset: [gsize; 4usize],
    pub stride: [gint; 4usize],
    pub ABI: _GstVideoInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstVideoInfo__bindgen_ty_1 {
    pub abi: _GstVideoInfo__bindgen_ty_1__bindgen_ty_1,
    pub _gst_reserved: [gpointer; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoInfo__bindgen_ty_1__bindgen_ty_1 {
    pub multiview_mode: GstVideoMultiviewMode,
    pub multiview_flags: GstVideoMultiviewFlags,
    pub field_order: GstVideoFieldOrder,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoInfo__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstVideoInfo__bindgen_ty_1__bindgen_ty_1>() - 12usize];
    ["Alignment of _GstVideoInfo__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstVideoInfo__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: _GstVideoInfo__bindgen_ty_1__bindgen_ty_1::multiview_mode"][::std::mem::offset_of!(
        _GstVideoInfo__bindgen_ty_1__bindgen_ty_1,
        multiview_mode
    ) - 0usize];
    ["Offset of field: _GstVideoInfo__bindgen_ty_1__bindgen_ty_1::multiview_flags"][::std::mem::offset_of!(
        _GstVideoInfo__bindgen_ty_1__bindgen_ty_1,
        multiview_flags
    ) - 4usize];
    ["Offset of field: _GstVideoInfo__bindgen_ty_1__bindgen_ty_1::field_order"]
        [::std::mem::offset_of!(_GstVideoInfo__bindgen_ty_1__bindgen_ty_1, field_order) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoInfo__bindgen_ty_1"]
        [::std::mem::size_of::<_GstVideoInfo__bindgen_ty_1>() - 32usize];
    ["Alignment of _GstVideoInfo__bindgen_ty_1"]
        [::std::mem::align_of::<_GstVideoInfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstVideoInfo__bindgen_ty_1::abi"]
        [::std::mem::offset_of!(_GstVideoInfo__bindgen_ty_1, abi) - 0usize];
    ["Offset of field: _GstVideoInfo__bindgen_ty_1::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoInfo__bindgen_ty_1, _gst_reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoInfo"][::std::mem::size_of::<_GstVideoInfo>() - 152usize];
    ["Alignment of _GstVideoInfo"][::std::mem::align_of::<_GstVideoInfo>() - 8usize];
    ["Offset of field: _GstVideoInfo::finfo"]
        [::std::mem::offset_of!(_GstVideoInfo, finfo) - 0usize];
    ["Offset of field: _GstVideoInfo::interlace_mode"]
        [::std::mem::offset_of!(_GstVideoInfo, interlace_mode) - 8usize];
    ["Offset of field: _GstVideoInfo::flags"]
        [::std::mem::offset_of!(_GstVideoInfo, flags) - 12usize];
    ["Offset of field: _GstVideoInfo::width"]
        [::std::mem::offset_of!(_GstVideoInfo, width) - 16usize];
    ["Offset of field: _GstVideoInfo::height"]
        [::std::mem::offset_of!(_GstVideoInfo, height) - 20usize];
    ["Offset of field: _GstVideoInfo::size"][::std::mem::offset_of!(_GstVideoInfo, size) - 24usize];
    ["Offset of field: _GstVideoInfo::views"]
        [::std::mem::offset_of!(_GstVideoInfo, views) - 32usize];
    ["Offset of field: _GstVideoInfo::chroma_site"]
        [::std::mem::offset_of!(_GstVideoInfo, chroma_site) - 36usize];
    ["Offset of field: _GstVideoInfo::colorimetry"]
        [::std::mem::offset_of!(_GstVideoInfo, colorimetry) - 40usize];
    ["Offset of field: _GstVideoInfo::par_n"]
        [::std::mem::offset_of!(_GstVideoInfo, par_n) - 56usize];
    ["Offset of field: _GstVideoInfo::par_d"]
        [::std::mem::offset_of!(_GstVideoInfo, par_d) - 60usize];
    ["Offset of field: _GstVideoInfo::fps_n"]
        [::std::mem::offset_of!(_GstVideoInfo, fps_n) - 64usize];
    ["Offset of field: _GstVideoInfo::fps_d"]
        [::std::mem::offset_of!(_GstVideoInfo, fps_d) - 68usize];
    ["Offset of field: _GstVideoInfo::offset"]
        [::std::mem::offset_of!(_GstVideoInfo, offset) - 72usize];
    ["Offset of field: _GstVideoInfo::stride"]
        [::std::mem::offset_of!(_GstVideoInfo, stride) - 104usize];
    ["Offset of field: _GstVideoInfo::ABI"][::std::mem::offset_of!(_GstVideoInfo, ABI) - 120usize];
};
unsafe extern "C" {
    pub fn gst_video_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_info_new() -> *mut GstVideoInfo;
}
unsafe extern "C" {
    pub fn gst_video_info_init(info: *mut GstVideoInfo);
}
unsafe extern "C" {
    pub fn gst_video_info_copy(info: *const GstVideoInfo) -> *mut GstVideoInfo;
}
unsafe extern "C" {
    pub fn gst_video_info_free(info: *mut GstVideoInfo);
}
unsafe extern "C" {
    pub fn gst_video_info_new_from_caps(caps: *const GstCaps) -> *mut GstVideoInfo;
}
unsafe extern "C" {
    pub fn gst_video_info_set_format(
        info: *mut GstVideoInfo,
        format: GstVideoFormat,
        width: guint,
        height: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_set_interlaced_format(
        info: *mut GstVideoInfo,
        format: GstVideoFormat,
        mode: GstVideoInterlaceMode,
        width: guint,
        height: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_from_caps(info: *mut GstVideoInfo, caps: *const GstCaps) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_to_caps(info: *const GstVideoInfo) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_video_info_convert(
        info: *const GstVideoInfo,
        src_format: GstFormat,
        src_value: gint64,
        dest_format: GstFormat,
        dest_value: *mut gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_is_equal(
        info: *const GstVideoInfo,
        other: *const GstVideoInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_align(info: *mut GstVideoInfo, align: *mut GstVideoAlignment)
    -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_info_align_full(
        info: *mut GstVideoInfo,
        align: *mut GstVideoAlignment,
        plane_size: *mut gsize,
    ) -> gboolean;
}
pub type GstVideoInfo_autoptr = *mut GstVideoInfo;
pub type GstVideoInfo_listautoptr = *mut GList;
pub type GstVideoInfo_slistautoptr = *mut GSList;
pub type GstVideoInfo_queueautoptr = *mut GQueue;
#[doc = " GstVideoFrame:\n @info: the #GstVideoInfo\n @flags: #GstVideoFrameFlags for the frame\n @buffer: the mapped buffer\n @meta: pointer to metadata if any\n @id: id of the mapped frame. the id can for example be used to\n   identify the frame in case of multiview video.\n @data: pointers to the plane data\n @map: mappings of the planes\n\n A video frame obtained from gst_video_frame_map()"]
pub type GstVideoFrame = _GstVideoFrame;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_NONE: GstVideoFrameFlags = 0;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_INTERLACED: GstVideoFrameFlags = 1;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_TFF: GstVideoFrameFlags = 2;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_RFF: GstVideoFrameFlags = 4;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_ONEFIELD: GstVideoFrameFlags = 8;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_MULTIPLE_VIEW: GstVideoFrameFlags = 16;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_FIRST_IN_BUNDLE: GstVideoFrameFlags = 32;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_TOP_FIELD: GstVideoFrameFlags = 10;
pub const GstVideoFrameFlags_GST_VIDEO_FRAME_FLAG_BOTTOM_FIELD: GstVideoFrameFlags = 8;
#[doc = " GstVideoFrameFlags:\n @GST_VIDEO_FRAME_FLAG_NONE: no flags\n @GST_VIDEO_FRAME_FLAG_INTERLACED: The video frame is interlaced. In mixed\n           interlace-mode, this flag specifies if the frame is interlaced or\n           progressive.\n @GST_VIDEO_FRAME_FLAG_TFF: The video frame has the top field first\n @GST_VIDEO_FRAME_FLAG_RFF: The video frame has the repeat flag\n @GST_VIDEO_FRAME_FLAG_ONEFIELD: The video frame has one field\n @GST_VIDEO_FRAME_FLAG_MULTIPLE_VIEW: The video contains one or\n     more non-mono views\n @GST_VIDEO_FRAME_FLAG_FIRST_IN_BUNDLE: The video frame is the first\n     in a set of corresponding views provided as sequential frames.\n @GST_VIDEO_FRAME_FLAG_TOP_FIELD: The video frame has the top field only. This\n     is the same as GST_VIDEO_FRAME_FLAG_TFF | GST_VIDEO_FRAME_FLAG_ONEFIELD\n     (Since: 1.16).\n @GST_VIDEO_FRAME_FLAG_BOTTOM_FIELD: The video frame has the bottom field\n     only. This is the same as GST_VIDEO_FRAME_FLAG_ONEFIELD\n     (GST_VIDEO_FRAME_FLAG_TFF flag unset) (Since: 1.16).\n\n Extra video frame flags"]
pub type GstVideoFrameFlags = ::std::os::raw::c_uint;
#[doc = " GstVideoFrame:\n @info: the #GstVideoInfo\n @flags: #GstVideoFrameFlags for the frame\n @buffer: the mapped buffer\n @meta: pointer to metadata if any\n @id: id of the mapped frame. the id can for example be used to\n   identify the frame in case of multiview video.\n @data: pointers to the plane data\n @map: mappings of the planes\n\n A video frame obtained from gst_video_frame_map()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoFrame {
    pub info: GstVideoInfo,
    pub flags: GstVideoFrameFlags,
    pub buffer: *mut GstBuffer,
    pub meta: gpointer,
    pub id: gint,
    pub data: [gpointer; 4usize],
    pub map: [GstMapInfo; 4usize],
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoFrame"][::std::mem::size_of::<_GstVideoFrame>() - 664usize];
    ["Alignment of _GstVideoFrame"][::std::mem::align_of::<_GstVideoFrame>() - 8usize];
    ["Offset of field: _GstVideoFrame::info"]
        [::std::mem::offset_of!(_GstVideoFrame, info) - 0usize];
    ["Offset of field: _GstVideoFrame::flags"]
        [::std::mem::offset_of!(_GstVideoFrame, flags) - 152usize];
    ["Offset of field: _GstVideoFrame::buffer"]
        [::std::mem::offset_of!(_GstVideoFrame, buffer) - 160usize];
    ["Offset of field: _GstVideoFrame::meta"]
        [::std::mem::offset_of!(_GstVideoFrame, meta) - 168usize];
    ["Offset of field: _GstVideoFrame::id"][::std::mem::offset_of!(_GstVideoFrame, id) - 176usize];
    ["Offset of field: _GstVideoFrame::data"]
        [::std::mem::offset_of!(_GstVideoFrame, data) - 184usize];
    ["Offset of field: _GstVideoFrame::map"]
        [::std::mem::offset_of!(_GstVideoFrame, map) - 216usize];
    ["Offset of field: _GstVideoFrame::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoFrame, _gst_reserved) - 632usize];
};
unsafe extern "C" {
    pub fn gst_video_frame_map(
        frame: *mut GstVideoFrame,
        info: *const GstVideoInfo,
        buffer: *mut GstBuffer,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_frame_map_id(
        frame: *mut GstVideoFrame,
        info: *const GstVideoInfo,
        buffer: *mut GstBuffer,
        id: gint,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_frame_unmap(frame: *mut GstVideoFrame);
}
unsafe extern "C" {
    pub fn gst_video_frame_copy(dest: *mut GstVideoFrame, src: *const GstVideoFrame) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_frame_copy_plane(
        dest: *mut GstVideoFrame,
        src: *const GstVideoFrame,
        plane: guint,
    ) -> gboolean;
}
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_INTERLACED: GstVideoBufferFlags = 1048576;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_TFF: GstVideoBufferFlags = 2097152;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_RFF: GstVideoBufferFlags = 4194304;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_ONEFIELD: GstVideoBufferFlags = 8388608;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW: GstVideoBufferFlags = 16777216;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_FIRST_IN_BUNDLE: GstVideoBufferFlags = 33554432;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_TOP_FIELD: GstVideoBufferFlags = 10485760;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_BOTTOM_FIELD: GstVideoBufferFlags = 8388608;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_MARKER: GstVideoBufferFlags = 512;
pub const GstVideoBufferFlags_GST_VIDEO_BUFFER_FLAG_LAST: GstVideoBufferFlags = 268435456;
#[doc = " GstVideoBufferFlags:\n @GST_VIDEO_BUFFER_FLAG_INTERLACED:  If the #GstBuffer is interlaced. In mixed\n                                     interlace-mode, this flags specifies if the frame is\n                                     interlaced or progressive.\n @GST_VIDEO_BUFFER_FLAG_TFF:         If the #GstBuffer is interlaced, then the first field\n                                     in the video frame is the top field.  If unset, the\n                                     bottom field is first.\n @GST_VIDEO_BUFFER_FLAG_RFF:         If the #GstBuffer is interlaced, then the first field\n                                     (as defined by the %GST_VIDEO_BUFFER_FLAG_TFF flag setting)\n                                     is repeated.\n @GST_VIDEO_BUFFER_FLAG_ONEFIELD:    If the #GstBuffer is interlaced, then only the\n                                     first field (as defined by the %GST_VIDEO_BUFFER_FLAG_TFF\n                                     flag setting) is to be displayed (Since: 1.16).\n @GST_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW: The #GstBuffer contains one or more specific views,\n                                     such as left or right eye view. This flags is set on\n                                     any buffer that contains non-mono content - even for\n                                     streams that contain only a single viewpoint. In mixed\n                                     mono / non-mono streams, the absence of the flag marks\n                                     mono buffers.\n @GST_VIDEO_BUFFER_FLAG_FIRST_IN_BUNDLE: When conveying stereo/multiview content with\n                                     frame-by-frame methods, this flag marks the first buffer\n                                      in a bundle of frames that belong together.\n @GST_VIDEO_BUFFER_FLAG_TOP_FIELD:   The video frame has the top field only. This is the\n                                     same as GST_VIDEO_BUFFER_FLAG_TFF |\n                                     GST_VIDEO_BUFFER_FLAG_ONEFIELD (Since: 1.16).\n                                     Use GST_VIDEO_BUFFER_IS_TOP_FIELD() to check for this flag.\n @GST_VIDEO_BUFFER_FLAG_BOTTOM_FIELD: The video frame has the bottom field only. This is\n                                     the same as GST_VIDEO_BUFFER_FLAG_ONEFIELD\n                                     (GST_VIDEO_BUFFER_FLAG_TFF flag unset) (Since: 1.16).\n                                     Use GST_VIDEO_BUFFER_IS_BOTTOM_FIELD() to check for this flag.\n @GST_VIDEO_BUFFER_FLAG_MARKER:      The #GstBuffer contains the end of a video field or frame\n                                     boundary such as the last subframe or packet (Since: 1.18).\n @GST_VIDEO_BUFFER_FLAG_LAST:        Offset to define more flags\n\n Additional video buffer flags. These flags can potentially be used on any\n buffers carrying closed caption data, or video data - even encoded data.\n\n Note that these are only valid for #GstCaps of type: video/... and caption/...\n They can conflict with other extended buffer flags."]
pub type GstVideoBufferFlags = ::std::os::raw::c_uint;
pub const GstVideoFrameMapFlags_GST_VIDEO_FRAME_MAP_FLAG_NO_REF: GstVideoFrameMapFlags = 65536;
pub const GstVideoFrameMapFlags_GST_VIDEO_FRAME_MAP_FLAG_LAST: GstVideoFrameMapFlags = 16777216;
#[doc = " GstVideoFrameMapFlags:\n @GST_VIDEO_FRAME_MAP_FLAG_NO_REF:  Don't take another reference of the buffer and store it in\n                                    the GstVideoFrame. This makes sure that the buffer stays\n                                    writable while the frame is mapped, but requires that the\n                                    buffer reference stays valid until the frame is unmapped again.\n @GST_VIDEO_FRAME_MAP_FLAG_LAST:    Offset to define more flags\n\n Additional mapping flags for gst_video_frame_map().\n\n Since: 1.6"]
pub type GstVideoFrameMapFlags = ::std::os::raw::c_uint;
pub const GstVideoAlphaMode_GST_VIDEO_ALPHA_MODE_COPY: GstVideoAlphaMode = 0;
pub const GstVideoAlphaMode_GST_VIDEO_ALPHA_MODE_SET: GstVideoAlphaMode = 1;
pub const GstVideoAlphaMode_GST_VIDEO_ALPHA_MODE_MULT: GstVideoAlphaMode = 2;
#[doc = " GstVideoAlphaMode:\n @GST_VIDEO_ALPHA_MODE_COPY: When input and output have alpha, it will be copied.\n         When the input has no alpha, alpha will be set to\n         #GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE\n @GST_VIDEO_ALPHA_MODE_SET: set all alpha to\n\t   #GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE\n @GST_VIDEO_ALPHA_MODE_MULT:  multiply all alpha with\n         #GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE.\n         When the input format has no alpha but the output format has, the\n         alpha value will be set to #GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE\n\n Different alpha modes.\n\n Since: 1.6"]
pub type GstVideoAlphaMode = ::std::os::raw::c_uint;
pub const GstVideoChromaMode_GST_VIDEO_CHROMA_MODE_FULL: GstVideoChromaMode = 0;
pub const GstVideoChromaMode_GST_VIDEO_CHROMA_MODE_UPSAMPLE_ONLY: GstVideoChromaMode = 1;
pub const GstVideoChromaMode_GST_VIDEO_CHROMA_MODE_DOWNSAMPLE_ONLY: GstVideoChromaMode = 2;
pub const GstVideoChromaMode_GST_VIDEO_CHROMA_MODE_NONE: GstVideoChromaMode = 3;
#[doc = " GstVideoChromaMode:\n @GST_VIDEO_CHROMA_MODE_FULL: do full chroma up and down sampling\n @GST_VIDEO_CHROMA_MODE_UPSAMPLE_ONLY: only perform chroma upsampling\n @GST_VIDEO_CHROMA_MODE_DOWNSAMPLE_ONLY: only perform chroma downsampling\n @GST_VIDEO_CHROMA_MODE_NONE: disable chroma resampling\n\n Different chroma downsampling and upsampling modes\n\n Since: 1.6"]
pub type GstVideoChromaMode = ::std::os::raw::c_uint;
pub const GstVideoMatrixMode_GST_VIDEO_MATRIX_MODE_FULL: GstVideoMatrixMode = 0;
pub const GstVideoMatrixMode_GST_VIDEO_MATRIX_MODE_INPUT_ONLY: GstVideoMatrixMode = 1;
pub const GstVideoMatrixMode_GST_VIDEO_MATRIX_MODE_OUTPUT_ONLY: GstVideoMatrixMode = 2;
pub const GstVideoMatrixMode_GST_VIDEO_MATRIX_MODE_NONE: GstVideoMatrixMode = 3;
#[doc = "GstVideoMatrixMode:\n @GST_VIDEO_MATRIX_MODE_FULL: do conversion between color matrices\n @GST_VIDEO_MATRIX_MODE_INPUT_ONLY:  use the input color matrix to convert\n\t  to and from R'G'B\n @GST_VIDEO_MATRIX_MODE_OUTPUT_ONLY: use the output color matrix to convert\n\t  to and from R'G'B\n @GST_VIDEO_MATRIX_MODE_NONE: disable color matrix conversion.\n\n Different color matrix conversion modes\n\n Since: 1.6"]
pub type GstVideoMatrixMode = ::std::os::raw::c_uint;
pub const GstVideoGammaMode_GST_VIDEO_GAMMA_MODE_NONE: GstVideoGammaMode = 0;
pub const GstVideoGammaMode_GST_VIDEO_GAMMA_MODE_REMAP: GstVideoGammaMode = 1;
#[doc = " GstVideoGammaMode:\n @GST_VIDEO_GAMMA_MODE_NONE: disable gamma handling\n @GST_VIDEO_GAMMA_MODE_REMAP: convert between input and output gamma\n Different gamma conversion modes\n\n Since: 1.6"]
pub type GstVideoGammaMode = ::std::os::raw::c_uint;
pub const GstVideoPrimariesMode_GST_VIDEO_PRIMARIES_MODE_NONE: GstVideoPrimariesMode = 0;
pub const GstVideoPrimariesMode_GST_VIDEO_PRIMARIES_MODE_MERGE_ONLY: GstVideoPrimariesMode = 1;
pub const GstVideoPrimariesMode_GST_VIDEO_PRIMARIES_MODE_FAST: GstVideoPrimariesMode = 2;
#[doc = " GstVideoPrimariesMode:\n @GST_VIDEO_PRIMARIES_MODE_NONE: disable conversion between primaries\n @GST_VIDEO_PRIMARIES_MODE_MERGE_ONLY: do conversion between primaries only\n\t  when it can be merged with color matrix conversion.\n @GST_VIDEO_PRIMARIES_MODE_FAST: fast conversion between primaries\n\n Different primaries conversion modes\n\n Since: 1.6"]
pub type GstVideoPrimariesMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoConverter {
    _unused: [u8; 0],
}
pub type GstVideoConverter = _GstVideoConverter;
unsafe extern "C" {
    pub fn gst_video_converter_new(
        in_info: *const GstVideoInfo,
        out_info: *const GstVideoInfo,
        config: *mut GstStructure,
    ) -> *mut GstVideoConverter;
}
unsafe extern "C" {
    pub fn gst_video_converter_new_with_pool(
        in_info: *const GstVideoInfo,
        out_info: *const GstVideoInfo,
        config: *mut GstStructure,
        pool: *mut GstTaskPool,
    ) -> *mut GstVideoConverter;
}
unsafe extern "C" {
    pub fn gst_video_converter_free(convert: *mut GstVideoConverter);
}
unsafe extern "C" {
    pub fn gst_video_converter_set_config(
        convert: *mut GstVideoConverter,
        config: *mut GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_converter_get_config(convert: *mut GstVideoConverter) -> *const GstStructure;
}
unsafe extern "C" {
    pub fn gst_video_converter_frame(
        convert: *mut GstVideoConverter,
        src: *const GstVideoFrame,
        dest: *mut GstVideoFrame,
    );
}
unsafe extern "C" {
    pub fn gst_video_converter_frame_finish(convert: *mut GstVideoConverter);
}
#[doc = " GstVideoResampler:\n @in_size: the input size\n @out_size: the output size\n @max_taps: the maximum number of taps\n @n_phases: the number of phases\n @offset: array with the source offset for each output element\n @phase: array with the phase to use for each output element\n @n_taps: array with new number of taps for each phase\n @taps: the taps for all phases\n\n A structure holding resampler information.\n\n Since: 1.6"]
pub type GstVideoResampler = _GstVideoResampler;
pub const GstVideoResamplerMethod_GST_VIDEO_RESAMPLER_METHOD_NEAREST: GstVideoResamplerMethod = 0;
pub const GstVideoResamplerMethod_GST_VIDEO_RESAMPLER_METHOD_LINEAR: GstVideoResamplerMethod = 1;
pub const GstVideoResamplerMethod_GST_VIDEO_RESAMPLER_METHOD_CUBIC: GstVideoResamplerMethod = 2;
pub const GstVideoResamplerMethod_GST_VIDEO_RESAMPLER_METHOD_SINC: GstVideoResamplerMethod = 3;
pub const GstVideoResamplerMethod_GST_VIDEO_RESAMPLER_METHOD_LANCZOS: GstVideoResamplerMethod = 4;
#[doc = " GstVideoResamplerMethod:\n @GST_VIDEO_RESAMPLER_METHOD_NEAREST: Duplicates the samples when\n    upsampling and drops when downsampling\n @GST_VIDEO_RESAMPLER_METHOD_LINEAR: Uses linear interpolation to reconstruct\n    missing samples and averaging to downsample\n @GST_VIDEO_RESAMPLER_METHOD_CUBIC: Uses cubic interpolation\n @GST_VIDEO_RESAMPLER_METHOD_SINC: Uses sinc interpolation\n @GST_VIDEO_RESAMPLER_METHOD_LANCZOS: Uses lanczos interpolation\n\n Different subsampling and upsampling methods\n\n Since: 1.6"]
pub type GstVideoResamplerMethod = ::std::os::raw::c_uint;
pub const GstVideoResamplerFlags_GST_VIDEO_RESAMPLER_FLAG_NONE: GstVideoResamplerFlags = 0;
pub const GstVideoResamplerFlags_GST_VIDEO_RESAMPLER_FLAG_HALF_TAPS: GstVideoResamplerFlags = 1;
#[doc = " GstVideoResamplerFlags:\n @GST_VIDEO_RESAMPLER_FLAG_NONE: no flags\n @GST_VIDEO_RESAMPLER_FLAG_HALF_TAPS: when no taps are given, half the\n              number of calculated taps. This can be used when making scalers\n              for the different fields of an interlaced picture. Since: 1.10\n\n Different resampler flags.\n\n Since: 1.6"]
pub type GstVideoResamplerFlags = ::std::os::raw::c_uint;
#[doc = " GstVideoResampler:\n @in_size: the input size\n @out_size: the output size\n @max_taps: the maximum number of taps\n @n_phases: the number of phases\n @offset: array with the source offset for each output element\n @phase: array with the phase to use for each output element\n @n_taps: array with new number of taps for each phase\n @taps: the taps for all phases\n\n A structure holding resampler information.\n\n Since: 1.6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoResampler {
    pub in_size: gint,
    pub out_size: gint,
    pub max_taps: guint,
    pub n_phases: guint,
    pub offset: *mut guint32,
    pub phase: *mut guint32,
    pub n_taps: *mut guint32,
    pub taps: *mut gdouble,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoResampler"][::std::mem::size_of::<_GstVideoResampler>() - 80usize];
    ["Alignment of _GstVideoResampler"][::std::mem::align_of::<_GstVideoResampler>() - 8usize];
    ["Offset of field: _GstVideoResampler::in_size"]
        [::std::mem::offset_of!(_GstVideoResampler, in_size) - 0usize];
    ["Offset of field: _GstVideoResampler::out_size"]
        [::std::mem::offset_of!(_GstVideoResampler, out_size) - 4usize];
    ["Offset of field: _GstVideoResampler::max_taps"]
        [::std::mem::offset_of!(_GstVideoResampler, max_taps) - 8usize];
    ["Offset of field: _GstVideoResampler::n_phases"]
        [::std::mem::offset_of!(_GstVideoResampler, n_phases) - 12usize];
    ["Offset of field: _GstVideoResampler::offset"]
        [::std::mem::offset_of!(_GstVideoResampler, offset) - 16usize];
    ["Offset of field: _GstVideoResampler::phase"]
        [::std::mem::offset_of!(_GstVideoResampler, phase) - 24usize];
    ["Offset of field: _GstVideoResampler::n_taps"]
        [::std::mem::offset_of!(_GstVideoResampler, n_taps) - 32usize];
    ["Offset of field: _GstVideoResampler::taps"]
        [::std::mem::offset_of!(_GstVideoResampler, taps) - 40usize];
    ["Offset of field: _GstVideoResampler::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoResampler, _gst_reserved) - 48usize];
};
unsafe extern "C" {
    pub fn gst_video_resampler_init(
        resampler: *mut GstVideoResampler,
        method: GstVideoResamplerMethod,
        flags: GstVideoResamplerFlags,
        n_phases: guint,
        n_taps: guint,
        shift: gdouble,
        in_size: guint,
        out_size: guint,
        options: *mut GstStructure,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_resampler_clear(resampler: *mut GstVideoResampler);
}
pub const GstVideoScalerFlags_GST_VIDEO_SCALER_FLAG_NONE: GstVideoScalerFlags = 0;
pub const GstVideoScalerFlags_GST_VIDEO_SCALER_FLAG_INTERLACED: GstVideoScalerFlags = 1;
#[doc = " GstVideoScalerFlags:\n @GST_VIDEO_SCALER_FLAG_NONE: no flags\n @GST_VIDEO_SCALER_FLAG_INTERLACED: Set up a scaler for interlaced content\n\n Different scale flags."]
pub type GstVideoScalerFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoScaler {
    _unused: [u8; 0],
}
pub type GstVideoScaler = _GstVideoScaler;
unsafe extern "C" {
    pub fn gst_video_scaler_new(
        method: GstVideoResamplerMethod,
        flags: GstVideoScalerFlags,
        n_taps: guint,
        in_size: guint,
        out_size: guint,
        options: *mut GstStructure,
    ) -> *mut GstVideoScaler;
}
unsafe extern "C" {
    pub fn gst_video_scaler_free(scale: *mut GstVideoScaler);
}
unsafe extern "C" {
    pub fn gst_video_scaler_get_max_taps(scale: *mut GstVideoScaler) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_scaler_get_coeff(
        scale: *mut GstVideoScaler,
        out_offset: guint,
        in_offset: *mut guint,
        n_taps: *mut guint,
    ) -> *const gdouble;
}
unsafe extern "C" {
    pub fn gst_video_scaler_horizontal(
        scale: *mut GstVideoScaler,
        format: GstVideoFormat,
        src: gpointer,
        dest: gpointer,
        dest_offset: guint,
        width: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_scaler_vertical(
        scale: *mut GstVideoScaler,
        format: GstVideoFormat,
        src_lines: *mut gpointer,
        dest: gpointer,
        dest_offset: guint,
        width: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_scaler_combine_packed_YUV(
        y_scale: *mut GstVideoScaler,
        uv_scale: *mut GstVideoScaler,
        in_format: GstVideoFormat,
        out_format: GstVideoFormat,
    ) -> *mut GstVideoScaler;
}
unsafe extern "C" {
    pub fn gst_video_scaler_2d(
        hscale: *mut GstVideoScaler,
        vscale: *mut GstVideoScaler,
        format: GstVideoFormat,
        src: gpointer,
        src_stride: gint,
        dest: gpointer,
        dest_stride: gint,
        x: guint,
        y: guint,
        width: guint,
        height: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_multiview_flagset_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_multiview_mode_to_caps_string(
        mview_mode: GstVideoMultiviewMode,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn gst_video_multiview_mode_from_caps_string(
        caps_mview_mode: *const gchar,
    ) -> GstVideoMultiviewMode;
}
unsafe extern "C" {
    pub fn gst_video_multiview_get_mono_modes() -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_video_multiview_get_unpacked_modes() -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_video_multiview_get_doubled_height_modes() -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_video_multiview_get_doubled_width_modes() -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_video_multiview_get_doubled_size_modes() -> *const GValue;
}
unsafe extern "C" {
    pub fn gst_video_multiview_video_info_change_mode(
        info: *mut GstVideoInfo,
        out_mview_mode: GstVideoMultiviewMode,
        out_mview_flags: GstVideoMultiviewFlags,
    );
}
unsafe extern "C" {
    pub fn gst_video_multiview_guess_half_aspect(
        mv_mode: GstVideoMultiviewMode,
        width: guint,
        height: guint,
        par_n: guint,
        par_d: guint,
    ) -> gboolean;
}
#[doc = " GstVideoAlignment:\n @padding_left: extra pixels on the left side\n @padding_right: extra pixels on the right side\n @padding_top: extra pixels on the top\n @padding_bottom: extra pixels on the bottom\n @stride_align: array with extra alignment requirements for the strides\n\n Extra alignment parameters for the memory of video buffers. This\n structure is usually used to configure the bufferpool if it supports the\n #GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAlignment {
    pub padding_top: guint,
    pub padding_bottom: guint,
    pub padding_left: guint,
    pub padding_right: guint,
    pub stride_align: [guint; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAlignment"][::std::mem::size_of::<_GstVideoAlignment>() - 32usize];
    ["Alignment of _GstVideoAlignment"][::std::mem::align_of::<_GstVideoAlignment>() - 4usize];
    ["Offset of field: _GstVideoAlignment::padding_top"]
        [::std::mem::offset_of!(_GstVideoAlignment, padding_top) - 0usize];
    ["Offset of field: _GstVideoAlignment::padding_bottom"]
        [::std::mem::offset_of!(_GstVideoAlignment, padding_bottom) - 4usize];
    ["Offset of field: _GstVideoAlignment::padding_left"]
        [::std::mem::offset_of!(_GstVideoAlignment, padding_left) - 8usize];
    ["Offset of field: _GstVideoAlignment::padding_right"]
        [::std::mem::offset_of!(_GstVideoAlignment, padding_right) - 12usize];
    ["Offset of field: _GstVideoAlignment::stride_align"]
        [::std::mem::offset_of!(_GstVideoAlignment, stride_align) - 16usize];
};
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_IDENTITY: GstVideoOrientationMethod = 0;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_90R: GstVideoOrientationMethod = 1;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_180: GstVideoOrientationMethod = 2;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_90L: GstVideoOrientationMethod = 3;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_HORIZ: GstVideoOrientationMethod = 4;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_VERT: GstVideoOrientationMethod = 5;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_UL_LR: GstVideoOrientationMethod = 6;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_UR_LL: GstVideoOrientationMethod = 7;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_AUTO: GstVideoOrientationMethod = 8;
pub const GstVideoOrientationMethod_GST_VIDEO_ORIENTATION_CUSTOM: GstVideoOrientationMethod = 9;
#[doc = " GstVideoOrientationMethod:\n @GST_VIDEO_ORIENTATION_IDENTITY: Identity (no rotation)\n @GST_VIDEO_ORIENTATION_90R: Rotate clockwise 90 degrees\n @GST_VIDEO_ORIENTATION_180: Rotate 180 degrees\n @GST_VIDEO_ORIENTATION_90L: Rotate counter-clockwise 90 degrees\n @GST_VIDEO_ORIENTATION_HORIZ: Flip horizontally\n @GST_VIDEO_ORIENTATION_VERT: Flip vertically\n @GST_VIDEO_ORIENTATION_UL_LR: Flip across upper left/lower right diagonal\n @GST_VIDEO_ORIENTATION_UR_LL: Flip across upper right/lower left diagonal\n @GST_VIDEO_ORIENTATION_AUTO: Select flip method based on image-orientation tag\n @GST_VIDEO_ORIENTATION_CUSTOM: Current status depends on plugin internal setup\n\n The different video orientation methods.\n\n Since: 1.10"]
pub type GstVideoOrientationMethod = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_alignment_reset(align: *mut GstVideoAlignment);
}
unsafe extern "C" {
    pub fn gst_video_calculate_display_ratio(
        dar_n: *mut guint,
        dar_d: *mut guint,
        video_width: guint,
        video_height: guint,
        video_par_n: guint,
        video_par_d: guint,
        display_par_n: guint,
        display_par_d: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_guess_framerate(
        duration: GstClockTime,
        dest_n: *mut gint,
        dest_d: *mut gint,
    ) -> gboolean;
}
pub type GstVideoConvertSampleCallback = ::std::option::Option<
    unsafe extern "C" fn(sample: *mut GstSample, error: *mut GError, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn gst_video_convert_sample_async(
        sample: *mut GstSample,
        to_caps: *const GstCaps,
        timeout: GstClockTime,
        callback: GstVideoConvertSampleCallback,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_video_convert_sample(
        sample: *mut GstSample,
        to_caps: *const GstCaps,
        timeout: GstClockTime,
        error: *mut *mut GError,
    ) -> *mut GstSample;
}
unsafe extern "C" {
    pub fn gst_video_orientation_from_tag(
        taglist: *mut GstTagList,
        method: *mut GstVideoOrientationMethod,
    ) -> gboolean;
}
#[doc = " GstColorBalanceChannel:\n @label: A string containing a descriptive name for this channel\n @min_value: The minimum valid value for this channel.\n @max_value: The maximum valid value for this channel."]
pub type GstColorBalanceChannel = _GstColorBalanceChannel;
#[doc = " GstColorBalanceChannelClass:\n @parent: the parent class\n @value_changed: default handler for value changed notification\n\n Color-balance channel class."]
pub type GstColorBalanceChannelClass = _GstColorBalanceChannelClass;
#[doc = " GstColorBalanceChannel:\n @label: A string containing a descriptive name for this channel\n @min_value: The minimum valid value for this channel.\n @max_value: The maximum valid value for this channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstColorBalanceChannel {
    pub parent: GObject,
    pub label: *mut gchar,
    pub min_value: gint,
    pub max_value: gint,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstColorBalanceChannel"][::std::mem::size_of::<_GstColorBalanceChannel>() - 72usize];
    ["Alignment of _GstColorBalanceChannel"]
        [::std::mem::align_of::<_GstColorBalanceChannel>() - 8usize];
    ["Offset of field: _GstColorBalanceChannel::parent"]
        [::std::mem::offset_of!(_GstColorBalanceChannel, parent) - 0usize];
    ["Offset of field: _GstColorBalanceChannel::label"]
        [::std::mem::offset_of!(_GstColorBalanceChannel, label) - 24usize];
    ["Offset of field: _GstColorBalanceChannel::min_value"]
        [::std::mem::offset_of!(_GstColorBalanceChannel, min_value) - 32usize];
    ["Offset of field: _GstColorBalanceChannel::max_value"]
        [::std::mem::offset_of!(_GstColorBalanceChannel, max_value) - 36usize];
    ["Offset of field: _GstColorBalanceChannel::_gst_reserved"]
        [::std::mem::offset_of!(_GstColorBalanceChannel, _gst_reserved) - 40usize];
};
#[doc = " GstColorBalanceChannelClass:\n @parent: the parent class\n @value_changed: default handler for value changed notification\n\n Color-balance channel class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstColorBalanceChannelClass {
    pub parent: GObjectClass,
    pub value_changed: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GstColorBalanceChannel, value: gint),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstColorBalanceChannelClass"]
        [::std::mem::size_of::<_GstColorBalanceChannelClass>() - 176usize];
    ["Alignment of _GstColorBalanceChannelClass"]
        [::std::mem::align_of::<_GstColorBalanceChannelClass>() - 8usize];
    ["Offset of field: _GstColorBalanceChannelClass::parent"]
        [::std::mem::offset_of!(_GstColorBalanceChannelClass, parent) - 0usize];
    ["Offset of field: _GstColorBalanceChannelClass::value_changed"]
        [::std::mem::offset_of!(_GstColorBalanceChannelClass, value_changed) - 136usize];
    ["Offset of field: _GstColorBalanceChannelClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstColorBalanceChannelClass, _gst_reserved) - 144usize];
};
unsafe extern "C" {
    pub fn gst_color_balance_channel_get_type() -> GType;
}
pub type GstColorBalanceChannel_autoptr = *mut GstColorBalanceChannel;
pub type GstColorBalanceChannel_listautoptr = *mut GList;
pub type GstColorBalanceChannel_slistautoptr = *mut GSList;
pub type GstColorBalanceChannel_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstColorBalance {
    _unused: [u8; 0],
}
pub type GstColorBalance = _GstColorBalance;
#[doc = " GstColorBalanceInterface:\n @iface: the parent interface\n @get_balance_type: implementation type\n @list_channels: list handled channels\n @set_value: set a channel value\n @get_value: get a channel value\n @value_changed: default handler for value changed notification\n\n Color-balance interface."]
pub type GstColorBalanceInterface = _GstColorBalanceInterface;
pub const GstColorBalanceType_GST_COLOR_BALANCE_HARDWARE: GstColorBalanceType = 0;
pub const GstColorBalanceType_GST_COLOR_BALANCE_SOFTWARE: GstColorBalanceType = 1;
#[doc = " GstColorBalanceType:\n @GST_COLOR_BALANCE_HARDWARE: Color balance is implemented with dedicated\n         hardware.\n @GST_COLOR_BALANCE_SOFTWARE: Color balance is implemented via software\n         processing.\n\n An enumeration indicating whether an element implements color balancing\n operations in software or in dedicated hardware. In general, dedicated\n hardware implementations (such as those provided by xvimagesink) are\n preferred."]
pub type GstColorBalanceType = ::std::os::raw::c_uint;
#[doc = " GstColorBalanceInterface:\n @iface: the parent interface\n @get_balance_type: implementation type\n @list_channels: list handled channels\n @set_value: set a channel value\n @get_value: get a channel value\n @value_changed: default handler for value changed notification\n\n Color-balance interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstColorBalanceInterface {
    pub iface: GTypeInterface,
    pub list_channels:
        ::std::option::Option<unsafe extern "C" fn(balance: *mut GstColorBalance) -> *const GList>,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            balance: *mut GstColorBalance,
            channel: *mut GstColorBalanceChannel,
            value: gint,
        ),
    >,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            balance: *mut GstColorBalance,
            channel: *mut GstColorBalanceChannel,
        ) -> gint,
    >,
    pub get_balance_type: ::std::option::Option<
        unsafe extern "C" fn(balance: *mut GstColorBalance) -> GstColorBalanceType,
    >,
    pub value_changed: ::std::option::Option<
        unsafe extern "C" fn(
            balance: *mut GstColorBalance,
            channel: *mut GstColorBalanceChannel,
            value: gint,
        ),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstColorBalanceInterface"]
        [::std::mem::size_of::<_GstColorBalanceInterface>() - 88usize];
    ["Alignment of _GstColorBalanceInterface"]
        [::std::mem::align_of::<_GstColorBalanceInterface>() - 8usize];
    ["Offset of field: _GstColorBalanceInterface::iface"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, iface) - 0usize];
    ["Offset of field: _GstColorBalanceInterface::list_channels"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, list_channels) - 16usize];
    ["Offset of field: _GstColorBalanceInterface::set_value"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, set_value) - 24usize];
    ["Offset of field: _GstColorBalanceInterface::get_value"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, get_value) - 32usize];
    ["Offset of field: _GstColorBalanceInterface::get_balance_type"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, get_balance_type) - 40usize];
    ["Offset of field: _GstColorBalanceInterface::value_changed"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, value_changed) - 48usize];
    ["Offset of field: _GstColorBalanceInterface::_gst_reserved"]
        [::std::mem::offset_of!(_GstColorBalanceInterface, _gst_reserved) - 56usize];
};
unsafe extern "C" {
    pub fn gst_color_balance_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_color_balance_list_channels(balance: *mut GstColorBalance) -> *const GList;
}
unsafe extern "C" {
    pub fn gst_color_balance_set_value(
        balance: *mut GstColorBalance,
        channel: *mut GstColorBalanceChannel,
        value: gint,
    );
}
unsafe extern "C" {
    pub fn gst_color_balance_get_value(
        balance: *mut GstColorBalance,
        channel: *mut GstColorBalanceChannel,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_color_balance_get_balance_type(balance: *mut GstColorBalance)
    -> GstColorBalanceType;
}
unsafe extern "C" {
    pub fn gst_color_balance_value_changed(
        balance: *mut GstColorBalance,
        channel: *mut GstColorBalanceChannel,
        value: gint,
    );
}
#[doc = " GstVideoAffineTransformationMeta:\n @meta: parent #GstMeta\n @matrix: the column-major 4x4 transformation matrix\n\n Extra buffer metadata for performing an affine transformation using a 4x4\n matrix. The transformation matrix can be composed with\n gst_video_affine_transformation_meta_apply_matrix().\n\n The vertices operated on are all in the range 0 to 1, not in\n Normalized Device Coordinates (-1 to +1). Transforming points in this space\n are assumed to have an origin at (0.5, 0.5, 0.5) in a left-handed coordinate\n system with the x-axis moving horizontally (positive values to the right),\n the y-axis moving vertically (positive values up the screen) and the z-axis\n perpendicular to the screen (positive values into the screen).\n\n Since: 1.8"]
pub type GstVideoAffineTransformationMeta = _GstVideoAffineTransformationMeta;
pub type GstVideoAffineTransformationGetMatrix = ::std::option::Option<
    unsafe extern "C" fn(
        meta: *mut GstVideoAffineTransformationMeta,
        matrix: *mut gfloat,
    ) -> gboolean,
>;
#[doc = " GstVideoAffineTransformationMeta:\n @meta: parent #GstMeta\n @matrix: the column-major 4x4 transformation matrix\n\n Extra buffer metadata for performing an affine transformation using a 4x4\n matrix. The transformation matrix can be composed with\n gst_video_affine_transformation_meta_apply_matrix().\n\n The vertices operated on are all in the range 0 to 1, not in\n Normalized Device Coordinates (-1 to +1). Transforming points in this space\n are assumed to have an origin at (0.5, 0.5, 0.5) in a left-handed coordinate\n system with the x-axis moving horizontally (positive values to the right),\n the y-axis moving vertically (positive values up the screen) and the z-axis\n perpendicular to the screen (positive values into the screen).\n\n Since: 1.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAffineTransformationMeta {
    pub meta: GstMeta,
    pub matrix: [gfloat; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAffineTransformationMeta"]
        [::std::mem::size_of::<_GstVideoAffineTransformationMeta>() - 80usize];
    ["Alignment of _GstVideoAffineTransformationMeta"]
        [::std::mem::align_of::<_GstVideoAffineTransformationMeta>() - 8usize];
    ["Offset of field: _GstVideoAffineTransformationMeta::meta"]
        [::std::mem::offset_of!(_GstVideoAffineTransformationMeta, meta) - 0usize];
    ["Offset of field: _GstVideoAffineTransformationMeta::matrix"]
        [::std::mem::offset_of!(_GstVideoAffineTransformationMeta, matrix) - 16usize];
};
unsafe extern "C" {
    pub fn gst_video_affine_transformation_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_affine_transformation_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_affine_transformation_meta(
        buffer: *mut GstBuffer,
    ) -> *mut GstVideoAffineTransformationMeta;
}
unsafe extern "C" {
    pub fn gst_video_affine_transformation_meta_apply_matrix(
        meta: *mut GstVideoAffineTransformationMeta,
        matrix: *const gfloat,
    );
}
#[doc = " GstAggregator Structs  *"]
pub type GstAggregator = _GstAggregator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAggregatorPrivate {
    _unused: [u8; 0],
}
pub type GstAggregatorPrivate = _GstAggregatorPrivate;
#[doc = " GstAggregatorClass:\n @flush:          Optional.\n                  Called after a successful flushing seek, once all the flush\n                  stops have been received. Flush pad-specific data in\n                  #GstAggregatorPad->flush.\n @clip:           Optional.\n                  Called when a buffer is received on a sink pad, the task of\n                  clipping it and translating it to the current segment falls\n                  on the subclass. The function should use the segment of data\n                  and the negotiated media type on the pad to perform\n                  clipping of input buffer. This function takes ownership of\n                  buf and should output a buffer or return NULL in\n                  if the buffer should be dropped.\n @finish_buffer:  Optional.\n                  Called when a subclass calls gst_aggregator_finish_buffer()\n                  from their aggregate function to push out a buffer.\n                  Subclasses can override this to modify or decorate buffers\n                  before they get pushed out. This function takes ownership\n                  of the buffer passed. Subclasses that override this method\n                  should always chain up to the parent class virtual method.\n @sink_event:     Optional.\n                  Called when an event is received on a sink pad, the subclass\n                  should always chain up.\n @sink_query:     Optional.\n                  Called when a query is received on a sink pad, the subclass\n                  should always chain up.\n @src_event:      Optional.\n                  Called when an event is received on the src pad, the subclass\n                  should always chain up.\n @src_query:      Optional.\n                  Called when a query is received on the src pad, the subclass\n                  should always chain up.\n @src_activate:   Optional.\n                  Called when the src pad is activated, it will start/stop its\n                  pad task right after that call.\n @aggregate:      Mandatory.\n                  Called when buffers are queued on all sinkpads. Classes\n                  should iterate the GstElement->sinkpads and peek or steal\n                  buffers from the #GstAggregatorPads. If the subclass returns\n                  GST_FLOW_EOS, sending of the eos event will be taken care\n                  of. Once / if a buffer has been constructed from the\n                  aggregated buffers, the subclass should call _finish_buffer.\n @stop:           Optional.\n                  Called when the element goes from PAUSED to READY.\n                  The subclass should free all resources and reset its state.\n @start:          Optional.\n                  Called when the element goes from READY to PAUSED.\n                  The subclass should get ready to process\n                  aggregated buffers.\n @get_next_time:  Optional.\n                  Called when the element needs to know the running time of the next\n                  rendered buffer for live pipelines. This causes deadline\n                  based aggregation to occur. Defaults to returning\n                  GST_CLOCK_TIME_NONE causing the element to wait for buffers\n                  on all sink pads before aggregating.\n @create_new_pad: Optional.\n                  Called when a new pad needs to be created. Allows subclass that\n                  don't have a single sink pad template to provide a pad based\n                  on the provided information.\n @update_src_caps: Lets subclasses update the #GstCaps representing\n                   the src pad caps before usage.  The result should end up\n                   in @ret. Return %GST_AGGREGATOR_FLOW_NEED_DATA to indicate that the\n                   element needs more information (caps, a buffer, etc) to\n                   choose the correct caps. Should return ANY caps if the\n                   stream has not caps at all.\n @fixate_src_caps: Optional.\n                   Fixate and return the src pad caps provided.  The function takes\n                   ownership of @caps and returns a fixated version of\n                   @caps. @caps is not guaranteed to be writable.\n @negotiated_src_caps: Optional.\n                       Notifies subclasses what caps format has been negotiated\n @decide_allocation: Optional.\n                     Allows the subclass to influence the allocation choices.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n @propose_allocation: Optional.\n                     Allows the subclass to handle the allocation query from upstream.\n @negotiate: Optional.\n             Negotiate the caps with the peer (Since: 1.18).\n @sink_event_pre_queue: Optional.\n                        Called when an event is received on a sink pad before queueing up\n                        serialized events. The subclass should always chain up (Since: 1.18).\n @sink_query_pre_queue: Optional.\n                        Called when a query is received on a sink pad before queueing up\n                        serialized queries. The subclass should always chain up (Since: 1.18).\n\n The aggregator base class will handle in a thread-safe way all manners of\n concurrent flushes, seeks, pad additions and removals, leaving to the\n subclass the responsibility of clipping buffers, and aggregating buffers in\n the way the implementor sees fit.\n\n It will also take care of event ordering (stream-start, segment, eos).\n\n Basically, a simple implementation will override @aggregate, and call\n _finish_buffer from inside that function.\n\n Since: 1.14"]
pub type GstAggregatorClass = _GstAggregatorClass;
#[doc = " GstAggregatorPad Structs *"]
pub type GstAggregatorPad = _GstAggregatorPad;
#[doc = " GstAggregatorPadClass:\n @flush:       Optional\n               Called when the pad has received a flush stop, this is the place\n               to flush any information specific to the pad, it allows for individual\n               pads to be flushed while others might not be.\n @skip_buffer: Optional\n               Called before input buffers are queued in the pad, return %TRUE\n               if the buffer should be skipped.\n\n Since: 1.14"]
pub type GstAggregatorPadClass = _GstAggregatorPadClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAggregatorPadPrivate {
    _unused: [u8; 0],
}
pub type GstAggregatorPadPrivate = _GstAggregatorPadPrivate;
#[doc = " GstAggregatorPad:\n @segment: last segment received.\n\n The implementation the GstPad to use with #GstAggregator\n\n Since: 1.14"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstAggregatorPad {
    pub parent: GstPad,
    pub segment: GstSegment,
    pub priv_: *mut GstAggregatorPadPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAggregatorPad"][::std::mem::size_of::<_GstAggregatorPad>() - 680usize];
    ["Alignment of _GstAggregatorPad"][::std::mem::align_of::<_GstAggregatorPad>() - 8usize];
    ["Offset of field: _GstAggregatorPad::parent"]
        [::std::mem::offset_of!(_GstAggregatorPad, parent) - 0usize];
    ["Offset of field: _GstAggregatorPad::segment"]
        [::std::mem::offset_of!(_GstAggregatorPad, segment) - 520usize];
    ["Offset of field: _GstAggregatorPad::priv_"]
        [::std::mem::offset_of!(_GstAggregatorPad, priv_) - 640usize];
    ["Offset of field: _GstAggregatorPad::_gst_reserved"]
        [::std::mem::offset_of!(_GstAggregatorPad, _gst_reserved) - 648usize];
};
#[doc = " GstAggregatorPadClass:\n @flush:       Optional\n               Called when the pad has received a flush stop, this is the place\n               to flush any information specific to the pad, it allows for individual\n               pads to be flushed while others might not be.\n @skip_buffer: Optional\n               Called before input buffers are queued in the pad, return %TRUE\n               if the buffer should be skipped.\n\n Since: 1.14"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAggregatorPadClass {
    pub parent_class: GstPadClass,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            aggpad: *mut GstAggregatorPad,
            aggregator: *mut GstAggregator,
        ) -> GstFlowReturn,
    >,
    pub skip_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            aggpad: *mut GstAggregatorPad,
            aggregator: *mut GstAggregator,
            buffer: *mut GstBuffer,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAggregatorPadClass"][::std::mem::size_of::<_GstAggregatorPadClass>() - 408usize];
    ["Alignment of _GstAggregatorPadClass"]
        [::std::mem::align_of::<_GstAggregatorPadClass>() - 8usize];
    ["Offset of field: _GstAggregatorPadClass::parent_class"]
        [::std::mem::offset_of!(_GstAggregatorPadClass, parent_class) - 0usize];
    ["Offset of field: _GstAggregatorPadClass::flush"]
        [::std::mem::offset_of!(_GstAggregatorPadClass, flush) - 232usize];
    ["Offset of field: _GstAggregatorPadClass::skip_buffer"]
        [::std::mem::offset_of!(_GstAggregatorPadClass, skip_buffer) - 240usize];
    ["Offset of field: _GstAggregatorPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstAggregatorPadClass, _gst_reserved) - 248usize];
};
unsafe extern "C" {
    pub fn gst_aggregator_pad_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " GstAggregatorPad methods *"]
    pub fn gst_aggregator_pad_pop_buffer(pad: *mut GstAggregatorPad) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_aggregator_pad_peek_buffer(pad: *mut GstAggregatorPad) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_aggregator_pad_drop_buffer(pad: *mut GstAggregatorPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_aggregator_pad_has_buffer(pad: *mut GstAggregatorPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_aggregator_pad_is_eos(pad: *mut GstAggregatorPad) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_aggregator_pad_is_inactive(pad: *mut GstAggregatorPad) -> gboolean;
}
#[doc = " GstAggregator:\n @srcpad: the aggregator's source pad\n\n Aggregator base class object structure.\n\n Since: 1.14"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstAggregator {
    pub parent: GstElement,
    pub srcpad: *mut GstPad,
    pub priv_: *mut GstAggregatorPrivate,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAggregator"][::std::mem::size_of::<_GstAggregator>() - 440usize];
    ["Alignment of _GstAggregator"][::std::mem::align_of::<_GstAggregator>() - 8usize];
    ["Offset of field: _GstAggregator::parent"]
        [::std::mem::offset_of!(_GstAggregator, parent) - 0usize];
    ["Offset of field: _GstAggregator::srcpad"]
        [::std::mem::offset_of!(_GstAggregator, srcpad) - 264usize];
    ["Offset of field: _GstAggregator::priv_"]
        [::std::mem::offset_of!(_GstAggregator, priv_) - 272usize];
    ["Offset of field: _GstAggregator::_gst_reserved"]
        [::std::mem::offset_of!(_GstAggregator, _gst_reserved) - 280usize];
};
#[doc = " GstAggregatorClass:\n @flush:          Optional.\n                  Called after a successful flushing seek, once all the flush\n                  stops have been received. Flush pad-specific data in\n                  #GstAggregatorPad->flush.\n @clip:           Optional.\n                  Called when a buffer is received on a sink pad, the task of\n                  clipping it and translating it to the current segment falls\n                  on the subclass. The function should use the segment of data\n                  and the negotiated media type on the pad to perform\n                  clipping of input buffer. This function takes ownership of\n                  buf and should output a buffer or return NULL in\n                  if the buffer should be dropped.\n @finish_buffer:  Optional.\n                  Called when a subclass calls gst_aggregator_finish_buffer()\n                  from their aggregate function to push out a buffer.\n                  Subclasses can override this to modify or decorate buffers\n                  before they get pushed out. This function takes ownership\n                  of the buffer passed. Subclasses that override this method\n                  should always chain up to the parent class virtual method.\n @sink_event:     Optional.\n                  Called when an event is received on a sink pad, the subclass\n                  should always chain up.\n @sink_query:     Optional.\n                  Called when a query is received on a sink pad, the subclass\n                  should always chain up.\n @src_event:      Optional.\n                  Called when an event is received on the src pad, the subclass\n                  should always chain up.\n @src_query:      Optional.\n                  Called when a query is received on the src pad, the subclass\n                  should always chain up.\n @src_activate:   Optional.\n                  Called when the src pad is activated, it will start/stop its\n                  pad task right after that call.\n @aggregate:      Mandatory.\n                  Called when buffers are queued on all sinkpads. Classes\n                  should iterate the GstElement->sinkpads and peek or steal\n                  buffers from the #GstAggregatorPads. If the subclass returns\n                  GST_FLOW_EOS, sending of the eos event will be taken care\n                  of. Once / if a buffer has been constructed from the\n                  aggregated buffers, the subclass should call _finish_buffer.\n @stop:           Optional.\n                  Called when the element goes from PAUSED to READY.\n                  The subclass should free all resources and reset its state.\n @start:          Optional.\n                  Called when the element goes from READY to PAUSED.\n                  The subclass should get ready to process\n                  aggregated buffers.\n @get_next_time:  Optional.\n                  Called when the element needs to know the running time of the next\n                  rendered buffer for live pipelines. This causes deadline\n                  based aggregation to occur. Defaults to returning\n                  GST_CLOCK_TIME_NONE causing the element to wait for buffers\n                  on all sink pads before aggregating.\n @create_new_pad: Optional.\n                  Called when a new pad needs to be created. Allows subclass that\n                  don't have a single sink pad template to provide a pad based\n                  on the provided information.\n @update_src_caps: Lets subclasses update the #GstCaps representing\n                   the src pad caps before usage.  The result should end up\n                   in @ret. Return %GST_AGGREGATOR_FLOW_NEED_DATA to indicate that the\n                   element needs more information (caps, a buffer, etc) to\n                   choose the correct caps. Should return ANY caps if the\n                   stream has not caps at all.\n @fixate_src_caps: Optional.\n                   Fixate and return the src pad caps provided.  The function takes\n                   ownership of @caps and returns a fixated version of\n                   @caps. @caps is not guaranteed to be writable.\n @negotiated_src_caps: Optional.\n                       Notifies subclasses what caps format has been negotiated\n @decide_allocation: Optional.\n                     Allows the subclass to influence the allocation choices.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n @propose_allocation: Optional.\n                     Allows the subclass to handle the allocation query from upstream.\n @negotiate: Optional.\n             Negotiate the caps with the peer (Since: 1.18).\n @sink_event_pre_queue: Optional.\n                        Called when an event is received on a sink pad before queueing up\n                        serialized events. The subclass should always chain up (Since: 1.18).\n @sink_query_pre_queue: Optional.\n                        Called when a query is received on a sink pad before queueing up\n                        serialized queries. The subclass should always chain up (Since: 1.18).\n\n The aggregator base class will handle in a thread-safe way all manners of\n concurrent flushes, seeks, pad additions and removals, leaving to the\n subclass the responsibility of clipping buffers, and aggregating buffers in\n the way the implementor sees fit.\n\n It will also take care of event ordering (stream-start, segment, eos).\n\n Basically, a simple implementation will override @aggregate, and call\n _finish_buffer from inside that function.\n\n Since: 1.14"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAggregatorClass {
    pub parent_class: GstElementClass,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(aggregator: *mut GstAggregator) -> GstFlowReturn,
    >,
    pub clip: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
            buf: *mut GstBuffer,
        ) -> *mut GstBuffer,
    >,
    pub finish_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            buffer: *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub sink_event: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
            event: *mut GstEvent,
        ) -> gboolean,
    >,
    pub sink_query: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
            query: *mut GstQuery,
        ) -> gboolean,
    >,
    pub src_event: ::std::option::Option<
        unsafe extern "C" fn(aggregator: *mut GstAggregator, event: *mut GstEvent) -> gboolean,
    >,
    pub src_query: ::std::option::Option<
        unsafe extern "C" fn(aggregator: *mut GstAggregator, query: *mut GstQuery) -> gboolean,
    >,
    pub src_activate: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            mode: GstPadMode,
            active: gboolean,
        ) -> gboolean,
    >,
    pub aggregate: ::std::option::Option<
        unsafe extern "C" fn(aggregator: *mut GstAggregator, timeout: gboolean) -> GstFlowReturn,
    >,
    pub stop:
        ::std::option::Option<unsafe extern "C" fn(aggregator: *mut GstAggregator) -> gboolean>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(aggregator: *mut GstAggregator) -> gboolean>,
    pub get_next_time:
        ::std::option::Option<unsafe extern "C" fn(aggregator: *mut GstAggregator) -> GstClockTime>,
    pub create_new_pad: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GstAggregator,
            templ: *mut GstPadTemplate,
            req_name: *const gchar,
            caps: *const GstCaps,
        ) -> *mut GstAggregatorPad,
    >,
    #[doc = " GstAggregatorClass::update_src_caps:\n @ret: (out) (allow-none):"]
    pub update_src_caps: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GstAggregator,
            caps: *mut GstCaps,
            ret: *mut *mut GstCaps,
        ) -> GstFlowReturn,
    >,
    pub fixate_src_caps: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut GstAggregator, caps: *mut GstCaps) -> *mut GstCaps,
    >,
    pub negotiated_src_caps: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut GstAggregator, caps: *mut GstCaps) -> gboolean,
    >,
    pub decide_allocation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut GstAggregator, query: *mut GstQuery) -> gboolean,
    >,
    pub propose_allocation: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GstAggregator,
            pad: *mut GstAggregatorPad,
            decide_query: *mut GstQuery,
            query: *mut GstQuery,
        ) -> gboolean,
    >,
    pub negotiate:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut GstAggregator) -> gboolean>,
    pub sink_event_pre_queue: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
            event: *mut GstEvent,
        ) -> GstFlowReturn,
    >,
    pub sink_query_pre_queue: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
            query: *mut GstQuery,
        ) -> gboolean,
    >,
    #[doc = " GstAggregatorClass::finish_buffer_list:\n\n Optional. Equivalent of #GstAggregatorClass::finish_buffer for\n buffer lists.\n\n Since: 1.18"]
    pub finish_buffer_list: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            bufferlist: *mut GstBufferList,
        ) -> GstFlowReturn,
    >,
    #[doc = " GstAggregatorClass::peek_next_sample:\n\n See gst_aggregator_peek_next_sample().\n\n Since: 1.18"]
    pub peek_next_sample: ::std::option::Option<
        unsafe extern "C" fn(
            aggregator: *mut GstAggregator,
            aggregator_pad: *mut GstAggregatorPad,
        ) -> *mut GstSample,
    >,
    pub _gst_reserved: [gpointer; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstAggregatorClass"][::std::mem::size_of::<_GstAggregatorClass>() - 792usize];
    ["Alignment of _GstAggregatorClass"][::std::mem::align_of::<_GstAggregatorClass>() - 8usize];
    ["Offset of field: _GstAggregatorClass::parent_class"]
        [::std::mem::offset_of!(_GstAggregatorClass, parent_class) - 0usize];
    ["Offset of field: _GstAggregatorClass::flush"]
        [::std::mem::offset_of!(_GstAggregatorClass, flush) - 488usize];
    ["Offset of field: _GstAggregatorClass::clip"]
        [::std::mem::offset_of!(_GstAggregatorClass, clip) - 496usize];
    ["Offset of field: _GstAggregatorClass::finish_buffer"]
        [::std::mem::offset_of!(_GstAggregatorClass, finish_buffer) - 504usize];
    ["Offset of field: _GstAggregatorClass::sink_event"]
        [::std::mem::offset_of!(_GstAggregatorClass, sink_event) - 512usize];
    ["Offset of field: _GstAggregatorClass::sink_query"]
        [::std::mem::offset_of!(_GstAggregatorClass, sink_query) - 520usize];
    ["Offset of field: _GstAggregatorClass::src_event"]
        [::std::mem::offset_of!(_GstAggregatorClass, src_event) - 528usize];
    ["Offset of field: _GstAggregatorClass::src_query"]
        [::std::mem::offset_of!(_GstAggregatorClass, src_query) - 536usize];
    ["Offset of field: _GstAggregatorClass::src_activate"]
        [::std::mem::offset_of!(_GstAggregatorClass, src_activate) - 544usize];
    ["Offset of field: _GstAggregatorClass::aggregate"]
        [::std::mem::offset_of!(_GstAggregatorClass, aggregate) - 552usize];
    ["Offset of field: _GstAggregatorClass::stop"]
        [::std::mem::offset_of!(_GstAggregatorClass, stop) - 560usize];
    ["Offset of field: _GstAggregatorClass::start"]
        [::std::mem::offset_of!(_GstAggregatorClass, start) - 568usize];
    ["Offset of field: _GstAggregatorClass::get_next_time"]
        [::std::mem::offset_of!(_GstAggregatorClass, get_next_time) - 576usize];
    ["Offset of field: _GstAggregatorClass::create_new_pad"]
        [::std::mem::offset_of!(_GstAggregatorClass, create_new_pad) - 584usize];
    ["Offset of field: _GstAggregatorClass::update_src_caps"]
        [::std::mem::offset_of!(_GstAggregatorClass, update_src_caps) - 592usize];
    ["Offset of field: _GstAggregatorClass::fixate_src_caps"]
        [::std::mem::offset_of!(_GstAggregatorClass, fixate_src_caps) - 600usize];
    ["Offset of field: _GstAggregatorClass::negotiated_src_caps"]
        [::std::mem::offset_of!(_GstAggregatorClass, negotiated_src_caps) - 608usize];
    ["Offset of field: _GstAggregatorClass::decide_allocation"]
        [::std::mem::offset_of!(_GstAggregatorClass, decide_allocation) - 616usize];
    ["Offset of field: _GstAggregatorClass::propose_allocation"]
        [::std::mem::offset_of!(_GstAggregatorClass, propose_allocation) - 624usize];
    ["Offset of field: _GstAggregatorClass::negotiate"]
        [::std::mem::offset_of!(_GstAggregatorClass, negotiate) - 632usize];
    ["Offset of field: _GstAggregatorClass::sink_event_pre_queue"]
        [::std::mem::offset_of!(_GstAggregatorClass, sink_event_pre_queue) - 640usize];
    ["Offset of field: _GstAggregatorClass::sink_query_pre_queue"]
        [::std::mem::offset_of!(_GstAggregatorClass, sink_query_pre_queue) - 648usize];
    ["Offset of field: _GstAggregatorClass::finish_buffer_list"]
        [::std::mem::offset_of!(_GstAggregatorClass, finish_buffer_list) - 656usize];
    ["Offset of field: _GstAggregatorClass::peek_next_sample"]
        [::std::mem::offset_of!(_GstAggregatorClass, peek_next_sample) - 664usize];
    ["Offset of field: _GstAggregatorClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstAggregatorClass, _gst_reserved) - 672usize];
};
unsafe extern "C" {
    #[doc = " GstAggregator methods *"]
    pub fn gst_aggregator_finish_buffer(
        aggregator: *mut GstAggregator,
        buffer: *mut GstBuffer,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_aggregator_finish_buffer_list(
        aggregator: *mut GstAggregator,
        bufferlist: *mut GstBufferList,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_aggregator_set_src_caps(self_: *mut GstAggregator, caps: *mut GstCaps);
}
unsafe extern "C" {
    pub fn gst_aggregator_negotiate(self_: *mut GstAggregator) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_aggregator_set_latency(
        self_: *mut GstAggregator,
        min_latency: GstClockTime,
        max_latency: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_aggregator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_aggregator_get_latency(self_: *mut GstAggregator) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_aggregator_get_buffer_pool(self_: *mut GstAggregator) -> *mut GstBufferPool;
}
unsafe extern "C" {
    pub fn gst_aggregator_get_allocator(
        self_: *mut GstAggregator,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_aggregator_simple_get_next_time(self_: *mut GstAggregator) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_aggregator_update_segment(self_: *mut GstAggregator, segment: *const GstSegment);
}
unsafe extern "C" {
    pub fn gst_aggregator_peek_next_sample(
        self_: *mut GstAggregator,
        pad: *mut GstAggregatorPad,
    ) -> *mut GstSample;
}
unsafe extern "C" {
    pub fn gst_aggregator_selected_samples(
        self_: *mut GstAggregator,
        pts: GstClockTime,
        dts: GstClockTime,
        duration: GstClockTime,
        info: *mut GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_aggregator_set_ignore_inactive_pads(self_: *mut GstAggregator, ignore: gboolean);
}
unsafe extern "C" {
    pub fn gst_aggregator_get_ignore_inactive_pads(self_: *mut GstAggregator) -> gboolean;
}
pub const GstAggregatorStartTimeSelection_GST_AGGREGATOR_START_TIME_SELECTION_ZERO:
    GstAggregatorStartTimeSelection = 0;
pub const GstAggregatorStartTimeSelection_GST_AGGREGATOR_START_TIME_SELECTION_FIRST:
    GstAggregatorStartTimeSelection = 1;
pub const GstAggregatorStartTimeSelection_GST_AGGREGATOR_START_TIME_SELECTION_SET:
    GstAggregatorStartTimeSelection = 2;
#[doc = " GstAggregatorStartTimeSelection:\n @GST_AGGREGATOR_START_TIME_SELECTION_ZERO: Start at running time 0.\n @GST_AGGREGATOR_START_TIME_SELECTION_FIRST: Start at the running time of\n the first buffer that is received.\n @GST_AGGREGATOR_START_TIME_SELECTION_SET: Start at the running time\n selected by the `start-time` property.\n\n Since: 1.18"]
pub type GstAggregatorStartTimeSelection = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_aggregator_start_time_selection_get_type() -> GType;
}
pub type GstAggregator_autoptr = *mut GstAggregator;
pub type GstAggregator_listautoptr = *mut GList;
pub type GstAggregator_slistautoptr = *mut GSList;
pub type GstAggregator_queueautoptr = *mut GQueue;
pub type GstAggregatorPad_autoptr = *mut GstAggregatorPad;
pub type GstAggregatorPad_listautoptr = *mut GList;
pub type GstAggregatorPad_slistautoptr = *mut GSList;
pub type GstAggregatorPad_queueautoptr = *mut GQueue;
#[doc = " GstVideoAggregator:\n @info: The #GstVideoInfo representing the currently set\n srcpad caps.\n\n Since: 1.16"]
pub type GstVideoAggregator = _GstVideoAggregator;
#[doc = " GstVideoAggregatorClass:\n @update_caps:              Optional.\n                            Lets subclasses update the #GstCaps representing\n                            the src pad caps before usage.  Return %NULL to indicate failure.\n @aggregate_frames:         Lets subclasses aggregate frames that are ready. Subclasses\n                            should iterate the GstElement.sinkpads and use the already\n                            mapped #GstVideoFrame from gst_video_aggregator_pad_get_prepared_frame()\n                            or directly use the #GstBuffer from gst_video_aggregator_pad_get_current_buffer()\n                            if it needs to map the buffer in a special way. The result of the\n                            aggregation should land in @outbuffer.\n @create_output_buffer:     Optional.\n                            Lets subclasses provide a #GstBuffer to be used as @outbuffer of\n                            the #aggregate_frames vmethod.\n @find_best_format:         Optional.\n                            Lets subclasses decide of the best common format to use.\n\n Since: 1.16"]
pub type GstVideoAggregatorClass = _GstVideoAggregatorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorPrivate {
    _unused: [u8; 0],
}
pub type GstVideoAggregatorPrivate = _GstVideoAggregatorPrivate;
#[doc = " GstVideoAggregatorPad:\n @info: The #GstVideoInfo currently set on the pad\n\n Since: 1.16"]
pub type GstVideoAggregatorPad = _GstVideoAggregatorPad;
#[doc = " GstVideoAggregatorPadClass:\n @update_conversion_info: Called when either the input or output formats\n                          have changed.\n @prepare_frame: Prepare the frame from the pad buffer and sets it to prepared_frame.\n      Implementations should always return TRUE.  Returning FALSE will cease\n      iteration over subsequent pads.\n @clean_frame:   clean the frame previously prepared in prepare_frame\n\n Since: 1.16\n/\n/**\n GstVideoAggregatorPadClass::prepare_frame_start:\n @pad: the #GstVideoAggregatorPad\n @videoaggregator: the parent #GstVideoAggregator\n @buffer: the input #GstBuffer to prepare\n @prepared_frame: the #GstVideoFrame to prepare into\n\n Begin preparing the frame from the pad buffer and sets it to prepared_frame.\n\n If overriden, `prepare_frame_finish` must also be overriden.\n\n Since: 1.20\n/\n/**\n GstVideoAggregatorPadClass::prepare_frame_finish:\n @pad: the #GstVideoAggregatorPad\n @videoaggregator: the parent #GstVideoAggregator\n @prepared_frame: the #GstVideoFrame to prepare into\n\n Finish preparing @prepared_frame.\n\n If overriden, `prepare_frame_start` must also be overriden.\n\n Since: 1.20"]
pub type GstVideoAggregatorPadClass = _GstVideoAggregatorPadClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorPadPrivate {
    _unused: [u8; 0],
}
pub type GstVideoAggregatorPadPrivate = _GstVideoAggregatorPadPrivate;
#[doc = " GstVideoAggregatorPad:\n @info: The #GstVideoInfo currently set on the pad\n\n Since: 1.16"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoAggregatorPad {
    pub parent: GstAggregatorPad,
    pub info: GstVideoInfo,
    pub priv_: *mut GstVideoAggregatorPadPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorPad"][::std::mem::size_of::<_GstVideoAggregatorPad>() - 872usize];
    ["Alignment of _GstVideoAggregatorPad"]
        [::std::mem::align_of::<_GstVideoAggregatorPad>() - 8usize];
    ["Offset of field: _GstVideoAggregatorPad::parent"]
        [::std::mem::offset_of!(_GstVideoAggregatorPad, parent) - 0usize];
    ["Offset of field: _GstVideoAggregatorPad::info"]
        [::std::mem::offset_of!(_GstVideoAggregatorPad, info) - 680usize];
    ["Offset of field: _GstVideoAggregatorPad::priv_"]
        [::std::mem::offset_of!(_GstVideoAggregatorPad, priv_) - 832usize];
    ["Offset of field: _GstVideoAggregatorPad::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregatorPad, _gst_reserved) - 840usize];
};
#[doc = " GstVideoAggregatorPadClass:\n @update_conversion_info: Called when either the input or output formats\n                          have changed.\n @prepare_frame: Prepare the frame from the pad buffer and sets it to prepared_frame.\n      Implementations should always return TRUE.  Returning FALSE will cease\n      iteration over subsequent pads.\n @clean_frame:   clean the frame previously prepared in prepare_frame\n\n Since: 1.16\n/\n/**\n GstVideoAggregatorPadClass::prepare_frame_start:\n @pad: the #GstVideoAggregatorPad\n @videoaggregator: the parent #GstVideoAggregator\n @buffer: the input #GstBuffer to prepare\n @prepared_frame: the #GstVideoFrame to prepare into\n\n Begin preparing the frame from the pad buffer and sets it to prepared_frame.\n\n If overriden, `prepare_frame_finish` must also be overriden.\n\n Since: 1.20\n/\n/**\n GstVideoAggregatorPadClass::prepare_frame_finish:\n @pad: the #GstVideoAggregatorPad\n @videoaggregator: the parent #GstVideoAggregator\n @prepared_frame: the #GstVideoFrame to prepare into\n\n Finish preparing @prepared_frame.\n\n If overriden, `prepare_frame_start` must also be overriden.\n\n Since: 1.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorPadClass {
    pub parent_class: GstAggregatorPadClass,
    pub update_conversion_info:
        ::std::option::Option<unsafe extern "C" fn(pad: *mut GstVideoAggregatorPad)>,
    pub prepare_frame: ::std::option::Option<
        unsafe extern "C" fn(
            pad: *mut GstVideoAggregatorPad,
            videoaggregator: *mut GstVideoAggregator,
            buffer: *mut GstBuffer,
            prepared_frame: *mut GstVideoFrame,
        ) -> gboolean,
    >,
    pub clean_frame: ::std::option::Option<
        unsafe extern "C" fn(
            pad: *mut GstVideoAggregatorPad,
            videoaggregator: *mut GstVideoAggregator,
            prepared_frame: *mut GstVideoFrame,
        ),
    >,
    pub prepare_frame_start: ::std::option::Option<
        unsafe extern "C" fn(
            pad: *mut GstVideoAggregatorPad,
            videoaggregator: *mut GstVideoAggregator,
            buffer: *mut GstBuffer,
            prepared_frame: *mut GstVideoFrame,
        ),
    >,
    pub prepare_frame_finish: ::std::option::Option<
        unsafe extern "C" fn(
            pad: *mut GstVideoAggregatorPad,
            videoaggregator: *mut GstVideoAggregator,
            prepared_frame: *mut GstVideoFrame,
        ),
    >,
    pub _gst_reserved: [gpointer; 18usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorPadClass"]
        [::std::mem::size_of::<_GstVideoAggregatorPadClass>() - 592usize];
    ["Alignment of _GstVideoAggregatorPadClass"]
        [::std::mem::align_of::<_GstVideoAggregatorPadClass>() - 8usize];
    ["Offset of field: _GstVideoAggregatorPadClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoAggregatorPadClass::update_conversion_info"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, update_conversion_info) - 408usize];
    ["Offset of field: _GstVideoAggregatorPadClass::prepare_frame"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, prepare_frame) - 416usize];
    ["Offset of field: _GstVideoAggregatorPadClass::clean_frame"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, clean_frame) - 424usize];
    ["Offset of field: _GstVideoAggregatorPadClass::prepare_frame_start"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, prepare_frame_start) - 432usize];
    ["Offset of field: _GstVideoAggregatorPadClass::prepare_frame_finish"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, prepare_frame_finish) - 440usize];
    ["Offset of field: _GstVideoAggregatorPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregatorPadClass, _gst_reserved) - 448usize];
};
unsafe extern "C" {
    pub fn gst_video_aggregator_pad_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_pad_has_current_buffer(pad: *mut GstVideoAggregatorPad)
    -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_pad_get_current_buffer(
        pad: *mut GstVideoAggregatorPad,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_pad_get_prepared_frame(
        pad: *mut GstVideoAggregatorPad,
    ) -> *mut GstVideoFrame;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_pad_set_needs_alpha(
        pad: *mut GstVideoAggregatorPad,
        needs_alpha: gboolean,
    );
}
#[doc = " GstVideoAggregatorConvertPad:\n\n An implementation of GstPad that can be used with #GstVideoAggregator.\n\n See #GstVideoAggregator for more details.\n\n Since: 1.16"]
pub type GstVideoAggregatorConvertPad = _GstVideoAggregatorConvertPad;
#[doc = " GstVideoAggregatorConvertPadClass:\n\n Since: 1.16"]
pub type GstVideoAggregatorConvertPadClass = _GstVideoAggregatorConvertPadClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorConvertPadPrivate {
    _unused: [u8; 0],
}
pub type GstVideoAggregatorConvertPadPrivate = _GstVideoAggregatorConvertPadPrivate;
#[doc = " GstVideoAggregatorConvertPad:\n\n An implementation of GstPad that can be used with #GstVideoAggregator.\n\n See #GstVideoAggregator for more details.\n\n Since: 1.16"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoAggregatorConvertPad {
    pub parent: GstVideoAggregatorPad,
    pub priv_: *mut GstVideoAggregatorConvertPadPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorConvertPad"]
        [::std::mem::size_of::<_GstVideoAggregatorConvertPad>() - 912usize];
    ["Alignment of _GstVideoAggregatorConvertPad"]
        [::std::mem::align_of::<_GstVideoAggregatorConvertPad>() - 8usize];
    ["Offset of field: _GstVideoAggregatorConvertPad::parent"]
        [::std::mem::offset_of!(_GstVideoAggregatorConvertPad, parent) - 0usize];
    ["Offset of field: _GstVideoAggregatorConvertPad::priv_"]
        [::std::mem::offset_of!(_GstVideoAggregatorConvertPad, priv_) - 872usize];
    ["Offset of field: _GstVideoAggregatorConvertPad::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregatorConvertPad, _gst_reserved) - 880usize];
};
#[doc = " GstVideoAggregatorConvertPadClass:\n\n Since: 1.16"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorConvertPadClass {
    pub parent_class: GstVideoAggregatorPadClass,
    pub create_conversion_info: ::std::option::Option<
        unsafe extern "C" fn(
            pad: *mut GstVideoAggregatorConvertPad,
            agg: *mut GstVideoAggregator,
            conversion_info: *mut GstVideoInfo,
        ),
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorConvertPadClass"]
        [::std::mem::size_of::<_GstVideoAggregatorConvertPadClass>() - 632usize];
    ["Alignment of _GstVideoAggregatorConvertPadClass"]
        [::std::mem::align_of::<_GstVideoAggregatorConvertPadClass>() - 8usize];
    ["Offset of field: _GstVideoAggregatorConvertPadClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoAggregatorConvertPadClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoAggregatorConvertPadClass::create_conversion_info"][::std::mem::offset_of!(
        _GstVideoAggregatorConvertPadClass,
        create_conversion_info
    ) - 592usize];
    ["Offset of field: _GstVideoAggregatorConvertPadClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregatorConvertPadClass, _gst_reserved) - 600usize];
};
unsafe extern "C" {
    pub fn gst_video_aggregator_convert_pad_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_convert_pad_update_conversion_info(
        pad: *mut GstVideoAggregatorConvertPad,
    );
}
pub type GstVideoAggregatorConvertPad_autoptr = *mut GstVideoAggregatorConvertPad;
pub type GstVideoAggregatorConvertPad_listautoptr = *mut GList;
pub type GstVideoAggregatorConvertPad_slistautoptr = *mut GSList;
pub type GstVideoAggregatorConvertPad_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn gst_video_aggregator_parallel_convert_pad_get_type() -> GType;
}
pub type GstVideoAggregatorParallelConvertPad = _GstVideoAggregatorParallelConvertPad;
#[doc = " GstVideoAggregatorParallelConvertPadClass:\n\n Since: 1.20"]
pub type GstVideoAggregatorParallelConvertPadClass = _GstVideoAggregatorParallelConvertPadClass;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoAggregatorParallelConvertPad {
    pub parent_instance: GstVideoAggregatorConvertPad,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorParallelConvertPad"]
        [::std::mem::size_of::<_GstVideoAggregatorParallelConvertPad>() - 912usize];
    ["Alignment of _GstVideoAggregatorParallelConvertPad"]
        [::std::mem::align_of::<_GstVideoAggregatorParallelConvertPad>() - 8usize];
    ["Offset of field: _GstVideoAggregatorParallelConvertPad::parent_instance"]
        [::std::mem::offset_of!(_GstVideoAggregatorParallelConvertPad, parent_instance) - 0usize];
};
pub type GstVideoAggregatorParallelConvertPad_autoptr = *mut GstVideoAggregatorParallelConvertPad;
pub type GstVideoAggregatorParallelConvertPad_listautoptr = *mut GList;
pub type GstVideoAggregatorParallelConvertPad_slistautoptr = *mut GSList;
pub type GstVideoAggregatorParallelConvertPad_queueautoptr = *mut GQueue;
pub type GstVideoAggregatorParallelConvertPadClass_autoptr =
    *mut GstVideoAggregatorParallelConvertPadClass;
pub type GstVideoAggregatorParallelConvertPadClass_listautoptr = *mut GList;
pub type GstVideoAggregatorParallelConvertPadClass_slistautoptr = *mut GSList;
pub type GstVideoAggregatorParallelConvertPadClass_queueautoptr = *mut GQueue;
#[doc = " GstVideoAggregatorParallelConvertPadClass:\n\n Since: 1.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorParallelConvertPadClass {
    pub parent_class: GstVideoAggregatorConvertPadClass,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorParallelConvertPadClass"]
        [::std::mem::size_of::<_GstVideoAggregatorParallelConvertPadClass>() - 664usize];
    ["Alignment of _GstVideoAggregatorParallelConvertPadClass"]
        [::std::mem::align_of::<_GstVideoAggregatorParallelConvertPadClass>() - 8usize];
    ["Offset of field: _GstVideoAggregatorParallelConvertPadClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoAggregatorParallelConvertPadClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoAggregatorParallelConvertPadClass::_gst_reserved"][::std::mem::offset_of!(
        _GstVideoAggregatorParallelConvertPadClass,
        _gst_reserved
    ) - 632usize];
};
#[doc = " GstVideoAggregator:\n @info: The #GstVideoInfo representing the currently set\n srcpad caps.\n\n Since: 1.16"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoAggregator {
    pub aggregator: GstAggregator,
    pub info: GstVideoInfo,
    pub priv_: *mut GstVideoAggregatorPrivate,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregator"][::std::mem::size_of::<_GstVideoAggregator>() - 760usize];
    ["Alignment of _GstVideoAggregator"][::std::mem::align_of::<_GstVideoAggregator>() - 8usize];
    ["Offset of field: _GstVideoAggregator::aggregator"]
        [::std::mem::offset_of!(_GstVideoAggregator, aggregator) - 0usize];
    ["Offset of field: _GstVideoAggregator::info"]
        [::std::mem::offset_of!(_GstVideoAggregator, info) - 440usize];
    ["Offset of field: _GstVideoAggregator::priv_"]
        [::std::mem::offset_of!(_GstVideoAggregator, priv_) - 592usize];
    ["Offset of field: _GstVideoAggregator::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregator, _gst_reserved) - 600usize];
};
#[doc = " GstVideoAggregatorClass:\n @update_caps:              Optional.\n                            Lets subclasses update the #GstCaps representing\n                            the src pad caps before usage.  Return %NULL to indicate failure.\n @aggregate_frames:         Lets subclasses aggregate frames that are ready. Subclasses\n                            should iterate the GstElement.sinkpads and use the already\n                            mapped #GstVideoFrame from gst_video_aggregator_pad_get_prepared_frame()\n                            or directly use the #GstBuffer from gst_video_aggregator_pad_get_current_buffer()\n                            if it needs to map the buffer in a special way. The result of the\n                            aggregation should land in @outbuffer.\n @create_output_buffer:     Optional.\n                            Lets subclasses provide a #GstBuffer to be used as @outbuffer of\n                            the #aggregate_frames vmethod.\n @find_best_format:         Optional.\n                            Lets subclasses decide of the best common format to use.\n\n Since: 1.16"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAggregatorClass {
    pub parent_class: GstAggregatorClass,
    pub update_caps: ::std::option::Option<
        unsafe extern "C" fn(
            videoaggregator: *mut GstVideoAggregator,
            caps: *mut GstCaps,
        ) -> *mut GstCaps,
    >,
    pub aggregate_frames: ::std::option::Option<
        unsafe extern "C" fn(
            videoaggregator: *mut GstVideoAggregator,
            outbuffer: *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub create_output_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            videoaggregator: *mut GstVideoAggregator,
            outbuffer: *mut *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub find_best_format: ::std::option::Option<
        unsafe extern "C" fn(
            vagg: *mut GstVideoAggregator,
            downstream_caps: *mut GstCaps,
            best_info: *mut GstVideoInfo,
            at_least_one_alpha: *mut gboolean,
        ),
    >,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAggregatorClass"]
        [::std::mem::size_of::<_GstVideoAggregatorClass>() - 984usize];
    ["Alignment of _GstVideoAggregatorClass"]
        [::std::mem::align_of::<_GstVideoAggregatorClass>() - 8usize];
    ["Offset of field: _GstVideoAggregatorClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoAggregatorClass::update_caps"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, update_caps) - 792usize];
    ["Offset of field: _GstVideoAggregatorClass::aggregate_frames"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, aggregate_frames) - 800usize];
    ["Offset of field: _GstVideoAggregatorClass::create_output_buffer"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, create_output_buffer) - 808usize];
    ["Offset of field: _GstVideoAggregatorClass::find_best_format"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, find_best_format) - 816usize];
    ["Offset of field: _GstVideoAggregatorClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAggregatorClass, _gst_reserved) - 824usize];
};
unsafe extern "C" {
    pub fn gst_video_aggregator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_aggregator_get_execution_task_pool(
        vagg: *mut GstVideoAggregator,
    ) -> *mut GstTaskPool;
}
pub type GstVideoAggregator_autoptr = *mut GstVideoAggregator;
pub type GstVideoAggregator_listautoptr = *mut GList;
pub type GstVideoAggregator_slistautoptr = *mut GSList;
pub type GstVideoAggregator_queueautoptr = *mut GQueue;
pub type GstVideoAggregatorPad_autoptr = *mut GstVideoAggregatorPad;
pub type GstVideoAggregatorPad_listautoptr = *mut GList;
pub type GstVideoAggregatorPad_slistautoptr = *mut GSList;
pub type GstVideoAggregatorPad_queueautoptr = *mut GQueue;
#[doc = " GstVideoCodecAlphaMeta:\n @meta: parent #GstMeta\n @buffer: the encoded alpha frame\n\n Encapsulate an extra frame containing the encoded alpha channel for the\n currently negotiated CODEC. The streams must be of the same dimention as\n the original one.\n\n Since: 1.20"]
pub type GstVideoCodecAlphaMeta = _GstVideoCodecAlphaMeta;
#[doc = " GstVideoCodecAlphaMeta:\n @meta: parent #GstMeta\n @buffer: the encoded alpha frame\n\n Encapsulate an extra frame containing the encoded alpha channel for the\n currently negotiated CODEC. The streams must be of the same dimention as\n the original one.\n\n Since: 1.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoCodecAlphaMeta {
    pub meta: GstMeta,
    pub buffer: *mut GstBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCodecAlphaMeta"][::std::mem::size_of::<_GstVideoCodecAlphaMeta>() - 24usize];
    ["Alignment of _GstVideoCodecAlphaMeta"]
        [::std::mem::align_of::<_GstVideoCodecAlphaMeta>() - 8usize];
    ["Offset of field: _GstVideoCodecAlphaMeta::meta"]
        [::std::mem::offset_of!(_GstVideoCodecAlphaMeta, meta) - 0usize];
    ["Offset of field: _GstVideoCodecAlphaMeta::buffer"]
        [::std::mem::offset_of!(_GstVideoCodecAlphaMeta, buffer) - 16usize];
};
unsafe extern "C" {
    pub fn gst_video_codec_alpha_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_codec_alpha_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_codec_alpha_meta(
        buffer: *mut GstBuffer,
        alpha_buffer: *mut GstBuffer,
    ) -> *mut GstVideoCodecAlphaMeta;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAdapter {
    _unused: [u8; 0],
}
#[doc = " GstAdapter:\n\n The opaque #GstAdapter data structure."]
pub type GstAdapter = _GstAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstAdapterClass {
    _unused: [u8; 0],
}
pub type GstAdapterClass = _GstAdapterClass;
unsafe extern "C" {
    pub fn gst_adapter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_adapter_new() -> *mut GstAdapter;
}
unsafe extern "C" {
    pub fn gst_adapter_clear(adapter: *mut GstAdapter);
}
unsafe extern "C" {
    pub fn gst_adapter_push(adapter: *mut GstAdapter, buf: *mut GstBuffer);
}
unsafe extern "C" {
    pub fn gst_adapter_map(adapter: *mut GstAdapter, size: gsize) -> gconstpointer;
}
unsafe extern "C" {
    pub fn gst_adapter_unmap(adapter: *mut GstAdapter);
}
unsafe extern "C" {
    pub fn gst_adapter_copy(adapter: *mut GstAdapter, dest: gpointer, offset: gsize, size: gsize);
}
unsafe extern "C" {
    pub fn gst_adapter_copy_bytes(
        adapter: *mut GstAdapter,
        offset: gsize,
        size: gsize,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn gst_adapter_flush(adapter: *mut GstAdapter, flush: gsize);
}
unsafe extern "C" {
    pub fn gst_adapter_take(adapter: *mut GstAdapter, nbytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn gst_adapter_take_buffer(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_adapter_take_list(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_adapter_take_buffer_fast(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_adapter_take_buffer_list(
        adapter: *mut GstAdapter,
        nbytes: gsize,
    ) -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_adapter_get_buffer(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_adapter_get_list(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_adapter_get_buffer_fast(adapter: *mut GstAdapter, nbytes: gsize) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_adapter_get_buffer_list(
        adapter: *mut GstAdapter,
        nbytes: gsize,
    ) -> *mut GstBufferList;
}
unsafe extern "C" {
    pub fn gst_adapter_available(adapter: *mut GstAdapter) -> gsize;
}
unsafe extern "C" {
    pub fn gst_adapter_available_fast(adapter: *mut GstAdapter) -> gsize;
}
unsafe extern "C" {
    pub fn gst_adapter_prev_pts(adapter: *mut GstAdapter, distance: *mut guint64) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_prev_dts(adapter: *mut GstAdapter, distance: *mut guint64) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_prev_pts_at_offset(
        adapter: *mut GstAdapter,
        offset: gsize,
        distance: *mut guint64,
    ) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_prev_dts_at_offset(
        adapter: *mut GstAdapter,
        offset: gsize,
        distance: *mut guint64,
    ) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_prev_offset(adapter: *mut GstAdapter, distance: *mut guint64) -> guint64;
}
unsafe extern "C" {
    pub fn gst_adapter_pts_at_discont(adapter: *mut GstAdapter) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_dts_at_discont(adapter: *mut GstAdapter) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_adapter_offset_at_discont(adapter: *mut GstAdapter) -> guint64;
}
unsafe extern "C" {
    pub fn gst_adapter_distance_from_discont(adapter: *mut GstAdapter) -> guint64;
}
unsafe extern "C" {
    pub fn gst_adapter_masked_scan_uint32(
        adapter: *mut GstAdapter,
        mask: guint32,
        pattern: guint32,
        offset: gsize,
        size: gsize,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn gst_adapter_masked_scan_uint32_peek(
        adapter: *mut GstAdapter,
        mask: guint32,
        pattern: guint32,
        offset: gsize,
        size: gsize,
        value: *mut guint32,
    ) -> gssize;
}
pub type GstAdapter_autoptr = *mut GstAdapter;
pub type GstAdapter_listautoptr = *mut GList;
pub type GstAdapter_slistautoptr = *mut GSList;
pub type GstAdapter_queueautoptr = *mut GQueue;
#[doc = " GstVideoMasteringDisplayInfoCoordinates:\n @x: the x coordinate of CIE 1931 color space in unit of 0.00002.\n @y: the y coordinate of CIE 1931 color space in unit of 0.00002.\n\n Used to represent display_primaries and white_point of\n #GstVideoMasteringDisplayInfo struct. See #GstVideoMasteringDisplayInfo\n\n Since: 1.18"]
pub type GstVideoMasteringDisplayInfoCoordinates = _GstVideoMasteringDisplayInfoCoordinates;
#[doc = " GstVideoMasteringDisplayInfo:\n @display_primaries: the xy coordinates of primaries in the CIE 1931 color space.\n   the index 0 contains red, 1 is for green and 2 is for blue.\n   each value is normalized to 50000 (meaning that in unit of 0.00002)\n @white_point: the xy coordinates of white point in the CIE 1931 color space.\n   each value is normalized to 50000 (meaning that in unit of 0.00002)\n @max_display_mastering_luminance: the maximum value of display luminance\n   in unit of 0.0001 candelas per square metre (cd/m^2 and nit)\n @min_display_mastering_luminance: the minimum value of display luminance\n   in unit of 0.0001 candelas per square metre (cd/m^2 and nit)\n\n Mastering display color volume information defined by SMPTE ST 2086\n (a.k.a static HDR metadata).\n\n Since: 1.18"]
pub type GstVideoMasteringDisplayInfo = _GstVideoMasteringDisplayInfo;
#[doc = " GstVideoContentLightLevel:\n @max_content_light_level: the maximum content light level\n   (abbreviated to MaxCLL) in candelas per square meter (cd/m^2 and nit)\n @max_frame_average_light_level: the maximum frame average light level\n   (abbreviated to MaxFLL) in candelas per square meter (cd/m^2 and nit)\n\n Content light level information specified in CEA-861.3, Appendix A.\n\n Since: 1.18"]
pub type GstVideoContentLightLevel = _GstVideoContentLightLevel;
#[doc = " GstVideoMasteringDisplayInfoCoordinates:\n @x: the x coordinate of CIE 1931 color space in unit of 0.00002.\n @y: the y coordinate of CIE 1931 color space in unit of 0.00002.\n\n Used to represent display_primaries and white_point of\n #GstVideoMasteringDisplayInfo struct. See #GstVideoMasteringDisplayInfo\n\n Since: 1.18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoMasteringDisplayInfoCoordinates {
    pub x: guint16,
    pub y: guint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoMasteringDisplayInfoCoordinates"]
        [::std::mem::size_of::<_GstVideoMasteringDisplayInfoCoordinates>() - 4usize];
    ["Alignment of _GstVideoMasteringDisplayInfoCoordinates"]
        [::std::mem::align_of::<_GstVideoMasteringDisplayInfoCoordinates>() - 2usize];
    ["Offset of field: _GstVideoMasteringDisplayInfoCoordinates::x"]
        [::std::mem::offset_of!(_GstVideoMasteringDisplayInfoCoordinates, x) - 0usize];
    ["Offset of field: _GstVideoMasteringDisplayInfoCoordinates::y"]
        [::std::mem::offset_of!(_GstVideoMasteringDisplayInfoCoordinates, y) - 2usize];
};
#[doc = " GstVideoMasteringDisplayInfo:\n @display_primaries: the xy coordinates of primaries in the CIE 1931 color space.\n   the index 0 contains red, 1 is for green and 2 is for blue.\n   each value is normalized to 50000 (meaning that in unit of 0.00002)\n @white_point: the xy coordinates of white point in the CIE 1931 color space.\n   each value is normalized to 50000 (meaning that in unit of 0.00002)\n @max_display_mastering_luminance: the maximum value of display luminance\n   in unit of 0.0001 candelas per square metre (cd/m^2 and nit)\n @min_display_mastering_luminance: the minimum value of display luminance\n   in unit of 0.0001 candelas per square metre (cd/m^2 and nit)\n\n Mastering display color volume information defined by SMPTE ST 2086\n (a.k.a static HDR metadata).\n\n Since: 1.18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoMasteringDisplayInfo {
    pub display_primaries: [GstVideoMasteringDisplayInfoCoordinates; 3usize],
    pub white_point: GstVideoMasteringDisplayInfoCoordinates,
    pub max_display_mastering_luminance: guint32,
    pub min_display_mastering_luminance: guint32,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoMasteringDisplayInfo"]
        [::std::mem::size_of::<_GstVideoMasteringDisplayInfo>() - 56usize];
    ["Alignment of _GstVideoMasteringDisplayInfo"]
        [::std::mem::align_of::<_GstVideoMasteringDisplayInfo>() - 8usize];
    ["Offset of field: _GstVideoMasteringDisplayInfo::display_primaries"]
        [::std::mem::offset_of!(_GstVideoMasteringDisplayInfo, display_primaries) - 0usize];
    ["Offset of field: _GstVideoMasteringDisplayInfo::white_point"]
        [::std::mem::offset_of!(_GstVideoMasteringDisplayInfo, white_point) - 12usize];
    ["Offset of field: _GstVideoMasteringDisplayInfo::max_display_mastering_luminance"][::std::mem::offset_of!(
        _GstVideoMasteringDisplayInfo,
        max_display_mastering_luminance
    )
        - 16usize];
    ["Offset of field: _GstVideoMasteringDisplayInfo::min_display_mastering_luminance"][::std::mem::offset_of!(
        _GstVideoMasteringDisplayInfo,
        min_display_mastering_luminance
    )
        - 20usize];
    ["Offset of field: _GstVideoMasteringDisplayInfo::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoMasteringDisplayInfo, _gst_reserved) - 24usize];
};
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_init(minfo: *mut GstVideoMasteringDisplayInfo);
}
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_from_string(
        minfo: *mut GstVideoMasteringDisplayInfo,
        mastering: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_to_string(
        minfo: *const GstVideoMasteringDisplayInfo,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_is_equal(
        minfo: *const GstVideoMasteringDisplayInfo,
        other: *const GstVideoMasteringDisplayInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_from_caps(
        minfo: *mut GstVideoMasteringDisplayInfo,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_mastering_display_info_add_to_caps(
        minfo: *const GstVideoMasteringDisplayInfo,
        caps: *mut GstCaps,
    ) -> gboolean;
}
#[doc = " GstVideoContentLightLevel:\n @max_content_light_level: the maximum content light level\n   (abbreviated to MaxCLL) in candelas per square meter (cd/m^2 and nit)\n @max_frame_average_light_level: the maximum frame average light level\n   (abbreviated to MaxFLL) in candelas per square meter (cd/m^2 and nit)\n\n Content light level information specified in CEA-861.3, Appendix A.\n\n Since: 1.18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoContentLightLevel {
    pub max_content_light_level: guint16,
    pub max_frame_average_light_level: guint16,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoContentLightLevel"]
        [::std::mem::size_of::<_GstVideoContentLightLevel>() - 40usize];
    ["Alignment of _GstVideoContentLightLevel"]
        [::std::mem::align_of::<_GstVideoContentLightLevel>() - 8usize];
    ["Offset of field: _GstVideoContentLightLevel::max_content_light_level"]
        [::std::mem::offset_of!(_GstVideoContentLightLevel, max_content_light_level) - 0usize];
    ["Offset of field: _GstVideoContentLightLevel::max_frame_average_light_level"][::std::mem::offset_of!(
        _GstVideoContentLightLevel,
        max_frame_average_light_level
    ) - 2usize];
    ["Offset of field: _GstVideoContentLightLevel::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoContentLightLevel, _gst_reserved) - 8usize];
};
unsafe extern "C" {
    pub fn gst_video_content_light_level_init(linfo: *mut GstVideoContentLightLevel);
}
unsafe extern "C" {
    pub fn gst_video_content_light_level_from_string(
        linfo: *mut GstVideoContentLightLevel,
        level: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_content_light_level_to_string(
        linfo: *const GstVideoContentLightLevel,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_video_content_light_level_is_equal(
        linfo: *const GstVideoContentLightLevel,
        other: *const GstVideoContentLightLevel,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_content_light_level_from_caps(
        linfo: *mut GstVideoContentLightLevel,
        caps: *const GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_content_light_level_add_to_caps(
        linfo: *const GstVideoContentLightLevel,
        caps: *mut GstCaps,
    ) -> gboolean;
}
#[doc = " GstVideoCodecState:\n @info: The #GstVideoInfo describing the stream\n @caps: The #GstCaps used in the caps negotiation of the pad.\n @codec_data: a #GstBuffer corresponding to the\n     'codec_data' field of a stream, or NULL.\n @allocation_caps: The #GstCaps for allocation query and pool\n     negotiation. Since: 1.10\n @mastering_display_info: Mastering display color volume information\n     (HDR metadata) for the stream. Since: 1.20\n @content_light_level: Content light level information for the stream.\n     Since: 1.20\n\n Structure representing the state of an incoming or outgoing video\n stream for encoders and decoders.\n\n Decoders and encoders will receive such a state through their\n respective @set_format vmethods.\n\n Decoders and encoders can set the downstream state, by using the\n gst_video_decoder_set_output_state() or\n gst_video_encoder_set_output_state() methods.\n/\n/**\n GstVideoCodecState.mastering_display_info:\n\n Mastering display color volume information (HDR metadata) for the stream.\n\n Since: 1.20\n/\n/**\n GstVideoCodecState.content_light_level:\n\n Content light level information for the stream.\n\n Since: 1.20"]
pub type GstVideoCodecState = _GstVideoCodecState;
#[doc = " GstVideoCodecFrame:\n @pts: Presentation timestamp\n @dts: Decoding timestamp\n @duration: Duration of the frame\n @system_frame_number: Unique identifier for the frame. Use this if you need\n       to get hold of the frame later (like when data is being decoded).\n       Typical usage in decoders is to set this on the opaque value provided\n       to the library and get back the frame using gst_video_decoder_get_frame()\n @distance_from_sync: Distance in frames from the last synchronization point.\n @input_buffer: the input #GstBuffer that created this frame. The buffer is owned\n           by the frame and references to the frame instead of the buffer should\n           be kept.\n @output_buffer: the output #GstBuffer. Implementations should set this either\n           directly, or by using the\n           gst_video_decoder_allocate_output_frame() or\n           gst_video_decoder_allocate_output_buffer() methods. The buffer is\n           owned by the frame and references to the frame instead of the\n           buffer should be kept.\n @deadline: Running time when the frame will be used.\n\n A #GstVideoCodecFrame represents a video frame both in raw and\n encoded form."]
pub type GstVideoCodecFrame = _GstVideoCodecFrame;
#[doc = " GstVideoCodecState:\n @info: The #GstVideoInfo describing the stream\n @caps: The #GstCaps used in the caps negotiation of the pad.\n @codec_data: a #GstBuffer corresponding to the\n     'codec_data' field of a stream, or NULL.\n @allocation_caps: The #GstCaps for allocation query and pool\n     negotiation. Since: 1.10\n @mastering_display_info: Mastering display color volume information\n     (HDR metadata) for the stream. Since: 1.20\n @content_light_level: Content light level information for the stream.\n     Since: 1.20\n\n Structure representing the state of an incoming or outgoing video\n stream for encoders and decoders.\n\n Decoders and encoders will receive such a state through their\n respective @set_format vmethods.\n\n Decoders and encoders can set the downstream state, by using the\n gst_video_decoder_set_output_state() or\n gst_video_encoder_set_output_state() methods.\n/\n/**\n GstVideoCodecState.mastering_display_info:\n\n Mastering display color volume information (HDR metadata) for the stream.\n\n Since: 1.20\n/\n/**\n GstVideoCodecState.content_light_level:\n\n Content light level information for the stream.\n\n Since: 1.20"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoCodecState {
    pub ref_count: gint,
    pub info: GstVideoInfo,
    pub caps: *mut GstCaps,
    pub codec_data: *mut GstBuffer,
    pub allocation_caps: *mut GstCaps,
    pub mastering_display_info: *mut GstVideoMasteringDisplayInfo,
    pub content_light_level: *mut GstVideoContentLightLevel,
    pub padding: [gpointer; 17usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCodecState"][::std::mem::size_of::<_GstVideoCodecState>() - 336usize];
    ["Alignment of _GstVideoCodecState"][::std::mem::align_of::<_GstVideoCodecState>() - 8usize];
    ["Offset of field: _GstVideoCodecState::ref_count"]
        [::std::mem::offset_of!(_GstVideoCodecState, ref_count) - 0usize];
    ["Offset of field: _GstVideoCodecState::info"]
        [::std::mem::offset_of!(_GstVideoCodecState, info) - 8usize];
    ["Offset of field: _GstVideoCodecState::caps"]
        [::std::mem::offset_of!(_GstVideoCodecState, caps) - 160usize];
    ["Offset of field: _GstVideoCodecState::codec_data"]
        [::std::mem::offset_of!(_GstVideoCodecState, codec_data) - 168usize];
    ["Offset of field: _GstVideoCodecState::allocation_caps"]
        [::std::mem::offset_of!(_GstVideoCodecState, allocation_caps) - 176usize];
    ["Offset of field: _GstVideoCodecState::mastering_display_info"]
        [::std::mem::offset_of!(_GstVideoCodecState, mastering_display_info) - 184usize];
    ["Offset of field: _GstVideoCodecState::content_light_level"]
        [::std::mem::offset_of!(_GstVideoCodecState, content_light_level) - 192usize];
    ["Offset of field: _GstVideoCodecState::padding"]
        [::std::mem::offset_of!(_GstVideoCodecState, padding) - 200usize];
};
pub const GstVideoCodecFrameFlags_GST_VIDEO_CODEC_FRAME_FLAG_DECODE_ONLY: GstVideoCodecFrameFlags =
    1;
pub const GstVideoCodecFrameFlags_GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT: GstVideoCodecFrameFlags =
    2;
pub const GstVideoCodecFrameFlags_GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME:
    GstVideoCodecFrameFlags = 4;
pub const GstVideoCodecFrameFlags_GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS:
    GstVideoCodecFrameFlags = 8;
#[doc = " GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED:\n\n The buffer data is corrupted.\n\n Since: 1.20"]
pub const GstVideoCodecFrameFlags_GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED: GstVideoCodecFrameFlags =
    16;
#[doc = " GstVideoCodecFrameFlags:\n @GST_VIDEO_CODEC_FRAME_FLAG_DECODE_ONLY: is the frame only meant to be decoded\n @GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT: is the frame a synchronization point (keyframe)\n @GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME: should the output frame be made a keyframe\n @GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS: should the encoder output stream headers\n @GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED: the buffer data is corrupted (Since: 1.20)\n\n Flags for #GstVideoCodecFrame"]
pub type GstVideoCodecFrameFlags = ::std::os::raw::c_uint;
#[doc = " GstVideoCodecFrame:\n @pts: Presentation timestamp\n @dts: Decoding timestamp\n @duration: Duration of the frame\n @system_frame_number: Unique identifier for the frame. Use this if you need\n       to get hold of the frame later (like when data is being decoded).\n       Typical usage in decoders is to set this on the opaque value provided\n       to the library and get back the frame using gst_video_decoder_get_frame()\n @distance_from_sync: Distance in frames from the last synchronization point.\n @input_buffer: the input #GstBuffer that created this frame. The buffer is owned\n           by the frame and references to the frame instead of the buffer should\n           be kept.\n @output_buffer: the output #GstBuffer. Implementations should set this either\n           directly, or by using the\n           gst_video_decoder_allocate_output_frame() or\n           gst_video_decoder_allocate_output_buffer() methods. The buffer is\n           owned by the frame and references to the frame instead of the\n           buffer should be kept.\n @deadline: Running time when the frame will be used.\n\n A #GstVideoCodecFrame represents a video frame both in raw and\n encoded form."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoCodecFrame {
    pub ref_count: gint,
    pub flags: guint32,
    pub system_frame_number: guint32,
    pub decode_frame_number: guint32,
    pub presentation_frame_number: guint32,
    pub dts: GstClockTime,
    pub pts: GstClockTime,
    pub duration: GstClockTime,
    pub distance_from_sync: ::std::os::raw::c_int,
    pub input_buffer: *mut GstBuffer,
    pub output_buffer: *mut GstBuffer,
    pub deadline: GstClockTime,
    pub events: *mut GList,
    pub user_data: gpointer,
    pub user_data_destroy_notify: GDestroyNotify,
    pub abidata: _GstVideoCodecFrame__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GstVideoCodecFrame__bindgen_ty_1 {
    pub ABI: _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1,
    pub padding: [gpointer; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1 {
    pub ts: GstClockTime,
    pub ts2: GstClockTime,
    pub num_subframes: guint,
    pub subframes_processed: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1>() - 24usize];
    ["Alignment of _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1::ts"]
        [::std::mem::offset_of!(_GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1, ts) - 0usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1::ts2"]
        [::std::mem::offset_of!(_GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1, ts2) - 8usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1::num_subframes"][::std::mem::offset_of!(
        _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1,
        num_subframes
    )
        - 16usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1::subframes_processed"][::std::mem::offset_of!(
        _GstVideoCodecFrame__bindgen_ty_1__bindgen_ty_1,
        subframes_processed
    )
        - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCodecFrame__bindgen_ty_1"]
        [::std::mem::size_of::<_GstVideoCodecFrame__bindgen_ty_1>() - 160usize];
    ["Alignment of _GstVideoCodecFrame__bindgen_ty_1"]
        [::std::mem::align_of::<_GstVideoCodecFrame__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1::ABI"]
        [::std::mem::offset_of!(_GstVideoCodecFrame__bindgen_ty_1, ABI) - 0usize];
    ["Offset of field: _GstVideoCodecFrame__bindgen_ty_1::padding"]
        [::std::mem::offset_of!(_GstVideoCodecFrame__bindgen_ty_1, padding) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCodecFrame"][::std::mem::size_of::<_GstVideoCodecFrame>() - 264usize];
    ["Alignment of _GstVideoCodecFrame"][::std::mem::align_of::<_GstVideoCodecFrame>() - 8usize];
    ["Offset of field: _GstVideoCodecFrame::ref_count"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, ref_count) - 0usize];
    ["Offset of field: _GstVideoCodecFrame::flags"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, flags) - 4usize];
    ["Offset of field: _GstVideoCodecFrame::system_frame_number"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, system_frame_number) - 8usize];
    ["Offset of field: _GstVideoCodecFrame::decode_frame_number"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, decode_frame_number) - 12usize];
    ["Offset of field: _GstVideoCodecFrame::presentation_frame_number"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, presentation_frame_number) - 16usize];
    ["Offset of field: _GstVideoCodecFrame::dts"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, dts) - 24usize];
    ["Offset of field: _GstVideoCodecFrame::pts"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, pts) - 32usize];
    ["Offset of field: _GstVideoCodecFrame::duration"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, duration) - 40usize];
    ["Offset of field: _GstVideoCodecFrame::distance_from_sync"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, distance_from_sync) - 48usize];
    ["Offset of field: _GstVideoCodecFrame::input_buffer"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, input_buffer) - 56usize];
    ["Offset of field: _GstVideoCodecFrame::output_buffer"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, output_buffer) - 64usize];
    ["Offset of field: _GstVideoCodecFrame::deadline"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, deadline) - 72usize];
    ["Offset of field: _GstVideoCodecFrame::events"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, events) - 80usize];
    ["Offset of field: _GstVideoCodecFrame::user_data"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, user_data) - 88usize];
    ["Offset of field: _GstVideoCodecFrame::user_data_destroy_notify"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, user_data_destroy_notify) - 96usize];
    ["Offset of field: _GstVideoCodecFrame::abidata"]
        [::std::mem::offset_of!(_GstVideoCodecFrame, abidata) - 104usize];
};
unsafe extern "C" {
    pub fn gst_video_codec_state_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_codec_state_ref(state: *mut GstVideoCodecState) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_codec_state_unref(state: *mut GstVideoCodecState);
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_ref(frame: *mut GstVideoCodecFrame) -> *mut GstVideoCodecFrame;
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_unref(frame: *mut GstVideoCodecFrame);
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_set_user_data(
        frame: *mut GstVideoCodecFrame,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn gst_video_codec_frame_get_user_data(frame: *mut GstVideoCodecFrame) -> gpointer;
}
pub type GstVideoCodecFrame_autoptr = *mut GstVideoCodecFrame;
pub type GstVideoCodecFrame_listautoptr = *mut GList;
pub type GstVideoCodecFrame_slistautoptr = *mut GSList;
pub type GstVideoCodecFrame_queueautoptr = *mut GQueue;
pub type GstVideoCodecState_autoptr = *mut GstVideoCodecState;
pub type GstVideoCodecState_listautoptr = *mut GList;
pub type GstVideoCodecState_slistautoptr = *mut GSList;
pub type GstVideoCodecState_queueautoptr = *mut GQueue;
#[doc = " GstVideoDecoder:\n\n The opaque #GstVideoDecoder data structure."]
pub type GstVideoDecoder = _GstVideoDecoder;
#[doc = " GstVideoDecoderClass:\n @open:           Optional.\n                  Called when the element changes to GST_STATE_READY.\n                  Allows opening external resources.\n @close:          Optional.\n                  Called when the element changes to GST_STATE_NULL.\n                  Allows closing external resources.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @set_format:     Notifies subclass of incoming data format (caps).\n @parse:          Required for non-packetized input.\n                  Allows chopping incoming data into manageable units (frames)\n                  for subsequent decoding.\n @reset:          Optional.\n                  Allows subclass (decoder) to perform post-seek semantics reset.\n                  Deprecated.\n @handle_frame:   Provides input data frame to subclass. In subframe mode, the subclass needs\n                  to take ownership of @GstVideoCodecFrame.input_buffer as it will be modified\n                  by the base class on the next subframe buffer receiving.\n @finish:         Optional.\n                  Called to request subclass to dispatch any pending remaining\n                  data at EOS. Sub-classes can refuse to decode new data after.\n @drain:\t    Optional.\n                  Called to request subclass to decode any data it can at this\n                  point, but that more data may arrive after. (e.g. at segment end).\n                  Sub-classes should be prepared to handle new data afterward,\n                  or seamless segment processing will break. Since: 1.6\n @sink_event:     Optional.\n                  Event handler on the sink pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @src_event:      Optional.\n                  Event handler on the source pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @negotiate:      Optional.\n                  Negotiate with downstream and configure buffer pools, etc.\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @decide_allocation: Optional.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n                     Subclasses should chain up to the parent implementation to\n                     invoke the default handler.\n @propose_allocation: Optional.\n                      Propose buffer allocation parameters for upstream elements.\n                      Subclasses should chain up to the parent implementation to\n                      invoke the default handler.\n @flush:              Optional.\n                      Flush all remaining data from the decoder without\n                      pushing it downstream. Since: 1.2\n @sink_query:     Optional.\n                  Query handler on the sink pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @src_query:      Optional.\n                  Query handler on the source pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @getcaps:        Optional.\n                  Allows for a custom sink getcaps implementation.\n                  If not implemented, default returns\n                  gst_video_decoder_proxy_getcaps\n                  applied to sink template caps.\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method is copies all meta without\n                  tags and meta with only the \"video\" tag. subclasses can\n                  implement this method and return %TRUE if the metadata is to be\n                  copied. Since: 1.6\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum @handle_frame needs to be overridden, and @set_format\n and likely as well.  If non-packetized input is supported or expected,\n @parse needs to be overridden as well."]
pub type GstVideoDecoderClass = _GstVideoDecoderClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoDecoderPrivate {
    _unused: [u8; 0],
}
pub type GstVideoDecoderPrivate = _GstVideoDecoderPrivate;
unsafe extern "C" {
    pub fn _gst_video_decoder_error(
        dec: *mut GstVideoDecoder,
        weight: gint,
        domain: GQuark,
        code: gint,
        txt: *mut gchar,
        debug: *mut gchar,
        file: *const gchar,
        function: *const gchar,
        line: gint,
    ) -> GstFlowReturn;
}
#[doc = " GstVideoDecoder:\n\n The opaque #GstVideoDecoder data structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoDecoder {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub stream_lock: GRecMutex,
    pub input_segment: GstSegment,
    pub output_segment: GstSegment,
    pub priv_: *mut GstVideoDecoderPrivate,
    pub padding: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoDecoder"][::std::mem::size_of::<_GstVideoDecoder>() - 704usize];
    ["Alignment of _GstVideoDecoder"][::std::mem::align_of::<_GstVideoDecoder>() - 8usize];
    ["Offset of field: _GstVideoDecoder::element"]
        [::std::mem::offset_of!(_GstVideoDecoder, element) - 0usize];
    ["Offset of field: _GstVideoDecoder::sinkpad"]
        [::std::mem::offset_of!(_GstVideoDecoder, sinkpad) - 264usize];
    ["Offset of field: _GstVideoDecoder::srcpad"]
        [::std::mem::offset_of!(_GstVideoDecoder, srcpad) - 272usize];
    ["Offset of field: _GstVideoDecoder::stream_lock"]
        [::std::mem::offset_of!(_GstVideoDecoder, stream_lock) - 280usize];
    ["Offset of field: _GstVideoDecoder::input_segment"]
        [::std::mem::offset_of!(_GstVideoDecoder, input_segment) - 296usize];
    ["Offset of field: _GstVideoDecoder::output_segment"]
        [::std::mem::offset_of!(_GstVideoDecoder, output_segment) - 416usize];
    ["Offset of field: _GstVideoDecoder::priv_"]
        [::std::mem::offset_of!(_GstVideoDecoder, priv_) - 536usize];
    ["Offset of field: _GstVideoDecoder::padding"]
        [::std::mem::offset_of!(_GstVideoDecoder, padding) - 544usize];
};
#[doc = " GstVideoDecoderClass:\n @open:           Optional.\n                  Called when the element changes to GST_STATE_READY.\n                  Allows opening external resources.\n @close:          Optional.\n                  Called when the element changes to GST_STATE_NULL.\n                  Allows closing external resources.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @set_format:     Notifies subclass of incoming data format (caps).\n @parse:          Required for non-packetized input.\n                  Allows chopping incoming data into manageable units (frames)\n                  for subsequent decoding.\n @reset:          Optional.\n                  Allows subclass (decoder) to perform post-seek semantics reset.\n                  Deprecated.\n @handle_frame:   Provides input data frame to subclass. In subframe mode, the subclass needs\n                  to take ownership of @GstVideoCodecFrame.input_buffer as it will be modified\n                  by the base class on the next subframe buffer receiving.\n @finish:         Optional.\n                  Called to request subclass to dispatch any pending remaining\n                  data at EOS. Sub-classes can refuse to decode new data after.\n @drain:\t    Optional.\n                  Called to request subclass to decode any data it can at this\n                  point, but that more data may arrive after. (e.g. at segment end).\n                  Sub-classes should be prepared to handle new data afterward,\n                  or seamless segment processing will break. Since: 1.6\n @sink_event:     Optional.\n                  Event handler on the sink pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @src_event:      Optional.\n                  Event handler on the source pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @negotiate:      Optional.\n                  Negotiate with downstream and configure buffer pools, etc.\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @decide_allocation: Optional.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n                     Subclasses should chain up to the parent implementation to\n                     invoke the default handler.\n @propose_allocation: Optional.\n                      Propose buffer allocation parameters for upstream elements.\n                      Subclasses should chain up to the parent implementation to\n                      invoke the default handler.\n @flush:              Optional.\n                      Flush all remaining data from the decoder without\n                      pushing it downstream. Since: 1.2\n @sink_query:     Optional.\n                  Query handler on the sink pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @src_query:      Optional.\n                  Query handler on the source pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @getcaps:        Optional.\n                  Allows for a custom sink getcaps implementation.\n                  If not implemented, default returns\n                  gst_video_decoder_proxy_getcaps\n                  applied to sink template caps.\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method is copies all meta without\n                  tags and meta with only the \"video\" tag. subclasses can\n                  implement this method and return %TRUE if the metadata is to be\n                  copied. Since: 1.6\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum @handle_frame needs to be overridden, and @set_format\n and likely as well.  If non-packetized input is supported or expected,\n @parse needs to be overridden as well."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoDecoderClass {
    pub element_class: GstElementClass,
    pub open:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub close:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub stop:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub parse: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut GstVideoDecoder,
            frame: *mut GstVideoCodecFrame,
            adapter: *mut GstAdapter,
            at_eos: gboolean,
        ) -> GstFlowReturn,
    >,
    pub set_format: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut GstVideoDecoder,
            state: *mut GstVideoCodecState,
        ) -> gboolean,
    >,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, hard: gboolean) -> gboolean,
    >,
    pub finish:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> GstFlowReturn>,
    #[doc = " GstVideoDecoderClass::handle_frame:\n @decoder: The #GstVideoDecoder\n @frame: (transfer full): The frame to handle"]
    pub handle_frame: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut GstVideoDecoder,
            frame: *mut GstVideoCodecFrame,
        ) -> GstFlowReturn,
    >,
    pub sink_event: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, event: *mut GstEvent) -> gboolean,
    >,
    pub src_event: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, event: *mut GstEvent) -> gboolean,
    >,
    pub negotiate:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub decide_allocation: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, query: *mut GstQuery) -> gboolean,
    >,
    pub propose_allocation: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, query: *mut GstQuery) -> gboolean,
    >,
    pub flush:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> gboolean>,
    pub sink_query: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, query: *mut GstQuery) -> gboolean,
    >,
    pub src_query: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, query: *mut GstQuery) -> gboolean,
    >,
    pub getcaps: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut GstVideoDecoder, filter: *mut GstCaps) -> *mut GstCaps,
    >,
    pub drain:
        ::std::option::Option<unsafe extern "C" fn(decoder: *mut GstVideoDecoder) -> GstFlowReturn>,
    pub transform_meta: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut GstVideoDecoder,
            frame: *mut GstVideoCodecFrame,
            meta: *mut GstMeta,
        ) -> gboolean,
    >,
    #[doc = " GstVideoDecoderClass::handle_missing_data:\n @decoder: The #GstVideoDecoder\n @timestamp: Timestamp of the missing data\n @duration: Duration of the missing data\n\n Returns: %TRUE if the decoder should be drained afterwards.\n\n Since: 1.20"]
    pub handle_missing_data: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut GstVideoDecoder,
            timestamp: GstClockTime,
            duration: GstClockTime,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoDecoderClass"][::std::mem::size_of::<_GstVideoDecoderClass>() - 760usize];
    ["Alignment of _GstVideoDecoderClass"]
        [::std::mem::align_of::<_GstVideoDecoderClass>() - 8usize];
    ["Offset of field: _GstVideoDecoderClass::element_class"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, element_class) - 0usize];
    ["Offset of field: _GstVideoDecoderClass::open"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, open) - 488usize];
    ["Offset of field: _GstVideoDecoderClass::close"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, close) - 496usize];
    ["Offset of field: _GstVideoDecoderClass::start"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, start) - 504usize];
    ["Offset of field: _GstVideoDecoderClass::stop"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, stop) - 512usize];
    ["Offset of field: _GstVideoDecoderClass::parse"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, parse) - 520usize];
    ["Offset of field: _GstVideoDecoderClass::set_format"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, set_format) - 528usize];
    ["Offset of field: _GstVideoDecoderClass::reset"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, reset) - 536usize];
    ["Offset of field: _GstVideoDecoderClass::finish"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, finish) - 544usize];
    ["Offset of field: _GstVideoDecoderClass::handle_frame"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, handle_frame) - 552usize];
    ["Offset of field: _GstVideoDecoderClass::sink_event"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, sink_event) - 560usize];
    ["Offset of field: _GstVideoDecoderClass::src_event"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, src_event) - 568usize];
    ["Offset of field: _GstVideoDecoderClass::negotiate"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, negotiate) - 576usize];
    ["Offset of field: _GstVideoDecoderClass::decide_allocation"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, decide_allocation) - 584usize];
    ["Offset of field: _GstVideoDecoderClass::propose_allocation"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, propose_allocation) - 592usize];
    ["Offset of field: _GstVideoDecoderClass::flush"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, flush) - 600usize];
    ["Offset of field: _GstVideoDecoderClass::sink_query"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, sink_query) - 608usize];
    ["Offset of field: _GstVideoDecoderClass::src_query"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, src_query) - 616usize];
    ["Offset of field: _GstVideoDecoderClass::getcaps"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, getcaps) - 624usize];
    ["Offset of field: _GstVideoDecoderClass::drain"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, drain) - 632usize];
    ["Offset of field: _GstVideoDecoderClass::transform_meta"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, transform_meta) - 640usize];
    ["Offset of field: _GstVideoDecoderClass::handle_missing_data"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, handle_missing_data) - 648usize];
    ["Offset of field: _GstVideoDecoderClass::padding"]
        [::std::mem::offset_of!(_GstVideoDecoderClass, padding) - 656usize];
};
pub const GstVideoDecoderRequestSyncPointFlags_GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT : GstVideoDecoderRequestSyncPointFlags = 1 ;
pub const GstVideoDecoderRequestSyncPointFlags_GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT : GstVideoDecoderRequestSyncPointFlags = 2 ;
#[doc = " GstVideoDecoderRequestSyncPointFlags:\n @GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT: discard all following\n     input until the next sync point.\n @GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT: discard all following\n     output until the next sync point.\n\n Flags to be used in combination with gst_video_decoder_request_sync_point().\n See the function documentation for more details.\n\n Since: 1.20"]
pub type GstVideoDecoderRequestSyncPointFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_decoder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_packetized(decoder: *mut GstVideoDecoder, packetized: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_packetized(decoder: *mut GstVideoDecoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_subframe_mode(
        decoder: *mut GstVideoDecoder,
        subframe_mode: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_subframe_mode(decoder: *mut GstVideoDecoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_input_subframe_index(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_processed_subframe_index(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_estimate_rate(dec: *mut GstVideoDecoder, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_estimate_rate(dec: *mut GstVideoDecoder) -> gint;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_max_errors(dec: *mut GstVideoDecoder, num: gint);
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_max_errors(dec: *mut GstVideoDecoder) -> gint;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_needs_format(dec: *mut GstVideoDecoder, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_needs_format(dec: *mut GstVideoDecoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_needs_sync_point(dec: *mut GstVideoDecoder, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_needs_sync_point(dec: *mut GstVideoDecoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_latency(
        decoder: *mut GstVideoDecoder,
        min_latency: GstClockTime,
        max_latency: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_latency(
        decoder: *mut GstVideoDecoder,
        min_latency: *mut GstClockTime,
        max_latency: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_allocator(
        decoder: *mut GstVideoDecoder,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_buffer_pool(decoder: *mut GstVideoDecoder) -> *mut GstBufferPool;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_frame(
        decoder: *mut GstVideoDecoder,
        frame_number: ::std::os::raw::c_int,
    ) -> *mut GstVideoCodecFrame;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_oldest_frame(
        decoder: *mut GstVideoDecoder,
    ) -> *mut GstVideoCodecFrame;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_frames(decoder: *mut GstVideoDecoder) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_video_decoder_add_to_frame(
        decoder: *mut GstVideoDecoder,
        n_bytes: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_have_frame(decoder: *mut GstVideoDecoder) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_have_last_subframe(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_pending_frame_size(decoder: *mut GstVideoDecoder) -> gsize;
}
unsafe extern "C" {
    pub fn gst_video_decoder_allocate_output_buffer(
        decoder: *mut GstVideoDecoder,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_decoder_allocate_output_frame_with_params(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
        params: *mut GstBufferPoolAcquireParams,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_allocate_output_frame(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_output_state(
        decoder: *mut GstVideoDecoder,
        fmt: GstVideoFormat,
        width: guint,
        height: guint,
        reference: *mut GstVideoCodecState,
    ) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_interlaced_output_state(
        decoder: *mut GstVideoDecoder,
        fmt: GstVideoFormat,
        interlace_mode: GstVideoInterlaceMode,
        width: guint,
        height: guint,
        reference: *mut GstVideoCodecState,
    ) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_output_state(
        decoder: *mut GstVideoDecoder,
    ) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_decoder_negotiate(decoder: *mut GstVideoDecoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_max_decode_time(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstClockTimeDiff;
}
unsafe extern "C" {
    pub fn gst_video_decoder_get_qos_proportion(decoder: *mut GstVideoDecoder) -> gdouble;
}
unsafe extern "C" {
    pub fn gst_video_decoder_finish_frame(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_finish_subframe(
        decoder: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_drop_frame(
        dec: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_drop_subframe(
        dec: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_decoder_request_sync_point(
        dec: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
        flags: GstVideoDecoderRequestSyncPointFlags,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_release_frame(
        dec: *mut GstVideoDecoder,
        frame: *mut GstVideoCodecFrame,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_merge_tags(
        decoder: *mut GstVideoDecoder,
        tags: *const GstTagList,
        mode: GstTagMergeMode,
    );
}
unsafe extern "C" {
    pub fn gst_video_decoder_proxy_getcaps(
        decoder: *mut GstVideoDecoder,
        caps: *mut GstCaps,
        filter: *mut GstCaps,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_video_decoder_set_use_default_pad_acceptcaps(
        decoder: *mut GstVideoDecoder,
        use_: gboolean,
    );
}
pub type GstVideoDecoder_autoptr = *mut GstVideoDecoder;
pub type GstVideoDecoder_listautoptr = *mut GList;
pub type GstVideoDecoder_slistautoptr = *mut GSList;
pub type GstVideoDecoder_queueautoptr = *mut GQueue;
#[doc = " GstVideoEncoder:\n\n The opaque #GstVideoEncoder data structure."]
pub type GstVideoEncoder = _GstVideoEncoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoEncoderPrivate {
    _unused: [u8; 0],
}
pub type GstVideoEncoderPrivate = _GstVideoEncoderPrivate;
#[doc = " GstVideoEncoderClass:\n @open:           Optional.\n                  Called when the element changes to GST_STATE_READY.\n                  Allows opening external resources.\n @close:          Optional.\n                  Called when the element changes to GST_STATE_NULL.\n                  Allows closing external resources.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @set_format:     Optional.\n                  Notifies subclass of incoming data format.\n                  GstVideoCodecState fields have already been\n                  set according to provided caps.\n @handle_frame:   Provides input frame to subclass.\n @reset:          Optional.\n                  Allows subclass (encoder) to perform post-seek semantics reset.\n                  Deprecated.\n @finish:         Optional.\n                  Called to request subclass to dispatch any pending remaining\n                  data (e.g. at EOS).\n @pre_push:   Optional.\n                  Allows subclass to push frame downstream in whatever\n                  shape or form it deems appropriate.  If not provided,\n                  provided encoded frame data is simply pushed downstream.\n @getcaps:        Optional.\n                  Allows for a custom sink getcaps implementation (e.g.\n                  for multichannel input specification).  If not implemented,\n                  default returns gst_video_encoder_proxy_getcaps\n                  applied to sink template caps.\n @sink_event:     Optional.\n                  Event handler on the sink pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @src_event:      Optional.\n                  Event handler on the source pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @negotiate:      Optional.\n                  Negotiate with downstream and configure buffer pools, etc.\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @decide_allocation: Optional.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n                     Subclasses should chain up to the parent implementation to\n                     invoke the default handler.\n @propose_allocation: Optional.\n                      Propose buffer allocation parameters for upstream elements.\n                      Subclasses should chain up to the parent implementation to\n                      invoke the default handler.\n @flush:              Optional.\n                      Flush all remaining data from the encoder without\n                      pushing it downstream. Since: 1.2\n @sink_query:     Optional.\n                  Query handler on the sink pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @src_query:      Optional.\n                  Query handler on the source pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method is copies all meta without\n                  tags and meta with only the \"video\" tag. subclasses can\n                  implement this method and return %TRUE if the metadata is to be\n                  copied. Since: 1.6\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum @handle_frame needs to be overridden, and @set_format\n and @get_caps are likely needed as well."]
pub type GstVideoEncoderClass = _GstVideoEncoderClass;
#[doc = " GstVideoEncoder:\n\n The opaque #GstVideoEncoder data structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoEncoder {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub stream_lock: GRecMutex,
    pub input_segment: GstSegment,
    pub output_segment: GstSegment,
    pub priv_: *mut GstVideoEncoderPrivate,
    pub padding: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoEncoder"][::std::mem::size_of::<_GstVideoEncoder>() - 704usize];
    ["Alignment of _GstVideoEncoder"][::std::mem::align_of::<_GstVideoEncoder>() - 8usize];
    ["Offset of field: _GstVideoEncoder::element"]
        [::std::mem::offset_of!(_GstVideoEncoder, element) - 0usize];
    ["Offset of field: _GstVideoEncoder::sinkpad"]
        [::std::mem::offset_of!(_GstVideoEncoder, sinkpad) - 264usize];
    ["Offset of field: _GstVideoEncoder::srcpad"]
        [::std::mem::offset_of!(_GstVideoEncoder, srcpad) - 272usize];
    ["Offset of field: _GstVideoEncoder::stream_lock"]
        [::std::mem::offset_of!(_GstVideoEncoder, stream_lock) - 280usize];
    ["Offset of field: _GstVideoEncoder::input_segment"]
        [::std::mem::offset_of!(_GstVideoEncoder, input_segment) - 296usize];
    ["Offset of field: _GstVideoEncoder::output_segment"]
        [::std::mem::offset_of!(_GstVideoEncoder, output_segment) - 416usize];
    ["Offset of field: _GstVideoEncoder::priv_"]
        [::std::mem::offset_of!(_GstVideoEncoder, priv_) - 536usize];
    ["Offset of field: _GstVideoEncoder::padding"]
        [::std::mem::offset_of!(_GstVideoEncoder, padding) - 544usize];
};
#[doc = " GstVideoEncoderClass:\n @open:           Optional.\n                  Called when the element changes to GST_STATE_READY.\n                  Allows opening external resources.\n @close:          Optional.\n                  Called when the element changes to GST_STATE_NULL.\n                  Allows closing external resources.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @set_format:     Optional.\n                  Notifies subclass of incoming data format.\n                  GstVideoCodecState fields have already been\n                  set according to provided caps.\n @handle_frame:   Provides input frame to subclass.\n @reset:          Optional.\n                  Allows subclass (encoder) to perform post-seek semantics reset.\n                  Deprecated.\n @finish:         Optional.\n                  Called to request subclass to dispatch any pending remaining\n                  data (e.g. at EOS).\n @pre_push:   Optional.\n                  Allows subclass to push frame downstream in whatever\n                  shape or form it deems appropriate.  If not provided,\n                  provided encoded frame data is simply pushed downstream.\n @getcaps:        Optional.\n                  Allows for a custom sink getcaps implementation (e.g.\n                  for multichannel input specification).  If not implemented,\n                  default returns gst_video_encoder_proxy_getcaps\n                  applied to sink template caps.\n @sink_event:     Optional.\n                  Event handler on the sink pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @src_event:      Optional.\n                  Event handler on the source pad. This function should return\n                  TRUE if the event was handled and should be discarded\n                  (i.e. not unref'ed).\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @negotiate:      Optional.\n                  Negotiate with downstream and configure buffer pools, etc.\n                  Subclasses should chain up to the parent implementation to\n                  invoke the default handler.\n @decide_allocation: Optional.\n                     Setup the allocation parameters for allocating output\n                     buffers. The passed in query contains the result of the\n                     downstream allocation query.\n                     Subclasses should chain up to the parent implementation to\n                     invoke the default handler.\n @propose_allocation: Optional.\n                      Propose buffer allocation parameters for upstream elements.\n                      Subclasses should chain up to the parent implementation to\n                      invoke the default handler.\n @flush:              Optional.\n                      Flush all remaining data from the encoder without\n                      pushing it downstream. Since: 1.2\n @sink_query:     Optional.\n                  Query handler on the sink pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @src_query:      Optional.\n                  Query handler on the source pad. This function should\n                  return TRUE if the query could be performed. Subclasses\n                  should chain up to the parent implementation to invoke the\n                  default handler. Since: 1.4\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method is copies all meta without\n                  tags and meta with only the \"video\" tag. subclasses can\n                  implement this method and return %TRUE if the metadata is to be\n                  copied. Since: 1.6\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum @handle_frame needs to be overridden, and @set_format\n and @get_caps are likely needed as well."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoEncoderClass {
    pub element_class: GstElementClass,
    pub open:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub close:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub stop:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub set_format: ::std::option::Option<
        unsafe extern "C" fn(
            encoder: *mut GstVideoEncoder,
            state: *mut GstVideoCodecState,
        ) -> gboolean,
    >,
    pub handle_frame: ::std::option::Option<
        unsafe extern "C" fn(
            encoder: *mut GstVideoEncoder,
            frame: *mut GstVideoCodecFrame,
        ) -> GstFlowReturn,
    >,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, hard: gboolean) -> gboolean,
    >,
    pub finish:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> GstFlowReturn>,
    pub pre_push: ::std::option::Option<
        unsafe extern "C" fn(
            encoder: *mut GstVideoEncoder,
            frame: *mut GstVideoCodecFrame,
        ) -> GstFlowReturn,
    >,
    pub getcaps: ::std::option::Option<
        unsafe extern "C" fn(enc: *mut GstVideoEncoder, filter: *mut GstCaps) -> *mut GstCaps,
    >,
    pub sink_event: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, event: *mut GstEvent) -> gboolean,
    >,
    pub src_event: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, event: *mut GstEvent) -> gboolean,
    >,
    pub negotiate:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub decide_allocation: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, query: *mut GstQuery) -> gboolean,
    >,
    pub propose_allocation: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, query: *mut GstQuery) -> gboolean,
    >,
    pub flush:
        ::std::option::Option<unsafe extern "C" fn(encoder: *mut GstVideoEncoder) -> gboolean>,
    pub sink_query: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, query: *mut GstQuery) -> gboolean,
    >,
    pub src_query: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut GstVideoEncoder, query: *mut GstQuery) -> gboolean,
    >,
    pub transform_meta: ::std::option::Option<
        unsafe extern "C" fn(
            encoder: *mut GstVideoEncoder,
            frame: *mut GstVideoCodecFrame,
            meta: *mut GstMeta,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoEncoderClass"][::std::mem::size_of::<_GstVideoEncoderClass>() - 768usize];
    ["Alignment of _GstVideoEncoderClass"]
        [::std::mem::align_of::<_GstVideoEncoderClass>() - 8usize];
    ["Offset of field: _GstVideoEncoderClass::element_class"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, element_class) - 0usize];
    ["Offset of field: _GstVideoEncoderClass::open"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, open) - 488usize];
    ["Offset of field: _GstVideoEncoderClass::close"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, close) - 496usize];
    ["Offset of field: _GstVideoEncoderClass::start"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, start) - 504usize];
    ["Offset of field: _GstVideoEncoderClass::stop"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, stop) - 512usize];
    ["Offset of field: _GstVideoEncoderClass::set_format"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, set_format) - 520usize];
    ["Offset of field: _GstVideoEncoderClass::handle_frame"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, handle_frame) - 528usize];
    ["Offset of field: _GstVideoEncoderClass::reset"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, reset) - 536usize];
    ["Offset of field: _GstVideoEncoderClass::finish"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, finish) - 544usize];
    ["Offset of field: _GstVideoEncoderClass::pre_push"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, pre_push) - 552usize];
    ["Offset of field: _GstVideoEncoderClass::getcaps"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, getcaps) - 560usize];
    ["Offset of field: _GstVideoEncoderClass::sink_event"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, sink_event) - 568usize];
    ["Offset of field: _GstVideoEncoderClass::src_event"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, src_event) - 576usize];
    ["Offset of field: _GstVideoEncoderClass::negotiate"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, negotiate) - 584usize];
    ["Offset of field: _GstVideoEncoderClass::decide_allocation"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, decide_allocation) - 592usize];
    ["Offset of field: _GstVideoEncoderClass::propose_allocation"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, propose_allocation) - 600usize];
    ["Offset of field: _GstVideoEncoderClass::flush"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, flush) - 608usize];
    ["Offset of field: _GstVideoEncoderClass::sink_query"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, sink_query) - 616usize];
    ["Offset of field: _GstVideoEncoderClass::src_query"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, src_query) - 624usize];
    ["Offset of field: _GstVideoEncoderClass::transform_meta"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, transform_meta) - 632usize];
    ["Offset of field: _GstVideoEncoderClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoEncoderClass, _gst_reserved) - 640usize];
};
unsafe extern "C" {
    pub fn gst_video_encoder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_output_state(
        encoder: *mut GstVideoEncoder,
    ) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_output_state(
        encoder: *mut GstVideoEncoder,
        caps: *mut GstCaps,
        reference: *mut GstVideoCodecState,
    ) -> *mut GstVideoCodecState;
}
unsafe extern "C" {
    pub fn gst_video_encoder_negotiate(encoder: *mut GstVideoEncoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_frame(
        encoder: *mut GstVideoEncoder,
        frame_number: ::std::os::raw::c_int,
    ) -> *mut GstVideoCodecFrame;
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_oldest_frame(
        encoder: *mut GstVideoEncoder,
    ) -> *mut GstVideoCodecFrame;
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_frames(encoder: *mut GstVideoEncoder) -> *mut GList;
}
unsafe extern "C" {
    pub fn gst_video_encoder_allocate_output_buffer(
        encoder: *mut GstVideoEncoder,
        size: gsize,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_encoder_allocate_output_frame(
        encoder: *mut GstVideoEncoder,
        frame: *mut GstVideoCodecFrame,
        size: gsize,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_encoder_finish_frame(
        encoder: *mut GstVideoEncoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_encoder_finish_subframe(
        encoder: *mut GstVideoEncoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_video_encoder_proxy_getcaps(
        enc: *mut GstVideoEncoder,
        caps: *mut GstCaps,
        filter: *mut GstCaps,
    ) -> *mut GstCaps;
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_latency(
        encoder: *mut GstVideoEncoder,
        min_latency: GstClockTime,
        max_latency: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_latency(
        encoder: *mut GstVideoEncoder,
        min_latency: *mut GstClockTime,
        max_latency: *mut GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_headers(encoder: *mut GstVideoEncoder, headers: *mut GList);
}
unsafe extern "C" {
    pub fn gst_video_encoder_merge_tags(
        encoder: *mut GstVideoEncoder,
        tags: *const GstTagList,
        mode: GstTagMergeMode,
    );
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_allocator(
        encoder: *mut GstVideoEncoder,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_min_pts(encoder: *mut GstVideoEncoder, min_pts: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_qos_enabled(encoder: *mut GstVideoEncoder, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_encoder_is_qos_enabled(encoder: *mut GstVideoEncoder) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_max_encode_time(
        encoder: *mut GstVideoEncoder,
        frame: *mut GstVideoCodecFrame,
    ) -> GstClockTimeDiff;
}
unsafe extern "C" {
    pub fn gst_video_encoder_set_min_force_key_unit_interval(
        encoder: *mut GstVideoEncoder,
        interval: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_video_encoder_get_min_force_key_unit_interval(
        encoder: *mut GstVideoEncoder,
    ) -> GstClockTime;
}
pub type GstVideoEncoder_autoptr = *mut GstVideoEncoder;
pub type GstVideoEncoder_listautoptr = *mut GList;
pub type GstVideoEncoder_slistautoptr = *mut GSList;
pub type GstVideoEncoder_queueautoptr = *mut GQueue;
#[doc = " GstBaseTransform:\n\n The opaque #GstBaseTransform data structure."]
pub type GstBaseTransform = _GstBaseTransform;
#[doc = " GstBaseTransformClass:\n @parent_class:   Element parent class\n @passthrough_on_same_caps: If set to %TRUE, passthrough mode will be\n                            automatically enabled if the caps are the same.\n                            Set to %FALSE by default.\n @transform_ip_on_passthrough: If set to %TRUE, @transform_ip will be called in\n                           passthrough mode. The passed buffer might not be\n                           writable. When %FALSE, neither @transform nor\n                           @transform_ip will be called in passthrough mode.\n                           Set to %TRUE by default.\n @transform_caps: Optional.  Given the pad in this direction and the given\n                  caps, what caps are allowed on the other pad in this\n                  element ?\n @fixate_caps:    Optional. Given the pad in this direction and the given\n                  caps, fixate the caps on the other pad. The function takes\n                  ownership of @othercaps and returns a fixated version of\n                  @othercaps. @othercaps is not guaranteed to be writable.\n @accept_caps:    Optional.\n                  Subclasses can override this method to check if @caps can be\n                  handled by the element. The default implementation might not be\n                  the most optimal way to check this in all cases.\n @set_caps:       Allows the subclass to be notified of the actual caps set.\n @query:          Optional.\n                  Handle a requested query. Subclasses that implement this\n                  must chain up to the parent if they didn't handle the\n                  query\n @decide_allocation: Setup the allocation parameters for allocating output\n                    buffers. The passed in query contains the result of the\n                    downstream allocation query. This function is only called\n                    when not operating in passthrough mode. The default\n                    implementation will remove all memory dependent metadata.\n                    If there is a @filter_meta method implementation, it will\n                    be called for all metadata API in the downstream query,\n                    otherwise the metadata API is removed.\n @filter_meta: Return %TRUE if the metadata API should be proposed in the\n               upstream allocation query. The default implementation is %NULL\n               and will cause all metadata to be removed.\n @propose_allocation: Propose buffer allocation parameters for upstream elements.\n                      This function must be implemented if the element reads or\n                      writes the buffer content. The query that was passed to\n                      the decide_allocation is passed in this method (or %NULL\n                      when the element is in passthrough mode). The default\n                      implementation will pass the query downstream when in\n                      passthrough mode and will copy all the filtered metadata\n                      API in non-passthrough mode.\n @transform_size: Optional. Given the size of a buffer in the given direction\n                  with the given caps, calculate the size in bytes of a buffer\n                  on the other pad with the given other caps.\n                  The default implementation uses get_unit_size and keeps\n                  the number of units the same.\n @get_unit_size:  Required if the transform is not in-place.\n                  Get the size in bytes of one unit for the given caps.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @sink_event:     Optional.\n                  Event handler on the sink pad. The default implementation\n                  handles the event and forwards it downstream.\n @src_event:      Optional.\n                  Event handler on the source pad. The default implementation\n                  handles the event and forwards it upstream.\n @prepare_output_buffer: Optional.\n                         Subclasses can override this to do their own\n                         allocation of output buffers.  Elements that only do\n                         analysis can return a subbuffer or even just\n                         return a reference to the input buffer (if in\n                         passthrough mode). The default implementation will\n                         use the negotiated allocator or bufferpool and\n                         transform_size to allocate an output buffer or it\n                         will return the input buffer in passthrough mode.\n @copy_metadata: Optional.\n                 Copy the metadata from the input buffer to the output buffer.\n                 The default implementation will copy the flags, timestamps and\n                 offsets of the buffer.\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method copies all meta without\n                  tags. Subclasses can implement this method and return %TRUE if\n                  the metadata is to be copied.\n @before_transform: Optional.\n                    This method is called right before the base class will\n                    start processing. Dynamic properties or other delayed\n                    configuration could be performed in this method.\n @transform:      Required if the element does not operate in-place.\n                  Transforms one incoming buffer to one outgoing buffer.\n                  The function is allowed to change size/timestamp/duration\n                  of the outgoing buffer.\n @transform_ip:   Required if the element operates in-place.\n                  Transform the incoming buffer in-place.\n @submit_input_buffer: Function which accepts a new input buffer and pre-processes it.\n                  The default implementation performs caps (re)negotiation, then\n                  QoS if needed, and places the input buffer into the @queued_buf\n                  member variable. If the buffer is dropped due to QoS, it returns\n                  GST_BASE_TRANSFORM_FLOW_DROPPED. If this input buffer is not\n                  contiguous with any previous input buffer, then @is_discont\n                  is set to %TRUE. (Since: 1.6)\n @generate_output: Called after each new input buffer is submitted repeatedly\n                   until it either generates an error or fails to generate an output\n                   buffer. The default implementation takes the contents of the\n                   @queued_buf variable, generates an output buffer if needed\n                   by calling the class @prepare_output_buffer, and then\n                   calls either @transform or @transform_ip. Elements that don't\n                   do 1-to-1 transformations of input to output buffers can either\n                   return GST_BASE_TRANSFORM_FLOW_DROPPED or simply not generate\n                   an output buffer until they are ready to do so. (Since: 1.6)\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum either @transform or @transform_ip need to be overridden.\n If the element can overwrite the input data with the results (data is of the\n same type and quantity) it should provide @transform_ip."]
pub type GstBaseTransformClass = _GstBaseTransformClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBaseTransformPrivate {
    _unused: [u8; 0],
}
pub type GstBaseTransformPrivate = _GstBaseTransformPrivate;
#[doc = " GstBaseTransform:\n\n The opaque #GstBaseTransform data structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBaseTransform {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub have_segment: gboolean,
    pub segment: GstSegment,
    pub queued_buf: *mut GstBuffer,
    pub priv_: *mut GstBaseTransformPrivate,
    pub _gst_reserved: [gpointer; 19usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBaseTransform"][::std::mem::size_of::<_GstBaseTransform>() - 576usize];
    ["Alignment of _GstBaseTransform"][::std::mem::align_of::<_GstBaseTransform>() - 8usize];
    ["Offset of field: _GstBaseTransform::element"]
        [::std::mem::offset_of!(_GstBaseTransform, element) - 0usize];
    ["Offset of field: _GstBaseTransform::sinkpad"]
        [::std::mem::offset_of!(_GstBaseTransform, sinkpad) - 264usize];
    ["Offset of field: _GstBaseTransform::srcpad"]
        [::std::mem::offset_of!(_GstBaseTransform, srcpad) - 272usize];
    ["Offset of field: _GstBaseTransform::have_segment"]
        [::std::mem::offset_of!(_GstBaseTransform, have_segment) - 280usize];
    ["Offset of field: _GstBaseTransform::segment"]
        [::std::mem::offset_of!(_GstBaseTransform, segment) - 288usize];
    ["Offset of field: _GstBaseTransform::queued_buf"]
        [::std::mem::offset_of!(_GstBaseTransform, queued_buf) - 408usize];
    ["Offset of field: _GstBaseTransform::priv_"]
        [::std::mem::offset_of!(_GstBaseTransform, priv_) - 416usize];
    ["Offset of field: _GstBaseTransform::_gst_reserved"]
        [::std::mem::offset_of!(_GstBaseTransform, _gst_reserved) - 424usize];
};
#[doc = " GstBaseTransformClass:\n @parent_class:   Element parent class\n @passthrough_on_same_caps: If set to %TRUE, passthrough mode will be\n                            automatically enabled if the caps are the same.\n                            Set to %FALSE by default.\n @transform_ip_on_passthrough: If set to %TRUE, @transform_ip will be called in\n                           passthrough mode. The passed buffer might not be\n                           writable. When %FALSE, neither @transform nor\n                           @transform_ip will be called in passthrough mode.\n                           Set to %TRUE by default.\n @transform_caps: Optional.  Given the pad in this direction and the given\n                  caps, what caps are allowed on the other pad in this\n                  element ?\n @fixate_caps:    Optional. Given the pad in this direction and the given\n                  caps, fixate the caps on the other pad. The function takes\n                  ownership of @othercaps and returns a fixated version of\n                  @othercaps. @othercaps is not guaranteed to be writable.\n @accept_caps:    Optional.\n                  Subclasses can override this method to check if @caps can be\n                  handled by the element. The default implementation might not be\n                  the most optimal way to check this in all cases.\n @set_caps:       Allows the subclass to be notified of the actual caps set.\n @query:          Optional.\n                  Handle a requested query. Subclasses that implement this\n                  must chain up to the parent if they didn't handle the\n                  query\n @decide_allocation: Setup the allocation parameters for allocating output\n                    buffers. The passed in query contains the result of the\n                    downstream allocation query. This function is only called\n                    when not operating in passthrough mode. The default\n                    implementation will remove all memory dependent metadata.\n                    If there is a @filter_meta method implementation, it will\n                    be called for all metadata API in the downstream query,\n                    otherwise the metadata API is removed.\n @filter_meta: Return %TRUE if the metadata API should be proposed in the\n               upstream allocation query. The default implementation is %NULL\n               and will cause all metadata to be removed.\n @propose_allocation: Propose buffer allocation parameters for upstream elements.\n                      This function must be implemented if the element reads or\n                      writes the buffer content. The query that was passed to\n                      the decide_allocation is passed in this method (or %NULL\n                      when the element is in passthrough mode). The default\n                      implementation will pass the query downstream when in\n                      passthrough mode and will copy all the filtered metadata\n                      API in non-passthrough mode.\n @transform_size: Optional. Given the size of a buffer in the given direction\n                  with the given caps, calculate the size in bytes of a buffer\n                  on the other pad with the given other caps.\n                  The default implementation uses get_unit_size and keeps\n                  the number of units the same.\n @get_unit_size:  Required if the transform is not in-place.\n                  Get the size in bytes of one unit for the given caps.\n @start:          Optional.\n                  Called when the element starts processing.\n                  Allows opening external resources.\n @stop:           Optional.\n                  Called when the element stops processing.\n                  Allows closing external resources.\n @sink_event:     Optional.\n                  Event handler on the sink pad. The default implementation\n                  handles the event and forwards it downstream.\n @src_event:      Optional.\n                  Event handler on the source pad. The default implementation\n                  handles the event and forwards it upstream.\n @prepare_output_buffer: Optional.\n                         Subclasses can override this to do their own\n                         allocation of output buffers.  Elements that only do\n                         analysis can return a subbuffer or even just\n                         return a reference to the input buffer (if in\n                         passthrough mode). The default implementation will\n                         use the negotiated allocator or bufferpool and\n                         transform_size to allocate an output buffer or it\n                         will return the input buffer in passthrough mode.\n @copy_metadata: Optional.\n                 Copy the metadata from the input buffer to the output buffer.\n                 The default implementation will copy the flags, timestamps and\n                 offsets of the buffer.\n @transform_meta: Optional. Transform the metadata on the input buffer to the\n                  output buffer. By default this method copies all meta without\n                  tags. Subclasses can implement this method and return %TRUE if\n                  the metadata is to be copied.\n @before_transform: Optional.\n                    This method is called right before the base class will\n                    start processing. Dynamic properties or other delayed\n                    configuration could be performed in this method.\n @transform:      Required if the element does not operate in-place.\n                  Transforms one incoming buffer to one outgoing buffer.\n                  The function is allowed to change size/timestamp/duration\n                  of the outgoing buffer.\n @transform_ip:   Required if the element operates in-place.\n                  Transform the incoming buffer in-place.\n @submit_input_buffer: Function which accepts a new input buffer and pre-processes it.\n                  The default implementation performs caps (re)negotiation, then\n                  QoS if needed, and places the input buffer into the @queued_buf\n                  member variable. If the buffer is dropped due to QoS, it returns\n                  GST_BASE_TRANSFORM_FLOW_DROPPED. If this input buffer is not\n                  contiguous with any previous input buffer, then @is_discont\n                  is set to %TRUE. (Since: 1.6)\n @generate_output: Called after each new input buffer is submitted repeatedly\n                   until it either generates an error or fails to generate an output\n                   buffer. The default implementation takes the contents of the\n                   @queued_buf variable, generates an output buffer if needed\n                   by calling the class @prepare_output_buffer, and then\n                   calls either @transform or @transform_ip. Elements that don't\n                   do 1-to-1 transformations of input to output buffers can either\n                   return GST_BASE_TRANSFORM_FLOW_DROPPED or simply not generate\n                   an output buffer until they are ready to do so. (Since: 1.6)\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At minimum either @transform or @transform_ip need to be overridden.\n If the element can overwrite the input data with the results (data is of the\n same type and quantity) it should provide @transform_ip."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBaseTransformClass {
    pub parent_class: GstElementClass,
    pub passthrough_on_same_caps: gboolean,
    pub transform_ip_on_passthrough: gboolean,
    pub transform_caps: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            direction: GstPadDirection,
            caps: *mut GstCaps,
            filter: *mut GstCaps,
        ) -> *mut GstCaps,
    >,
    #[doc = " GstBaseTransformClass::fixate_caps:\n @othercaps: (transfer full):"]
    pub fixate_caps: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            direction: GstPadDirection,
            caps: *mut GstCaps,
            othercaps: *mut GstCaps,
        ) -> *mut GstCaps,
    >,
    pub accept_caps: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            direction: GstPadDirection,
            caps: *mut GstCaps,
        ) -> gboolean,
    >,
    pub set_caps: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            incaps: *mut GstCaps,
            outcaps: *mut GstCaps,
        ) -> gboolean,
    >,
    pub query: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            direction: GstPadDirection,
            query: *mut GstQuery,
        ) -> gboolean,
    >,
    pub decide_allocation: ::std::option::Option<
        unsafe extern "C" fn(trans: *mut GstBaseTransform, query: *mut GstQuery) -> gboolean,
    >,
    pub filter_meta: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            query: *mut GstQuery,
            api: GType,
            params: *const GstStructure,
        ) -> gboolean,
    >,
    pub propose_allocation: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            decide_query: *mut GstQuery,
            query: *mut GstQuery,
        ) -> gboolean,
    >,
    #[doc = " GstBaseTransformClass::transform_size:\n @othersize: (out):"]
    pub transform_size: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            direction: GstPadDirection,
            caps: *mut GstCaps,
            size: gsize,
            othercaps: *mut GstCaps,
            othersize: *mut gsize,
        ) -> gboolean,
    >,
    #[doc = " GstBaseTransformClass::get_unit_size:\n @size: (out):"]
    pub get_unit_size: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            caps: *mut GstCaps,
            size: *mut gsize,
        ) -> gboolean,
    >,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(trans: *mut GstBaseTransform) -> gboolean>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(trans: *mut GstBaseTransform) -> gboolean>,
    #[doc = " GstBaseTransformClass::sink_event:\n @event: (transfer full):"]
    pub sink_event: ::std::option::Option<
        unsafe extern "C" fn(trans: *mut GstBaseTransform, event: *mut GstEvent) -> gboolean,
    >,
    #[doc = " GstBaseTransformClass::src_event:\n @event: (transfer full):"]
    pub src_event: ::std::option::Option<
        unsafe extern "C" fn(trans: *mut GstBaseTransform, event: *mut GstEvent) -> gboolean,
    >,
    #[doc = " GstBaseTransformClass::prepare_output_buffer:\n @outbuf: (out):"]
    pub prepare_output_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            input: *mut GstBuffer,
            outbuf: *mut *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub copy_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            input: *mut GstBuffer,
            outbuf: *mut GstBuffer,
        ) -> gboolean,
    >,
    pub transform_meta: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            outbuf: *mut GstBuffer,
            meta: *mut GstMeta,
            inbuf: *mut GstBuffer,
        ) -> gboolean,
    >,
    pub before_transform: ::std::option::Option<
        unsafe extern "C" fn(trans: *mut GstBaseTransform, buffer: *mut GstBuffer),
    >,
    pub transform: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            inbuf: *mut GstBuffer,
            outbuf: *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub transform_ip: ::std::option::Option<
        unsafe extern "C" fn(trans: *mut GstBaseTransform, buf: *mut GstBuffer) -> GstFlowReturn,
    >,
    pub submit_input_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            is_discont: gboolean,
            input: *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    #[doc = " GstBaseTransformClass::generate_output:\n @outbuf: (out):"]
    pub generate_output: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstBaseTransform,
            outbuf: *mut *mut GstBuffer,
        ) -> GstFlowReturn,
    >,
    pub _gst_reserved: [gpointer; 18usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBaseTransformClass"][::std::mem::size_of::<_GstBaseTransformClass>() - 816usize];
    ["Alignment of _GstBaseTransformClass"]
        [::std::mem::align_of::<_GstBaseTransformClass>() - 8usize];
    ["Offset of field: _GstBaseTransformClass::parent_class"]
        [::std::mem::offset_of!(_GstBaseTransformClass, parent_class) - 0usize];
    ["Offset of field: _GstBaseTransformClass::passthrough_on_same_caps"]
        [::std::mem::offset_of!(_GstBaseTransformClass, passthrough_on_same_caps) - 488usize];
    ["Offset of field: _GstBaseTransformClass::transform_ip_on_passthrough"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform_ip_on_passthrough) - 492usize];
    ["Offset of field: _GstBaseTransformClass::transform_caps"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform_caps) - 496usize];
    ["Offset of field: _GstBaseTransformClass::fixate_caps"]
        [::std::mem::offset_of!(_GstBaseTransformClass, fixate_caps) - 504usize];
    ["Offset of field: _GstBaseTransformClass::accept_caps"]
        [::std::mem::offset_of!(_GstBaseTransformClass, accept_caps) - 512usize];
    ["Offset of field: _GstBaseTransformClass::set_caps"]
        [::std::mem::offset_of!(_GstBaseTransformClass, set_caps) - 520usize];
    ["Offset of field: _GstBaseTransformClass::query"]
        [::std::mem::offset_of!(_GstBaseTransformClass, query) - 528usize];
    ["Offset of field: _GstBaseTransformClass::decide_allocation"]
        [::std::mem::offset_of!(_GstBaseTransformClass, decide_allocation) - 536usize];
    ["Offset of field: _GstBaseTransformClass::filter_meta"]
        [::std::mem::offset_of!(_GstBaseTransformClass, filter_meta) - 544usize];
    ["Offset of field: _GstBaseTransformClass::propose_allocation"]
        [::std::mem::offset_of!(_GstBaseTransformClass, propose_allocation) - 552usize];
    ["Offset of field: _GstBaseTransformClass::transform_size"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform_size) - 560usize];
    ["Offset of field: _GstBaseTransformClass::get_unit_size"]
        [::std::mem::offset_of!(_GstBaseTransformClass, get_unit_size) - 568usize];
    ["Offset of field: _GstBaseTransformClass::start"]
        [::std::mem::offset_of!(_GstBaseTransformClass, start) - 576usize];
    ["Offset of field: _GstBaseTransformClass::stop"]
        [::std::mem::offset_of!(_GstBaseTransformClass, stop) - 584usize];
    ["Offset of field: _GstBaseTransformClass::sink_event"]
        [::std::mem::offset_of!(_GstBaseTransformClass, sink_event) - 592usize];
    ["Offset of field: _GstBaseTransformClass::src_event"]
        [::std::mem::offset_of!(_GstBaseTransformClass, src_event) - 600usize];
    ["Offset of field: _GstBaseTransformClass::prepare_output_buffer"]
        [::std::mem::offset_of!(_GstBaseTransformClass, prepare_output_buffer) - 608usize];
    ["Offset of field: _GstBaseTransformClass::copy_metadata"]
        [::std::mem::offset_of!(_GstBaseTransformClass, copy_metadata) - 616usize];
    ["Offset of field: _GstBaseTransformClass::transform_meta"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform_meta) - 624usize];
    ["Offset of field: _GstBaseTransformClass::before_transform"]
        [::std::mem::offset_of!(_GstBaseTransformClass, before_transform) - 632usize];
    ["Offset of field: _GstBaseTransformClass::transform"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform) - 640usize];
    ["Offset of field: _GstBaseTransformClass::transform_ip"]
        [::std::mem::offset_of!(_GstBaseTransformClass, transform_ip) - 648usize];
    ["Offset of field: _GstBaseTransformClass::submit_input_buffer"]
        [::std::mem::offset_of!(_GstBaseTransformClass, submit_input_buffer) - 656usize];
    ["Offset of field: _GstBaseTransformClass::generate_output"]
        [::std::mem::offset_of!(_GstBaseTransformClass, generate_output) - 664usize];
    ["Offset of field: _GstBaseTransformClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstBaseTransformClass, _gst_reserved) - 672usize];
};
unsafe extern "C" {
    pub fn gst_base_transform_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_base_transform_set_passthrough(trans: *mut GstBaseTransform, passthrough: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_transform_is_passthrough(trans: *mut GstBaseTransform) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_transform_set_in_place(trans: *mut GstBaseTransform, in_place: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_transform_is_in_place(trans: *mut GstBaseTransform) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_transform_update_qos(
        trans: *mut GstBaseTransform,
        proportion: gdouble,
        diff: GstClockTimeDiff,
        timestamp: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_base_transform_set_qos_enabled(trans: *mut GstBaseTransform, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_transform_is_qos_enabled(trans: *mut GstBaseTransform) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_transform_set_gap_aware(trans: *mut GstBaseTransform, gap_aware: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_transform_set_prefer_passthrough(
        trans: *mut GstBaseTransform,
        prefer_passthrough: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_base_transform_get_buffer_pool(trans: *mut GstBaseTransform) -> *mut GstBufferPool;
}
unsafe extern "C" {
    pub fn gst_base_transform_get_allocator(
        trans: *mut GstBaseTransform,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
}
unsafe extern "C" {
    pub fn gst_base_transform_reconfigure_sink(trans: *mut GstBaseTransform);
}
unsafe extern "C" {
    pub fn gst_base_transform_reconfigure_src(trans: *mut GstBaseTransform);
}
unsafe extern "C" {
    pub fn gst_base_transform_update_src_caps(
        trans: *mut GstBaseTransform,
        updated_caps: *mut GstCaps,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_transform_reconfigure(trans: *mut GstBaseTransform) -> gboolean;
}
pub type GstBaseTransform_autoptr = *mut GstBaseTransform;
pub type GstBaseTransform_listautoptr = *mut GList;
pub type GstBaseTransform_slistautoptr = *mut GSList;
pub type GstBaseTransform_queueautoptr = *mut GQueue;
pub type GstVideoFilter = _GstVideoFilter;
#[doc = " GstVideoFilterClass:\n @parent_class: the parent class structure\n @set_info: function to be called with the negotiated caps and video infos\n @transform_frame: transform a video frame\n @transform_frame_ip: transform a video frame in place\n\n The video filter class structure."]
pub type GstVideoFilterClass = _GstVideoFilterClass;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoFilter {
    pub element: GstBaseTransform,
    pub negotiated: gboolean,
    pub in_info: GstVideoInfo,
    pub out_info: GstVideoInfo,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoFilter"][::std::mem::size_of::<_GstVideoFilter>() - 920usize];
    ["Alignment of _GstVideoFilter"][::std::mem::align_of::<_GstVideoFilter>() - 8usize];
    ["Offset of field: _GstVideoFilter::element"]
        [::std::mem::offset_of!(_GstVideoFilter, element) - 0usize];
    ["Offset of field: _GstVideoFilter::negotiated"]
        [::std::mem::offset_of!(_GstVideoFilter, negotiated) - 576usize];
    ["Offset of field: _GstVideoFilter::in_info"]
        [::std::mem::offset_of!(_GstVideoFilter, in_info) - 584usize];
    ["Offset of field: _GstVideoFilter::out_info"]
        [::std::mem::offset_of!(_GstVideoFilter, out_info) - 736usize];
    ["Offset of field: _GstVideoFilter::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoFilter, _gst_reserved) - 888usize];
};
#[doc = " GstVideoFilterClass:\n @parent_class: the parent class structure\n @set_info: function to be called with the negotiated caps and video infos\n @transform_frame: transform a video frame\n @transform_frame_ip: transform a video frame in place\n\n The video filter class structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoFilterClass {
    pub parent_class: GstBaseTransformClass,
    pub set_info: ::std::option::Option<
        unsafe extern "C" fn(
            filter: *mut GstVideoFilter,
            incaps: *mut GstCaps,
            in_info: *mut GstVideoInfo,
            outcaps: *mut GstCaps,
            out_info: *mut GstVideoInfo,
        ) -> gboolean,
    >,
    pub transform_frame: ::std::option::Option<
        unsafe extern "C" fn(
            filter: *mut GstVideoFilter,
            inframe: *mut GstVideoFrame,
            outframe: *mut GstVideoFrame,
        ) -> GstFlowReturn,
    >,
    pub transform_frame_ip: ::std::option::Option<
        unsafe extern "C" fn(
            trans: *mut GstVideoFilter,
            frame: *mut GstVideoFrame,
        ) -> GstFlowReturn,
    >,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoFilterClass"][::std::mem::size_of::<_GstVideoFilterClass>() - 872usize];
    ["Alignment of _GstVideoFilterClass"][::std::mem::align_of::<_GstVideoFilterClass>() - 8usize];
    ["Offset of field: _GstVideoFilterClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoFilterClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoFilterClass::set_info"]
        [::std::mem::offset_of!(_GstVideoFilterClass, set_info) - 816usize];
    ["Offset of field: _GstVideoFilterClass::transform_frame"]
        [::std::mem::offset_of!(_GstVideoFilterClass, transform_frame) - 824usize];
    ["Offset of field: _GstVideoFilterClass::transform_frame_ip"]
        [::std::mem::offset_of!(_GstVideoFilterClass, transform_frame_ip) - 832usize];
    ["Offset of field: _GstVideoFilterClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoFilterClass, _gst_reserved) - 840usize];
};
unsafe extern "C" {
    pub fn gst_video_filter_get_type() -> GType;
}
pub type GstVideoFilter_autoptr = *mut GstVideoFilter;
pub type GstVideoFilter_listautoptr = *mut GList;
pub type GstVideoFilter_slistautoptr = *mut GSList;
pub type GstVideoFilter_queueautoptr = *mut GQueue;
#[doc = " GstVideoTimeCodeConfig:\n @fps_n: Numerator of the frame rate\n @fps_d: Denominator of the frame rate\n @flags: the corresponding #GstVideoTimeCodeFlags\n @latest_daily_jam: The latest daily jam information, if present, or NULL\n\n Supported frame rates: 30000/1001, 60000/1001 (both with and without drop\n frame), and integer frame rates e.g. 25/1, 30/1, 50/1, 60/1.\n\n The configuration of the time code.\n\n Since: 1.10"]
pub type GstVideoTimeCodeConfig = _GstVideoTimeCodeConfig;
#[doc = " GstVideoTimeCode:\n @hours: the hours field of #GstVideoTimeCode\n @minutes: the minutes field of #GstVideoTimeCode\n @seconds: the seconds field of #GstVideoTimeCode\n @frames: the frames field of #GstVideoTimeCode\n @field_count: Interlaced video field count\n @config: the corresponding #GstVideoTimeCodeConfig\n\n @field_count must be 0 for progressive video and 1 or 2 for interlaced.\n\n A representation of a SMPTE time code.\n\n @hours must be positive and less than 24. Will wrap around otherwise.\n @minutes and @seconds must be positive and less than 60.\n @frames must be less than or equal to @config.fps_n / @config.fps_d\n These values are *NOT* automatically normalized.\n\n Since: 1.10"]
pub type GstVideoTimeCode = _GstVideoTimeCode;
#[doc = " GstVideoTimeCodeInterval:\n @hours: the hours field of #GstVideoTimeCodeInterval\n @minutes: the minutes field of #GstVideoTimeCodeInterval\n @seconds: the seconds field of #GstVideoTimeCodeInterval\n @frames: the frames field of #GstVideoTimeCodeInterval\n\n A representation of a difference between two #GstVideoTimeCode instances.\n Will not necessarily correspond to a real timecode (e.g. 00:00:10;00)\n\n Since: 1.12"]
pub type GstVideoTimeCodeInterval = _GstVideoTimeCodeInterval;
pub const GstVideoTimeCodeFlags_GST_VIDEO_TIME_CODE_FLAGS_NONE: GstVideoTimeCodeFlags = 0;
pub const GstVideoTimeCodeFlags_GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME: GstVideoTimeCodeFlags = 1;
pub const GstVideoTimeCodeFlags_GST_VIDEO_TIME_CODE_FLAGS_INTERLACED: GstVideoTimeCodeFlags = 2;
#[doc = " GstVideoTimeCodeFlags:\n @GST_VIDEO_TIME_CODE_FLAGS_NONE: No flags\n @GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME: Whether we have drop frame rate\n @GST_VIDEO_TIME_CODE_FLAGS_INTERLACED: Whether we have interlaced video\n\n Flags related to the time code information.\n For drop frame, only 30000/1001 and 60000/1001 frame rates are supported.\n\n Since: 1.10"]
pub type GstVideoTimeCodeFlags = ::std::os::raw::c_uint;
#[doc = " GstVideoTimeCodeConfig:\n @fps_n: Numerator of the frame rate\n @fps_d: Denominator of the frame rate\n @flags: the corresponding #GstVideoTimeCodeFlags\n @latest_daily_jam: The latest daily jam information, if present, or NULL\n\n Supported frame rates: 30000/1001, 60000/1001 (both with and without drop\n frame), and integer frame rates e.g. 25/1, 30/1, 50/1, 60/1.\n\n The configuration of the time code.\n\n Since: 1.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoTimeCodeConfig {
    pub fps_n: guint,
    pub fps_d: guint,
    pub flags: GstVideoTimeCodeFlags,
    pub latest_daily_jam: *mut GDateTime,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoTimeCodeConfig"][::std::mem::size_of::<_GstVideoTimeCodeConfig>() - 24usize];
    ["Alignment of _GstVideoTimeCodeConfig"]
        [::std::mem::align_of::<_GstVideoTimeCodeConfig>() - 8usize];
    ["Offset of field: _GstVideoTimeCodeConfig::fps_n"]
        [::std::mem::offset_of!(_GstVideoTimeCodeConfig, fps_n) - 0usize];
    ["Offset of field: _GstVideoTimeCodeConfig::fps_d"]
        [::std::mem::offset_of!(_GstVideoTimeCodeConfig, fps_d) - 4usize];
    ["Offset of field: _GstVideoTimeCodeConfig::flags"]
        [::std::mem::offset_of!(_GstVideoTimeCodeConfig, flags) - 8usize];
    ["Offset of field: _GstVideoTimeCodeConfig::latest_daily_jam"]
        [::std::mem::offset_of!(_GstVideoTimeCodeConfig, latest_daily_jam) - 16usize];
};
#[doc = " GstVideoTimeCode:\n @hours: the hours field of #GstVideoTimeCode\n @minutes: the minutes field of #GstVideoTimeCode\n @seconds: the seconds field of #GstVideoTimeCode\n @frames: the frames field of #GstVideoTimeCode\n @field_count: Interlaced video field count\n @config: the corresponding #GstVideoTimeCodeConfig\n\n @field_count must be 0 for progressive video and 1 or 2 for interlaced.\n\n A representation of a SMPTE time code.\n\n @hours must be positive and less than 24. Will wrap around otherwise.\n @minutes and @seconds must be positive and less than 60.\n @frames must be less than or equal to @config.fps_n / @config.fps_d\n These values are *NOT* automatically normalized.\n\n Since: 1.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoTimeCode {
    pub config: GstVideoTimeCodeConfig,
    pub hours: guint,
    pub minutes: guint,
    pub seconds: guint,
    pub frames: guint,
    pub field_count: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoTimeCode"][::std::mem::size_of::<_GstVideoTimeCode>() - 48usize];
    ["Alignment of _GstVideoTimeCode"][::std::mem::align_of::<_GstVideoTimeCode>() - 8usize];
    ["Offset of field: _GstVideoTimeCode::config"]
        [::std::mem::offset_of!(_GstVideoTimeCode, config) - 0usize];
    ["Offset of field: _GstVideoTimeCode::hours"]
        [::std::mem::offset_of!(_GstVideoTimeCode, hours) - 24usize];
    ["Offset of field: _GstVideoTimeCode::minutes"]
        [::std::mem::offset_of!(_GstVideoTimeCode, minutes) - 28usize];
    ["Offset of field: _GstVideoTimeCode::seconds"]
        [::std::mem::offset_of!(_GstVideoTimeCode, seconds) - 32usize];
    ["Offset of field: _GstVideoTimeCode::frames"]
        [::std::mem::offset_of!(_GstVideoTimeCode, frames) - 36usize];
    ["Offset of field: _GstVideoTimeCode::field_count"]
        [::std::mem::offset_of!(_GstVideoTimeCode, field_count) - 40usize];
};
#[doc = " GstVideoTimeCodeInterval:\n @hours: the hours field of #GstVideoTimeCodeInterval\n @minutes: the minutes field of #GstVideoTimeCodeInterval\n @seconds: the seconds field of #GstVideoTimeCodeInterval\n @frames: the frames field of #GstVideoTimeCodeInterval\n\n A representation of a difference between two #GstVideoTimeCode instances.\n Will not necessarily correspond to a real timecode (e.g. 00:00:10;00)\n\n Since: 1.12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoTimeCodeInterval {
    pub hours: guint,
    pub minutes: guint,
    pub seconds: guint,
    pub frames: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoTimeCodeInterval"]
        [::std::mem::size_of::<_GstVideoTimeCodeInterval>() - 16usize];
    ["Alignment of _GstVideoTimeCodeInterval"]
        [::std::mem::align_of::<_GstVideoTimeCodeInterval>() - 4usize];
    ["Offset of field: _GstVideoTimeCodeInterval::hours"]
        [::std::mem::offset_of!(_GstVideoTimeCodeInterval, hours) - 0usize];
    ["Offset of field: _GstVideoTimeCodeInterval::minutes"]
        [::std::mem::offset_of!(_GstVideoTimeCodeInterval, minutes) - 4usize];
    ["Offset of field: _GstVideoTimeCodeInterval::seconds"]
        [::std::mem::offset_of!(_GstVideoTimeCodeInterval, seconds) - 8usize];
    ["Offset of field: _GstVideoTimeCodeInterval::frames"]
        [::std::mem::offset_of!(_GstVideoTimeCodeInterval, frames) - 12usize];
};
unsafe extern "C" {
    pub fn gst_video_time_code_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_time_code_new(
        fps_n: guint,
        fps_d: guint,
        latest_daily_jam: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        hours: guint,
        minutes: guint,
        seconds: guint,
        frames: guint,
        field_count: guint,
    ) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_new_empty() -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_new_from_string(tc_str: *const gchar) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_new_from_date_time(
        fps_n: guint,
        fps_d: guint,
        dt: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        field_count: guint,
    ) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_new_from_date_time_full(
        fps_n: guint,
        fps_d: guint,
        dt: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        field_count: guint,
    ) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_free(tc: *mut GstVideoTimeCode);
}
unsafe extern "C" {
    pub fn gst_video_time_code_copy(tc: *const GstVideoTimeCode) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_init(
        tc: *mut GstVideoTimeCode,
        fps_n: guint,
        fps_d: guint,
        latest_daily_jam: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        hours: guint,
        minutes: guint,
        seconds: guint,
        frames: guint,
        field_count: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_time_code_init_from_date_time(
        tc: *mut GstVideoTimeCode,
        fps_n: guint,
        fps_d: guint,
        dt: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        field_count: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_time_code_init_from_date_time_full(
        tc: *mut GstVideoTimeCode,
        fps_n: guint,
        fps_d: guint,
        dt: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        field_count: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_time_code_clear(tc: *mut GstVideoTimeCode);
}
unsafe extern "C" {
    pub fn gst_video_time_code_is_valid(tc: *const GstVideoTimeCode) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_time_code_compare(
        tc1: *const GstVideoTimeCode,
        tc2: *const GstVideoTimeCode,
    ) -> gint;
}
unsafe extern "C" {
    pub fn gst_video_time_code_increment_frame(tc: *mut GstVideoTimeCode);
}
unsafe extern "C" {
    pub fn gst_video_time_code_add_frames(tc: *mut GstVideoTimeCode, frames: gint64);
}
unsafe extern "C" {
    pub fn gst_video_time_code_to_string(tc: *const GstVideoTimeCode) -> *mut gchar;
}
unsafe extern "C" {
    pub fn gst_video_time_code_to_date_time(tc: *const GstVideoTimeCode) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn gst_video_time_code_nsec_since_daily_jam(tc: *const GstVideoTimeCode) -> guint64;
}
unsafe extern "C" {
    pub fn gst_video_time_code_frames_since_daily_jam(tc: *const GstVideoTimeCode) -> guint64;
}
unsafe extern "C" {
    pub fn gst_video_time_code_add_interval(
        tc: *const GstVideoTimeCode,
        tc_inter: *const GstVideoTimeCodeInterval,
    ) -> *mut GstVideoTimeCode;
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_new(
        hours: guint,
        minutes: guint,
        seconds: guint,
        frames: guint,
    ) -> *mut GstVideoTimeCodeInterval;
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_new_from_string(
        tc_inter_str: *const gchar,
    ) -> *mut GstVideoTimeCodeInterval;
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_free(tc: *mut GstVideoTimeCodeInterval);
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_copy(
        tc: *const GstVideoTimeCodeInterval,
    ) -> *mut GstVideoTimeCodeInterval;
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_init(
        tc: *mut GstVideoTimeCodeInterval,
        hours: guint,
        minutes: guint,
        seconds: guint,
        frames: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_time_code_interval_clear(tc: *mut GstVideoTimeCodeInterval);
}
#[doc = " GstVideoMeta:\n @meta: parent #GstMeta\n @buffer: the buffer this metadata belongs to\n @flags: additional video flags\n @format: the video format\n @id: identifier of the frame\n @width: the video width\n @height: the video height\n @n_planes: the number of planes in the image\n @offset: array of offsets for the planes. This field might not always be\n          valid, it is used by the default implementation of @map.\n @stride: array of strides for the planes. This field might not always be\n          valid, it is used by the default implementation of @map.\n @map: map the memory of a plane\n @unmap: unmap the memory of a plane\n @alignment: the paddings and alignment constraints of the video buffer.\n It is up to the caller of `gst_buffer_add_video_meta_full()` to set it\n using gst_video_meta_set_alignment(), if they did not it defaults\n to no padding and no alignment. Since: 1.18\n\n Extra buffer metadata describing image properties\n\n This meta can also be used by downstream elements to specifiy their\n buffer layout requirements for upstream. Upstream should try to\n fit those requirements, if possible, in order to prevent buffer copies.\n\n This is done by passing a custom #GstStructure to\n gst_query_add_allocation_meta() when handling the ALLOCATION query.\n This structure should be named 'video-meta' and can have the following\n fields:\n - padding-top (uint): extra pixels on the top\n - padding-bottom (uint): extra pixels on the bottom\n - padding-left (uint): extra pixels on the left side\n - padding-right (uint): extra pixels on the right side\n The padding fields have the same semantic as #GstVideoMeta.alignment\n and so represent the paddings requested on produced video buffers."]
pub type GstVideoMeta = _GstVideoMeta;
#[doc = " GstVideoCropMeta:\n @meta: parent #GstMeta\n @x: the horizontal offset\n @y: the vertical offset\n @width: the cropped width\n @height: the cropped height\n\n Extra buffer metadata describing image cropping."]
pub type GstVideoCropMeta = _GstVideoCropMeta;
#[doc = " GstVideoMeta:\n @meta: parent #GstMeta\n @buffer: the buffer this metadata belongs to\n @flags: additional video flags\n @format: the video format\n @id: identifier of the frame\n @width: the video width\n @height: the video height\n @n_planes: the number of planes in the image\n @offset: array of offsets for the planes. This field might not always be\n          valid, it is used by the default implementation of @map.\n @stride: array of strides for the planes. This field might not always be\n          valid, it is used by the default implementation of @map.\n @map: map the memory of a plane\n @unmap: unmap the memory of a plane\n @alignment: the paddings and alignment constraints of the video buffer.\n It is up to the caller of `gst_buffer_add_video_meta_full()` to set it\n using gst_video_meta_set_alignment(), if they did not it defaults\n to no padding and no alignment. Since: 1.18\n\n Extra buffer metadata describing image properties\n\n This meta can also be used by downstream elements to specifiy their\n buffer layout requirements for upstream. Upstream should try to\n fit those requirements, if possible, in order to prevent buffer copies.\n\n This is done by passing a custom #GstStructure to\n gst_query_add_allocation_meta() when handling the ALLOCATION query.\n This structure should be named 'video-meta' and can have the following\n fields:\n - padding-top (uint): extra pixels on the top\n - padding-bottom (uint): extra pixels on the bottom\n - padding-left (uint): extra pixels on the left side\n - padding-right (uint): extra pixels on the right side\n The padding fields have the same semantic as #GstVideoMeta.alignment\n and so represent the paddings requested on produced video buffers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoMeta {
    pub meta: GstMeta,
    pub buffer: *mut GstBuffer,
    pub flags: GstVideoFrameFlags,
    pub format: GstVideoFormat,
    pub id: gint,
    pub width: guint,
    pub height: guint,
    pub n_planes: guint,
    pub offset: [gsize; 4usize],
    pub stride: [gint; 4usize],
    pub map: ::std::option::Option<
        unsafe extern "C" fn(
            meta: *mut GstVideoMeta,
            plane: guint,
            info: *mut GstMapInfo,
            data: *mut gpointer,
            stride: *mut gint,
            flags: GstMapFlags,
        ) -> gboolean,
    >,
    pub unmap: ::std::option::Option<
        unsafe extern "C" fn(
            meta: *mut GstVideoMeta,
            plane: guint,
            info: *mut GstMapInfo,
        ) -> gboolean,
    >,
    pub alignment: GstVideoAlignment,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoMeta"][::std::mem::size_of::<_GstVideoMeta>() - 144usize];
    ["Alignment of _GstVideoMeta"][::std::mem::align_of::<_GstVideoMeta>() - 8usize];
    ["Offset of field: _GstVideoMeta::meta"][::std::mem::offset_of!(_GstVideoMeta, meta) - 0usize];
    ["Offset of field: _GstVideoMeta::buffer"]
        [::std::mem::offset_of!(_GstVideoMeta, buffer) - 16usize];
    ["Offset of field: _GstVideoMeta::flags"]
        [::std::mem::offset_of!(_GstVideoMeta, flags) - 24usize];
    ["Offset of field: _GstVideoMeta::format"]
        [::std::mem::offset_of!(_GstVideoMeta, format) - 28usize];
    ["Offset of field: _GstVideoMeta::id"][::std::mem::offset_of!(_GstVideoMeta, id) - 32usize];
    ["Offset of field: _GstVideoMeta::width"]
        [::std::mem::offset_of!(_GstVideoMeta, width) - 36usize];
    ["Offset of field: _GstVideoMeta::height"]
        [::std::mem::offset_of!(_GstVideoMeta, height) - 40usize];
    ["Offset of field: _GstVideoMeta::n_planes"]
        [::std::mem::offset_of!(_GstVideoMeta, n_planes) - 44usize];
    ["Offset of field: _GstVideoMeta::offset"]
        [::std::mem::offset_of!(_GstVideoMeta, offset) - 48usize];
    ["Offset of field: _GstVideoMeta::stride"]
        [::std::mem::offset_of!(_GstVideoMeta, stride) - 80usize];
    ["Offset of field: _GstVideoMeta::map"][::std::mem::offset_of!(_GstVideoMeta, map) - 96usize];
    ["Offset of field: _GstVideoMeta::unmap"]
        [::std::mem::offset_of!(_GstVideoMeta, unmap) - 104usize];
    ["Offset of field: _GstVideoMeta::alignment"]
        [::std::mem::offset_of!(_GstVideoMeta, alignment) - 112usize];
};
unsafe extern "C" {
    pub fn gst_video_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_get_video_meta(buffer: *mut GstBuffer) -> *mut GstVideoMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_get_video_meta_id(buffer: *mut GstBuffer, id: gint) -> *mut GstVideoMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_meta(
        buffer: *mut GstBuffer,
        flags: GstVideoFrameFlags,
        format: GstVideoFormat,
        width: guint,
        height: guint,
    ) -> *mut GstVideoMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_meta_full(
        buffer: *mut GstBuffer,
        flags: GstVideoFrameFlags,
        format: GstVideoFormat,
        width: guint,
        height: guint,
        n_planes: guint,
        offset: *mut gsize,
        stride: *mut gint,
    ) -> *mut GstVideoMeta;
}
unsafe extern "C" {
    pub fn gst_video_meta_map(
        meta: *mut GstVideoMeta,
        plane: guint,
        info: *mut GstMapInfo,
        data: *mut gpointer,
        stride: *mut gint,
        flags: GstMapFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_meta_unmap(
        meta: *mut GstVideoMeta,
        plane: guint,
        info: *mut GstMapInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_meta_set_alignment(
        meta: *mut GstVideoMeta,
        alignment: GstVideoAlignment,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_meta_get_plane_size(
        meta: *mut GstVideoMeta,
        plane_size: *mut gsize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_meta_get_plane_height(
        meta: *mut GstVideoMeta,
        plane_height: *mut guint,
    ) -> gboolean;
}
#[doc = " GstVideoCropMeta:\n @meta: parent #GstMeta\n @x: the horizontal offset\n @y: the vertical offset\n @width: the cropped width\n @height: the cropped height\n\n Extra buffer metadata describing image cropping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoCropMeta {
    pub meta: GstMeta,
    pub x: guint,
    pub y: guint,
    pub width: guint,
    pub height: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoCropMeta"][::std::mem::size_of::<_GstVideoCropMeta>() - 32usize];
    ["Alignment of _GstVideoCropMeta"][::std::mem::align_of::<_GstVideoCropMeta>() - 8usize];
    ["Offset of field: _GstVideoCropMeta::meta"]
        [::std::mem::offset_of!(_GstVideoCropMeta, meta) - 0usize];
    ["Offset of field: _GstVideoCropMeta::x"]
        [::std::mem::offset_of!(_GstVideoCropMeta, x) - 16usize];
    ["Offset of field: _GstVideoCropMeta::y"]
        [::std::mem::offset_of!(_GstVideoCropMeta, y) - 20usize];
    ["Offset of field: _GstVideoCropMeta::width"]
        [::std::mem::offset_of!(_GstVideoCropMeta, width) - 24usize];
    ["Offset of field: _GstVideoCropMeta::height"]
        [::std::mem::offset_of!(_GstVideoCropMeta, height) - 28usize];
};
unsafe extern "C" {
    pub fn gst_video_crop_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_crop_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_video_meta_transform_scale_get_quark() -> GQuark;
}
#[doc = " GstVideoMetaTransform:\n @in_info: the input #GstVideoInfo\n @out_info: the output #GstVideoInfo\n\n Extra data passed to a video transform #GstMetaTransformFunction such as:\n \"gst-video-scale\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoMetaTransform {
    pub in_info: *mut GstVideoInfo,
    pub out_info: *mut GstVideoInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoMetaTransform"][::std::mem::size_of::<GstVideoMetaTransform>() - 16usize];
    ["Alignment of GstVideoMetaTransform"]
        [::std::mem::align_of::<GstVideoMetaTransform>() - 8usize];
    ["Offset of field: GstVideoMetaTransform::in_info"]
        [::std::mem::offset_of!(GstVideoMetaTransform, in_info) - 0usize];
    ["Offset of field: GstVideoMetaTransform::out_info"]
        [::std::mem::offset_of!(GstVideoMetaTransform, out_info) - 8usize];
};
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE: GstVideoGLTextureType = 0;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE_ALPHA: GstVideoGLTextureType =
    1;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_RGB16: GstVideoGLTextureType = 2;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_RGB: GstVideoGLTextureType = 3;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_RGBA: GstVideoGLTextureType = 4;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_R: GstVideoGLTextureType = 5;
pub const GstVideoGLTextureType_GST_VIDEO_GL_TEXTURE_TYPE_RG: GstVideoGLTextureType = 6;
#[doc = " GstVideoGLTextureType:\n @GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE: Luminance texture, GL_LUMINANCE\n @GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE_ALPHA: Luminance-alpha texture, GL_LUMINANCE_ALPHA\n @GST_VIDEO_GL_TEXTURE_TYPE_RGB16: RGB 565 texture, GL_RGB\n @GST_VIDEO_GL_TEXTURE_TYPE_RGB: RGB texture, GL_RGB\n @GST_VIDEO_GL_TEXTURE_TYPE_RGBA: RGBA texture, GL_RGBA\n @GST_VIDEO_GL_TEXTURE_TYPE_R: R texture, GL_RED_EXT\n @GST_VIDEO_GL_TEXTURE_TYPE_RG: RG texture, GL_RG_EXT\n\n The GL texture type."]
pub type GstVideoGLTextureType = ::std::os::raw::c_uint;
pub const GstVideoGLTextureOrientation_GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_NORMAL:
    GstVideoGLTextureOrientation = 0;
pub const GstVideoGLTextureOrientation_GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP:
    GstVideoGLTextureOrientation = 1;
pub const GstVideoGLTextureOrientation_GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_NORMAL:
    GstVideoGLTextureOrientation = 2;
pub const GstVideoGLTextureOrientation_GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_FLIP:
    GstVideoGLTextureOrientation = 3;
#[doc = " GstVideoGLTextureOrientation:\n @GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_NORMAL: Top line first in memory, left row first\n @GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP: Bottom line first in memory, left row first\n @GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_NORMAL: Top line first in memory, right row first\n @GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_FLIP: Bottom line first in memory, right row first\n\n The orientation of the GL texture."]
pub type GstVideoGLTextureOrientation = ::std::os::raw::c_uint;
#[doc = " GstVideoGLTextureUploadMeta:\n @meta: parent #GstMeta\n @texture_orientation: Orientation of the textures\n @n_textures: Number of textures that are generated\n @texture_type: Type of each texture\n\n Extra buffer metadata for uploading a buffer to an OpenGL texture\n ID. The caller of gst_video_gl_texture_upload_meta_upload() must\n have OpenGL set up and call this from a thread where it is valid\n to upload something to an OpenGL texture."]
pub type GstVideoGLTextureUploadMeta = _GstVideoGLTextureUploadMeta;
pub type GstVideoGLTextureUpload = ::std::option::Option<
    unsafe extern "C" fn(
        meta: *mut GstVideoGLTextureUploadMeta,
        texture_id: *mut guint,
    ) -> gboolean,
>;
#[doc = " GstVideoGLTextureUploadMeta:\n @meta: parent #GstMeta\n @texture_orientation: Orientation of the textures\n @n_textures: Number of textures that are generated\n @texture_type: Type of each texture\n\n Extra buffer metadata for uploading a buffer to an OpenGL texture\n ID. The caller of gst_video_gl_texture_upload_meta_upload() must\n have OpenGL set up and call this from a thread where it is valid\n to upload something to an OpenGL texture."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoGLTextureUploadMeta {
    pub meta: GstMeta,
    pub texture_orientation: GstVideoGLTextureOrientation,
    pub n_textures: guint,
    pub texture_type: [GstVideoGLTextureType; 4usize],
    pub buffer: *mut GstBuffer,
    pub upload: GstVideoGLTextureUpload,
    pub user_data: gpointer,
    pub user_data_copy: GBoxedCopyFunc,
    pub user_data_free: GBoxedFreeFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoGLTextureUploadMeta"]
        [::std::mem::size_of::<_GstVideoGLTextureUploadMeta>() - 80usize];
    ["Alignment of _GstVideoGLTextureUploadMeta"]
        [::std::mem::align_of::<_GstVideoGLTextureUploadMeta>() - 8usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::meta"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, meta) - 0usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::texture_orientation"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, texture_orientation) - 16usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::n_textures"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, n_textures) - 20usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::texture_type"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, texture_type) - 24usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::buffer"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, buffer) - 40usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::upload"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, upload) - 48usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::user_data"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, user_data) - 56usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::user_data_copy"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, user_data_copy) - 64usize];
    ["Offset of field: _GstVideoGLTextureUploadMeta::user_data_free"]
        [::std::mem::offset_of!(_GstVideoGLTextureUploadMeta, user_data_free) - 72usize];
};
unsafe extern "C" {
    pub fn gst_video_gl_texture_upload_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_gl_texture_upload_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_gl_texture_upload_meta(
        buffer: *mut GstBuffer,
        texture_orientation: GstVideoGLTextureOrientation,
        n_textures: guint,
        texture_type: *mut GstVideoGLTextureType,
        upload: GstVideoGLTextureUpload,
        user_data: gpointer,
        user_data_copy: GBoxedCopyFunc,
        user_data_free: GBoxedFreeFunc,
    ) -> *mut GstVideoGLTextureUploadMeta;
}
unsafe extern "C" {
    pub fn gst_video_gl_texture_upload_meta_upload(
        meta: *mut GstVideoGLTextureUploadMeta,
        texture_id: *mut guint,
    ) -> gboolean;
}
#[doc = " GstVideoRegionOfInterestMeta:\n @meta: parent #GstMeta\n @roi_type: GQuark describing the semantic of the Roi (f.i. a face, a pedestrian)\n @id: identifier of this particular ROI\n @parent_id: identifier of its parent ROI, used f.i. for ROI hierarchisation.\n @x: x component of upper-left corner\n @y: y component of upper-left corner\n @w: bounding box width\n @h: bounding box height\n @params: list of #GstStructure containing element-specific params for downstream,\n          see gst_video_region_of_interest_meta_add_param(). (Since: 1.14)\n\n Extra buffer metadata describing an image region of interest"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoRegionOfInterestMeta {
    pub meta: GstMeta,
    pub roi_type: GQuark,
    pub id: gint,
    pub parent_id: gint,
    pub x: guint,
    pub y: guint,
    pub w: guint,
    pub h: guint,
    pub params: *mut GList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoRegionOfInterestMeta"]
        [::std::mem::size_of::<GstVideoRegionOfInterestMeta>() - 56usize];
    ["Alignment of GstVideoRegionOfInterestMeta"]
        [::std::mem::align_of::<GstVideoRegionOfInterestMeta>() - 8usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::meta"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, meta) - 0usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::roi_type"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, roi_type) - 16usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::id"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, id) - 20usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::parent_id"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, parent_id) - 24usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::x"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, x) - 28usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::y"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, y) - 32usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::w"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, w) - 36usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::h"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, h) - 40usize];
    ["Offset of field: GstVideoRegionOfInterestMeta::params"]
        [::std::mem::offset_of!(GstVideoRegionOfInterestMeta, params) - 48usize];
};
unsafe extern "C" {
    pub fn gst_video_region_of_interest_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_region_of_interest_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_get_video_region_of_interest_meta_id(
        buffer: *mut GstBuffer,
        id: gint,
    ) -> *mut GstVideoRegionOfInterestMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_region_of_interest_meta(
        buffer: *mut GstBuffer,
        roi_type: *const gchar,
        x: guint,
        y: guint,
        w: guint,
        h: guint,
    ) -> *mut GstVideoRegionOfInterestMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_region_of_interest_meta_id(
        buffer: *mut GstBuffer,
        roi_type: GQuark,
        x: guint,
        y: guint,
        w: guint,
        h: guint,
    ) -> *mut GstVideoRegionOfInterestMeta;
}
unsafe extern "C" {
    pub fn gst_video_region_of_interest_meta_add_param(
        meta: *mut GstVideoRegionOfInterestMeta,
        s: *mut GstStructure,
    );
}
unsafe extern "C" {
    pub fn gst_video_region_of_interest_meta_get_param(
        meta: *mut GstVideoRegionOfInterestMeta,
        name: *const gchar,
    ) -> *mut GstStructure;
}
#[doc = " GstVideoTimeCodeMeta:\n @meta: parent #GstMeta\n @tc: the GstVideoTimeCode to attach\n\n Extra buffer metadata describing the GstVideoTimeCode of the frame.\n\n Each frame is assumed to have its own timecode, i.e. they are not\n automatically incremented/interpolated.\n\n Since: 1.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoTimeCodeMeta {
    pub meta: GstMeta,
    pub tc: GstVideoTimeCode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoTimeCodeMeta"][::std::mem::size_of::<GstVideoTimeCodeMeta>() - 64usize];
    ["Alignment of GstVideoTimeCodeMeta"][::std::mem::align_of::<GstVideoTimeCodeMeta>() - 8usize];
    ["Offset of field: GstVideoTimeCodeMeta::meta"]
        [::std::mem::offset_of!(GstVideoTimeCodeMeta, meta) - 0usize];
    ["Offset of field: GstVideoTimeCodeMeta::tc"]
        [::std::mem::offset_of!(GstVideoTimeCodeMeta, tc) - 16usize];
};
unsafe extern "C" {
    pub fn gst_video_time_code_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_time_code_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_time_code_meta(
        buffer: *mut GstBuffer,
        tc: *const GstVideoTimeCode,
    ) -> *mut GstVideoTimeCodeMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_time_code_meta_full(
        buffer: *mut GstBuffer,
        fps_n: guint,
        fps_d: guint,
        latest_daily_jam: *mut GDateTime,
        flags: GstVideoTimeCodeFlags,
        hours: guint,
        minutes: guint,
        seconds: guint,
        frames: guint,
        field_count: guint,
    ) -> *mut GstVideoTimeCodeMeta;
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_set_video_alignment(
        config: *mut GstStructure,
        align: *const GstVideoAlignment,
    );
}
unsafe extern "C" {
    pub fn gst_buffer_pool_config_get_video_alignment(
        config: *mut GstStructure,
        align: *mut GstVideoAlignment,
    ) -> gboolean;
}
pub type GstVideoBufferPool = _GstVideoBufferPool;
pub type GstVideoBufferPoolClass = _GstVideoBufferPoolClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoBufferPoolPrivate {
    _unused: [u8; 0],
}
pub type GstVideoBufferPoolPrivate = _GstVideoBufferPoolPrivate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoBufferPool {
    pub bufferpool: GstBufferPool,
    pub priv_: *mut GstVideoBufferPoolPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoBufferPool"][::std::mem::size_of::<_GstVideoBufferPool>() - 144usize];
    ["Alignment of _GstVideoBufferPool"][::std::mem::align_of::<_GstVideoBufferPool>() - 8usize];
    ["Offset of field: _GstVideoBufferPool::bufferpool"]
        [::std::mem::offset_of!(_GstVideoBufferPool, bufferpool) - 0usize];
    ["Offset of field: _GstVideoBufferPool::priv_"]
        [::std::mem::offset_of!(_GstVideoBufferPool, priv_) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoBufferPoolClass {
    pub parent_class: GstBufferPoolClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoBufferPoolClass"]
        [::std::mem::size_of::<_GstVideoBufferPoolClass>() - 288usize];
    ["Alignment of _GstVideoBufferPoolClass"]
        [::std::mem::align_of::<_GstVideoBufferPoolClass>() - 8usize];
    ["Offset of field: _GstVideoBufferPoolClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoBufferPoolClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn gst_video_buffer_pool_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_buffer_pool_new() -> *mut GstBufferPool;
}
pub type GstVideoBufferPool_autoptr = *mut GstVideoBufferPool;
pub type GstVideoBufferPool_listautoptr = *mut GList;
pub type GstVideoBufferPool_slistautoptr = *mut GSList;
pub type GstVideoBufferPool_queueautoptr = *mut GQueue;
#[doc = " GstBaseSink:\n\n The opaque #GstBaseSink data structure."]
pub type GstBaseSink = _GstBaseSink;
#[doc = " GstBaseSinkClass:\n @parent_class: Element parent class\n @get_caps: Called to get sink pad caps from the subclass\n @set_caps: Notify subclass of changed caps\n @fixate: Only useful in pull mode. Implement if you have\n     ideas about what should be the default values for the caps you support.\n @activate_pull: Subclasses should override this when they can provide an\n     alternate method of spawning a thread to drive the pipeline in pull mode.\n     Should start or stop the pulling thread, depending on the value of the\n     \"active\" argument. Called after actually activating the sink pad in pull\n     mode. The default implementation starts a task on the sink pad.\n @get_times: Called to get the start and end times for synchronising\n     the passed buffer to the clock\n @propose_allocation: configure the allocation query\n @start: Start processing. Ideal for opening resources in the subclass\n @stop: Stop processing. Subclasses should use this to close resources.\n @unlock: Unlock any pending access to the resource. Subclasses should\n     unblock any blocked function ASAP and call gst_base_sink_wait_preroll()\n @unlock_stop: Clear the previous unlock request. Subclasses should clear\n     any state they set during #GstBaseSinkClass::unlock, and be ready to\n     continue where they left off after gst_base_sink_wait_preroll(),\n     gst_base_sink_wait() or gst_wait_sink_wait_clock() return or\n     #GstBaseSinkClass::render is called again.\n @query: perform a #GstQuery on the element.\n @event: Override this to handle events arriving on the sink pad\n @wait_event: Override this to implement custom logic to wait for the event\n     time (for events like EOS and GAP). Subclasses should always first\n     chain up to the default implementation.\n @prepare: Called to prepare the buffer for @render and @preroll. This\n     function is called before synchronisation is performed.\n @prepare_list: Called to prepare the buffer list for @render_list. This\n     function is called before synchronisation is performed.\n @preroll: Called to present the preroll buffer if desired.\n @render: Called when a buffer should be presented or output, at the\n     correct moment if the #GstBaseSink has been set to sync to the clock.\n @render_list: Same as @render but used with buffer lists instead of\n     buffers.\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At the minimum, the @render method should be overridden to\n output/present buffers."]
pub type GstBaseSinkClass = _GstBaseSinkClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBaseSinkPrivate {
    _unused: [u8; 0],
}
pub type GstBaseSinkPrivate = _GstBaseSinkPrivate;
#[doc = " GstBaseSink:\n\n The opaque #GstBaseSink data structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBaseSink {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub pad_mode: GstPadMode,
    pub offset: guint64,
    pub can_activate_pull: gboolean,
    pub can_activate_push: gboolean,
    pub preroll_lock: GMutex,
    pub preroll_cond: GCond,
    pub eos: gboolean,
    pub need_preroll: gboolean,
    pub have_preroll: gboolean,
    pub playing_async: gboolean,
    pub have_newsegment: gboolean,
    pub segment: GstSegment,
    pub clock_id: GstClockID,
    pub sync: gboolean,
    pub flushing: gboolean,
    pub running: gboolean,
    pub max_lateness: gint64,
    pub priv_: *mut GstBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBaseSink"][::std::mem::size_of::<_GstBaseSink>() - 664usize];
    ["Alignment of _GstBaseSink"][::std::mem::align_of::<_GstBaseSink>() - 8usize];
    ["Offset of field: _GstBaseSink::element"]
        [::std::mem::offset_of!(_GstBaseSink, element) - 0usize];
    ["Offset of field: _GstBaseSink::sinkpad"]
        [::std::mem::offset_of!(_GstBaseSink, sinkpad) - 264usize];
    ["Offset of field: _GstBaseSink::pad_mode"]
        [::std::mem::offset_of!(_GstBaseSink, pad_mode) - 272usize];
    ["Offset of field: _GstBaseSink::offset"]
        [::std::mem::offset_of!(_GstBaseSink, offset) - 280usize];
    ["Offset of field: _GstBaseSink::can_activate_pull"]
        [::std::mem::offset_of!(_GstBaseSink, can_activate_pull) - 288usize];
    ["Offset of field: _GstBaseSink::can_activate_push"]
        [::std::mem::offset_of!(_GstBaseSink, can_activate_push) - 292usize];
    ["Offset of field: _GstBaseSink::preroll_lock"]
        [::std::mem::offset_of!(_GstBaseSink, preroll_lock) - 296usize];
    ["Offset of field: _GstBaseSink::preroll_cond"]
        [::std::mem::offset_of!(_GstBaseSink, preroll_cond) - 304usize];
    ["Offset of field: _GstBaseSink::eos"][::std::mem::offset_of!(_GstBaseSink, eos) - 320usize];
    ["Offset of field: _GstBaseSink::need_preroll"]
        [::std::mem::offset_of!(_GstBaseSink, need_preroll) - 324usize];
    ["Offset of field: _GstBaseSink::have_preroll"]
        [::std::mem::offset_of!(_GstBaseSink, have_preroll) - 328usize];
    ["Offset of field: _GstBaseSink::playing_async"]
        [::std::mem::offset_of!(_GstBaseSink, playing_async) - 332usize];
    ["Offset of field: _GstBaseSink::have_newsegment"]
        [::std::mem::offset_of!(_GstBaseSink, have_newsegment) - 336usize];
    ["Offset of field: _GstBaseSink::segment"]
        [::std::mem::offset_of!(_GstBaseSink, segment) - 344usize];
    ["Offset of field: _GstBaseSink::clock_id"]
        [::std::mem::offset_of!(_GstBaseSink, clock_id) - 464usize];
    ["Offset of field: _GstBaseSink::sync"][::std::mem::offset_of!(_GstBaseSink, sync) - 472usize];
    ["Offset of field: _GstBaseSink::flushing"]
        [::std::mem::offset_of!(_GstBaseSink, flushing) - 476usize];
    ["Offset of field: _GstBaseSink::running"]
        [::std::mem::offset_of!(_GstBaseSink, running) - 480usize];
    ["Offset of field: _GstBaseSink::max_lateness"]
        [::std::mem::offset_of!(_GstBaseSink, max_lateness) - 488usize];
    ["Offset of field: _GstBaseSink::priv_"]
        [::std::mem::offset_of!(_GstBaseSink, priv_) - 496usize];
    ["Offset of field: _GstBaseSink::_gst_reserved"]
        [::std::mem::offset_of!(_GstBaseSink, _gst_reserved) - 504usize];
};
#[doc = " GstBaseSinkClass:\n @parent_class: Element parent class\n @get_caps: Called to get sink pad caps from the subclass\n @set_caps: Notify subclass of changed caps\n @fixate: Only useful in pull mode. Implement if you have\n     ideas about what should be the default values for the caps you support.\n @activate_pull: Subclasses should override this when they can provide an\n     alternate method of spawning a thread to drive the pipeline in pull mode.\n     Should start or stop the pulling thread, depending on the value of the\n     \"active\" argument. Called after actually activating the sink pad in pull\n     mode. The default implementation starts a task on the sink pad.\n @get_times: Called to get the start and end times for synchronising\n     the passed buffer to the clock\n @propose_allocation: configure the allocation query\n @start: Start processing. Ideal for opening resources in the subclass\n @stop: Stop processing. Subclasses should use this to close resources.\n @unlock: Unlock any pending access to the resource. Subclasses should\n     unblock any blocked function ASAP and call gst_base_sink_wait_preroll()\n @unlock_stop: Clear the previous unlock request. Subclasses should clear\n     any state they set during #GstBaseSinkClass::unlock, and be ready to\n     continue where they left off after gst_base_sink_wait_preroll(),\n     gst_base_sink_wait() or gst_wait_sink_wait_clock() return or\n     #GstBaseSinkClass::render is called again.\n @query: perform a #GstQuery on the element.\n @event: Override this to handle events arriving on the sink pad\n @wait_event: Override this to implement custom logic to wait for the event\n     time (for events like EOS and GAP). Subclasses should always first\n     chain up to the default implementation.\n @prepare: Called to prepare the buffer for @render and @preroll. This\n     function is called before synchronisation is performed.\n @prepare_list: Called to prepare the buffer list for @render_list. This\n     function is called before synchronisation is performed.\n @preroll: Called to present the preroll buffer if desired.\n @render: Called when a buffer should be presented or output, at the\n     correct moment if the #GstBaseSink has been set to sync to the clock.\n @render_list: Same as @render but used with buffer lists instead of\n     buffers.\n\n Subclasses can override any of the available virtual methods or not, as\n needed. At the minimum, the @render method should be overridden to\n output/present buffers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBaseSinkClass {
    pub parent_class: GstElementClass,
    #[doc = " GstBaseSink::get_caps:\n @filter: (in) (nullable):\n\n Called to get sink pad caps from the subclass."]
    pub get_caps: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, filter: *mut GstCaps) -> *mut GstCaps,
    >,
    pub set_caps: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, caps: *mut GstCaps) -> gboolean,
    >,
    pub fixate: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, caps: *mut GstCaps) -> *mut GstCaps,
    >,
    pub activate_pull: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, active: gboolean) -> gboolean,
    >,
    #[doc = " GstBaseSink::get_times:\n @start: (out): the start #GstClockTime\n @end: (out): the end #GstClockTime\n\n Get the start and end times for syncing on this buffer."]
    pub get_times: ::std::option::Option<
        unsafe extern "C" fn(
            sink: *mut GstBaseSink,
            buffer: *mut GstBuffer,
            start: *mut GstClockTime,
            end: *mut GstClockTime,
        ),
    >,
    pub propose_allocation: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, query: *mut GstQuery) -> gboolean,
    >,
    pub start: ::std::option::Option<unsafe extern "C" fn(sink: *mut GstBaseSink) -> gboolean>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(sink: *mut GstBaseSink) -> gboolean>,
    pub unlock: ::std::option::Option<unsafe extern "C" fn(sink: *mut GstBaseSink) -> gboolean>,
    pub unlock_stop:
        ::std::option::Option<unsafe extern "C" fn(sink: *mut GstBaseSink) -> gboolean>,
    pub query: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, query: *mut GstQuery) -> gboolean,
    >,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, event: *mut GstEvent) -> gboolean,
    >,
    pub wait_event: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, event: *mut GstEvent) -> GstFlowReturn,
    >,
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, buffer: *mut GstBuffer) -> GstFlowReturn,
    >,
    pub prepare_list: ::std::option::Option<
        unsafe extern "C" fn(
            sink: *mut GstBaseSink,
            buffer_list: *mut GstBufferList,
        ) -> GstFlowReturn,
    >,
    pub preroll: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, buffer: *mut GstBuffer) -> GstFlowReturn,
    >,
    pub render: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut GstBaseSink, buffer: *mut GstBuffer) -> GstFlowReturn,
    >,
    pub render_list: ::std::option::Option<
        unsafe extern "C" fn(
            sink: *mut GstBaseSink,
            buffer_list: *mut GstBufferList,
        ) -> GstFlowReturn,
    >,
    pub _gst_reserved: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstBaseSinkClass"][::std::mem::size_of::<_GstBaseSinkClass>() - 792usize];
    ["Alignment of _GstBaseSinkClass"][::std::mem::align_of::<_GstBaseSinkClass>() - 8usize];
    ["Offset of field: _GstBaseSinkClass::parent_class"]
        [::std::mem::offset_of!(_GstBaseSinkClass, parent_class) - 0usize];
    ["Offset of field: _GstBaseSinkClass::get_caps"]
        [::std::mem::offset_of!(_GstBaseSinkClass, get_caps) - 488usize];
    ["Offset of field: _GstBaseSinkClass::set_caps"]
        [::std::mem::offset_of!(_GstBaseSinkClass, set_caps) - 496usize];
    ["Offset of field: _GstBaseSinkClass::fixate"]
        [::std::mem::offset_of!(_GstBaseSinkClass, fixate) - 504usize];
    ["Offset of field: _GstBaseSinkClass::activate_pull"]
        [::std::mem::offset_of!(_GstBaseSinkClass, activate_pull) - 512usize];
    ["Offset of field: _GstBaseSinkClass::get_times"]
        [::std::mem::offset_of!(_GstBaseSinkClass, get_times) - 520usize];
    ["Offset of field: _GstBaseSinkClass::propose_allocation"]
        [::std::mem::offset_of!(_GstBaseSinkClass, propose_allocation) - 528usize];
    ["Offset of field: _GstBaseSinkClass::start"]
        [::std::mem::offset_of!(_GstBaseSinkClass, start) - 536usize];
    ["Offset of field: _GstBaseSinkClass::stop"]
        [::std::mem::offset_of!(_GstBaseSinkClass, stop) - 544usize];
    ["Offset of field: _GstBaseSinkClass::unlock"]
        [::std::mem::offset_of!(_GstBaseSinkClass, unlock) - 552usize];
    ["Offset of field: _GstBaseSinkClass::unlock_stop"]
        [::std::mem::offset_of!(_GstBaseSinkClass, unlock_stop) - 560usize];
    ["Offset of field: _GstBaseSinkClass::query"]
        [::std::mem::offset_of!(_GstBaseSinkClass, query) - 568usize];
    ["Offset of field: _GstBaseSinkClass::event"]
        [::std::mem::offset_of!(_GstBaseSinkClass, event) - 576usize];
    ["Offset of field: _GstBaseSinkClass::wait_event"]
        [::std::mem::offset_of!(_GstBaseSinkClass, wait_event) - 584usize];
    ["Offset of field: _GstBaseSinkClass::prepare"]
        [::std::mem::offset_of!(_GstBaseSinkClass, prepare) - 592usize];
    ["Offset of field: _GstBaseSinkClass::prepare_list"]
        [::std::mem::offset_of!(_GstBaseSinkClass, prepare_list) - 600usize];
    ["Offset of field: _GstBaseSinkClass::preroll"]
        [::std::mem::offset_of!(_GstBaseSinkClass, preroll) - 608usize];
    ["Offset of field: _GstBaseSinkClass::render"]
        [::std::mem::offset_of!(_GstBaseSinkClass, render) - 616usize];
    ["Offset of field: _GstBaseSinkClass::render_list"]
        [::std::mem::offset_of!(_GstBaseSinkClass, render_list) - 624usize];
    ["Offset of field: _GstBaseSinkClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstBaseSinkClass, _gst_reserved) - 632usize];
};
unsafe extern "C" {
    pub fn gst_base_sink_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_base_sink_do_preroll(
        sink: *mut GstBaseSink,
        obj: *mut GstMiniObject,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_base_sink_wait_preroll(sink: *mut GstBaseSink) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_sync(sink: *mut GstBaseSink, sync: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_sync(sink: *mut GstBaseSink) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_drop_out_of_segment(
        sink: *mut GstBaseSink,
        drop_out_of_segment: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_base_sink_get_drop_out_of_segment(sink: *mut GstBaseSink) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_max_lateness(sink: *mut GstBaseSink, max_lateness: gint64);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_max_lateness(sink: *mut GstBaseSink) -> gint64;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_qos_enabled(sink: *mut GstBaseSink, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_sink_is_qos_enabled(sink: *mut GstBaseSink) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_async_enabled(sink: *mut GstBaseSink, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_sink_is_async_enabled(sink: *mut GstBaseSink) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_ts_offset(sink: *mut GstBaseSink, offset: GstClockTimeDiff);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_ts_offset(sink: *mut GstBaseSink) -> GstClockTimeDiff;
}
unsafe extern "C" {
    pub fn gst_base_sink_get_last_sample(sink: *mut GstBaseSink) -> *mut GstSample;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_last_sample_enabled(sink: *mut GstBaseSink, enabled: gboolean);
}
unsafe extern "C" {
    pub fn gst_base_sink_is_last_sample_enabled(sink: *mut GstBaseSink) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_query_latency(
        sink: *mut GstBaseSink,
        live: *mut gboolean,
        upstream_live: *mut gboolean,
        min_latency: *mut GstClockTime,
        max_latency: *mut GstClockTime,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_base_sink_get_latency(sink: *mut GstBaseSink) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_render_delay(sink: *mut GstBaseSink, delay: GstClockTime);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_render_delay(sink: *mut GstBaseSink) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_blocksize(sink: *mut GstBaseSink, blocksize: guint);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_blocksize(sink: *mut GstBaseSink) -> guint;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_throttle_time(sink: *mut GstBaseSink, throttle: guint64);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_throttle_time(sink: *mut GstBaseSink) -> guint64;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_max_bitrate(sink: *mut GstBaseSink, max_bitrate: guint64);
}
unsafe extern "C" {
    pub fn gst_base_sink_get_max_bitrate(sink: *mut GstBaseSink) -> guint64;
}
unsafe extern "C" {
    pub fn gst_base_sink_set_processing_deadline(
        sink: *mut GstBaseSink,
        processing_deadline: GstClockTime,
    );
}
unsafe extern "C" {
    pub fn gst_base_sink_get_processing_deadline(sink: *mut GstBaseSink) -> GstClockTime;
}
unsafe extern "C" {
    pub fn gst_base_sink_wait_clock(
        sink: *mut GstBaseSink,
        time: GstClockTime,
        jitter: *mut GstClockTimeDiff,
    ) -> GstClockReturn;
}
unsafe extern "C" {
    pub fn gst_base_sink_wait(
        sink: *mut GstBaseSink,
        time: GstClockTime,
        jitter: *mut GstClockTimeDiff,
    ) -> GstFlowReturn;
}
unsafe extern "C" {
    pub fn gst_base_sink_get_stats(sink: *mut GstBaseSink) -> *mut GstStructure;
}
pub type GstBaseSink_autoptr = *mut GstBaseSink;
pub type GstBaseSink_listautoptr = *mut GList;
pub type GstBaseSink_slistautoptr = *mut GSList;
pub type GstBaseSink_queueautoptr = *mut GQueue;
#[doc = " GstVideoSink:\n @height: video height (derived class needs to set this)\n @width: video width (derived class needs to set this)\n\n The video sink instance structure. Derived video sinks should set the\n @height and @width members."]
pub type GstVideoSink = _GstVideoSink;
#[doc = " GstVideoSinkClass:\n @parent_class: the parent class structure\n @show_frame: render a video frame. Maps to #GstBaseSinkClass.render() and\n     #GstBaseSinkClass.preroll() vfuncs. Rendering during preroll will be\n     suppressed if the #GstVideoSink:show-preroll-frame property is set to\n     %FALSE.\n\n The video sink class structure. Derived classes should override the\n @show_frame virtual function."]
pub type GstVideoSinkClass = _GstVideoSinkClass;
#[doc = " GstVideoRectangle:\n @x: X coordinate of rectangle's top-left point\n @y: Y coordinate of rectangle's top-left point\n @w: width of the rectangle\n @h: height of the rectangle\n\n Helper structure representing a rectangular area."]
pub type GstVideoRectangle = _GstVideoRectangle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoSinkPrivate {
    _unused: [u8; 0],
}
pub type GstVideoSinkPrivate = _GstVideoSinkPrivate;
#[doc = " GstVideoRectangle:\n @x: X coordinate of rectangle's top-left point\n @y: Y coordinate of rectangle's top-left point\n @w: width of the rectangle\n @h: height of the rectangle\n\n Helper structure representing a rectangular area."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoRectangle {
    pub x: gint,
    pub y: gint,
    pub w: gint,
    pub h: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoRectangle"][::std::mem::size_of::<_GstVideoRectangle>() - 16usize];
    ["Alignment of _GstVideoRectangle"][::std::mem::align_of::<_GstVideoRectangle>() - 4usize];
    ["Offset of field: _GstVideoRectangle::x"]
        [::std::mem::offset_of!(_GstVideoRectangle, x) - 0usize];
    ["Offset of field: _GstVideoRectangle::y"]
        [::std::mem::offset_of!(_GstVideoRectangle, y) - 4usize];
    ["Offset of field: _GstVideoRectangle::w"]
        [::std::mem::offset_of!(_GstVideoRectangle, w) - 8usize];
    ["Offset of field: _GstVideoRectangle::h"]
        [::std::mem::offset_of!(_GstVideoRectangle, h) - 12usize];
};
#[doc = " GstVideoSink:\n @height: video height (derived class needs to set this)\n @width: video width (derived class needs to set this)\n\n The video sink instance structure. Derived video sinks should set the\n @height and @width members."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstVideoSink {
    pub element: GstBaseSink,
    pub width: gint,
    pub height: gint,
    pub priv_: *mut GstVideoSinkPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoSink"][::std::mem::size_of::<_GstVideoSink>() - 712usize];
    ["Alignment of _GstVideoSink"][::std::mem::align_of::<_GstVideoSink>() - 8usize];
    ["Offset of field: _GstVideoSink::element"]
        [::std::mem::offset_of!(_GstVideoSink, element) - 0usize];
    ["Offset of field: _GstVideoSink::width"]
        [::std::mem::offset_of!(_GstVideoSink, width) - 664usize];
    ["Offset of field: _GstVideoSink::height"]
        [::std::mem::offset_of!(_GstVideoSink, height) - 668usize];
    ["Offset of field: _GstVideoSink::priv_"]
        [::std::mem::offset_of!(_GstVideoSink, priv_) - 672usize];
    ["Offset of field: _GstVideoSink::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoSink, _gst_reserved) - 680usize];
};
#[doc = " GstVideoSinkClass:\n @parent_class: the parent class structure\n @show_frame: render a video frame. Maps to #GstBaseSinkClass.render() and\n     #GstBaseSinkClass.preroll() vfuncs. Rendering during preroll will be\n     suppressed if the #GstVideoSink:show-preroll-frame property is set to\n     %FALSE.\n\n The video sink class structure. Derived classes should override the\n @show_frame virtual function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoSinkClass {
    pub parent_class: GstBaseSinkClass,
    pub show_frame: ::std::option::Option<
        unsafe extern "C" fn(video_sink: *mut GstVideoSink, buf: *mut GstBuffer) -> GstFlowReturn,
    >,
    #[doc = " GstVideoSinkClass::set_info:\n @caps: A #GstCaps.\n @info: A #GstVideoInfo corresponding to @caps.\n\n Notifies the subclass of changed #GstVideoInfo.\n\n Since: 1.20"]
    pub set_info: ::std::option::Option<
        unsafe extern "C" fn(
            video_sink: *mut GstVideoSink,
            caps: *mut GstCaps,
            info: *const GstVideoInfo,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoSinkClass"][::std::mem::size_of::<_GstVideoSinkClass>() - 832usize];
    ["Alignment of _GstVideoSinkClass"][::std::mem::align_of::<_GstVideoSinkClass>() - 8usize];
    ["Offset of field: _GstVideoSinkClass::parent_class"]
        [::std::mem::offset_of!(_GstVideoSinkClass, parent_class) - 0usize];
    ["Offset of field: _GstVideoSinkClass::show_frame"]
        [::std::mem::offset_of!(_GstVideoSinkClass, show_frame) - 792usize];
    ["Offset of field: _GstVideoSinkClass::set_info"]
        [::std::mem::offset_of!(_GstVideoSinkClass, set_info) - 800usize];
    ["Offset of field: _GstVideoSinkClass::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoSinkClass, _gst_reserved) - 808usize];
};
unsafe extern "C" {
    pub fn gst_video_sink_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_sink_center_rect(
        src: GstVideoRectangle,
        dst: GstVideoRectangle,
        result: *mut GstVideoRectangle,
        scaling: gboolean,
    );
}
unsafe extern "C" {
    pub fn gst_video_center_rect(
        src: *const GstVideoRectangle,
        dst: *const GstVideoRectangle,
        result: *mut GstVideoRectangle,
        scaling: gboolean,
    );
}
pub type GstVideoSink_autoptr = *mut GstVideoSink;
pub type GstVideoSink_listautoptr = *mut GList;
pub type GstVideoSink_slistautoptr = *mut GSList;
pub type GstVideoSink_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstNavigation {
    _unused: [u8; 0],
}
pub type GstNavigation = _GstNavigation;
#[doc = " GstNavigationInterface:\n @iface: the parent interface\n @send_event: sending a navigation event\n\n Navigation interface."]
pub type GstNavigationInterface = _GstNavigationInterface;
#[doc = " GstNavigationInterface:\n @iface: the parent interface\n @send_event: sending a navigation event\n\n Navigation interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstNavigationInterface {
    pub iface: GTypeInterface,
    pub send_event: ::std::option::Option<
        unsafe extern "C" fn(navigation: *mut GstNavigation, structure: *mut GstStructure),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstNavigationInterface"][::std::mem::size_of::<_GstNavigationInterface>() - 24usize];
    ["Alignment of _GstNavigationInterface"]
        [::std::mem::align_of::<_GstNavigationInterface>() - 8usize];
    ["Offset of field: _GstNavigationInterface::iface"]
        [::std::mem::offset_of!(_GstNavigationInterface, iface) - 0usize];
    ["Offset of field: _GstNavigationInterface::send_event"]
        [::std::mem::offset_of!(_GstNavigationInterface, send_event) - 16usize];
};
unsafe extern "C" {
    pub fn gst_navigation_get_type() -> GType;
}
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_INVALID: GstNavigationCommand = 0;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU1: GstNavigationCommand = 1;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU2: GstNavigationCommand = 2;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU3: GstNavigationCommand = 3;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU4: GstNavigationCommand = 4;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU5: GstNavigationCommand = 5;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU6: GstNavigationCommand = 6;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_MENU7: GstNavigationCommand = 7;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_LEFT: GstNavigationCommand = 20;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_RIGHT: GstNavigationCommand = 21;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_UP: GstNavigationCommand = 22;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_DOWN: GstNavigationCommand = 23;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_ACTIVATE: GstNavigationCommand = 24;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_PREV_ANGLE: GstNavigationCommand = 30;
pub const GstNavigationCommand_GST_NAVIGATION_COMMAND_NEXT_ANGLE: GstNavigationCommand = 31;
#[doc = " GstNavigationCommand:\n @GST_NAVIGATION_COMMAND_INVALID: An invalid command entry\n @GST_NAVIGATION_COMMAND_MENU1: Execute navigation menu command 1. For DVD,\n this enters the DVD root menu, or exits back to the title from the menu.\n @GST_NAVIGATION_COMMAND_MENU2: Execute navigation menu command 2. For DVD,\n this jumps to the DVD title menu.\n @GST_NAVIGATION_COMMAND_MENU3: Execute navigation menu command 3. For DVD,\n this jumps into the DVD root menu.\n @GST_NAVIGATION_COMMAND_MENU4: Execute navigation menu command 4. For DVD,\n this jumps to the Subpicture menu.\n @GST_NAVIGATION_COMMAND_MENU5: Execute navigation menu command 5. For DVD,\n the jumps to the audio menu.\n @GST_NAVIGATION_COMMAND_MENU6: Execute navigation menu command 6. For DVD,\n this jumps to the angles menu.\n @GST_NAVIGATION_COMMAND_MENU7: Execute navigation menu command 7. For DVD,\n this jumps to the chapter menu.\n @GST_NAVIGATION_COMMAND_LEFT: Select the next button to the left in a menu,\n if such a button exists.\n @GST_NAVIGATION_COMMAND_RIGHT: Select the next button to the right in a menu,\n if such a button exists.\n @GST_NAVIGATION_COMMAND_UP: Select the button above the current one in a\n menu, if such a button exists.\n @GST_NAVIGATION_COMMAND_DOWN: Select the button below the current one in a\n menu, if such a button exists.\n @GST_NAVIGATION_COMMAND_ACTIVATE: Activate (click) the currently selected\n button in a menu, if such a button exists.\n @GST_NAVIGATION_COMMAND_PREV_ANGLE: Switch to the previous angle in a\n multiangle feature.\n @GST_NAVIGATION_COMMAND_NEXT_ANGLE: Switch to the next angle in a multiangle\n feature.\n\n A set of commands that may be issued to an element providing the\n #GstNavigation interface. The available commands can be queried via\n the gst_navigation_query_new_commands() query.\n\n For convenience in handling DVD navigation, the MENU commands are aliased as:\n    GST_NAVIGATION_COMMAND_DVD_MENU            = @GST_NAVIGATION_COMMAND_MENU1\n    GST_NAVIGATION_COMMAND_DVD_TITLE_MENU      = @GST_NAVIGATION_COMMAND_MENU2\n    GST_NAVIGATION_COMMAND_DVD_ROOT_MENU       = @GST_NAVIGATION_COMMAND_MENU3\n    GST_NAVIGATION_COMMAND_DVD_SUBPICTURE_MENU = @GST_NAVIGATION_COMMAND_MENU4\n    GST_NAVIGATION_COMMAND_DVD_AUDIO_MENU      = @GST_NAVIGATION_COMMAND_MENU5\n    GST_NAVIGATION_COMMAND_DVD_ANGLE_MENU      = @GST_NAVIGATION_COMMAND_MENU6\n    GST_NAVIGATION_COMMAND_DVD_CHAPTER_MENU    = @GST_NAVIGATION_COMMAND_MENU7"]
pub type GstNavigationCommand = ::std::os::raw::c_uint;
pub const GstNavigationQueryType_GST_NAVIGATION_QUERY_INVALID: GstNavigationQueryType = 0;
pub const GstNavigationQueryType_GST_NAVIGATION_QUERY_COMMANDS: GstNavigationQueryType = 1;
pub const GstNavigationQueryType_GST_NAVIGATION_QUERY_ANGLES: GstNavigationQueryType = 2;
#[doc = " GstNavigationQueryType:\n @GST_NAVIGATION_QUERY_INVALID: invalid query\n @GST_NAVIGATION_QUERY_COMMANDS: command query\n @GST_NAVIGATION_QUERY_ANGLES: viewing angle query\n\n Types of navigation interface queries."]
pub type GstNavigationQueryType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_navigation_query_get_type(query: *mut GstQuery) -> GstNavigationQueryType;
}
unsafe extern "C" {
    pub fn gst_navigation_query_new_commands() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_navigation_query_set_commands(query: *mut GstQuery, n_cmds: gint, ...);
}
unsafe extern "C" {
    pub fn gst_navigation_query_set_commandsv(
        query: *mut GstQuery,
        n_cmds: gint,
        cmds: *mut GstNavigationCommand,
    );
}
unsafe extern "C" {
    pub fn gst_navigation_query_parse_commands_length(
        query: *mut GstQuery,
        n_cmds: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_query_parse_commands_nth(
        query: *mut GstQuery,
        nth: guint,
        cmd: *mut GstNavigationCommand,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_query_new_angles() -> *mut GstQuery;
}
unsafe extern "C" {
    pub fn gst_navigation_query_set_angles(query: *mut GstQuery, cur_angle: guint, n_angles: guint);
}
unsafe extern "C" {
    pub fn gst_navigation_query_parse_angles(
        query: *mut GstQuery,
        cur_angle: *mut guint,
        n_angles: *mut guint,
    ) -> gboolean;
}
pub const GstNavigationMessageType_GST_NAVIGATION_MESSAGE_INVALID: GstNavigationMessageType = 0;
pub const GstNavigationMessageType_GST_NAVIGATION_MESSAGE_MOUSE_OVER: GstNavigationMessageType = 1;
pub const GstNavigationMessageType_GST_NAVIGATION_MESSAGE_COMMANDS_CHANGED:
    GstNavigationMessageType = 2;
pub const GstNavigationMessageType_GST_NAVIGATION_MESSAGE_ANGLES_CHANGED: GstNavigationMessageType =
    3;
pub const GstNavigationMessageType_GST_NAVIGATION_MESSAGE_EVENT: GstNavigationMessageType = 4;
#[doc = " GstNavigationMessageType:\n @GST_NAVIGATION_MESSAGE_INVALID: Returned from\n gst_navigation_message_get_type() when the passed message is not a\n navigation message.\n @GST_NAVIGATION_MESSAGE_MOUSE_OVER: Sent when the mouse moves over or leaves a\n clickable region of the output, such as a DVD menu button.\n @GST_NAVIGATION_MESSAGE_COMMANDS_CHANGED: Sent when the set of available commands\n changes and should re-queried by interested applications.\n @GST_NAVIGATION_MESSAGE_ANGLES_CHANGED: Sent when display angles in a multi-angle\n feature (such as a multiangle DVD) change - either angles have appeared or\n disappeared.\n @GST_NAVIGATION_MESSAGE_EVENT: Sent when a navigation event was not handled\n by any element in the pipeline (Since: 1.6)\n\n A set of notifications that may be received on the bus when navigation\n related status changes."]
pub type GstNavigationMessageType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_navigation_message_get_type(message: *mut GstMessage) -> GstNavigationMessageType;
}
unsafe extern "C" {
    pub fn gst_navigation_message_new_mouse_over(
        src: *mut GstObject,
        active: gboolean,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_navigation_message_parse_mouse_over(
        message: *mut GstMessage,
        active: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_message_new_commands_changed(src: *mut GstObject) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_navigation_message_new_angles_changed(
        src: *mut GstObject,
        cur_angle: guint,
        n_angles: guint,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_navigation_message_parse_angles_changed(
        message: *mut GstMessage,
        cur_angle: *mut guint,
        n_angles: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_message_new_event(
        src: *mut GstObject,
        event: *mut GstEvent,
    ) -> *mut GstMessage;
}
unsafe extern "C" {
    pub fn gst_navigation_message_parse_event(
        message: *mut GstMessage,
        event: *mut *mut GstEvent,
    ) -> gboolean;
}
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_INVALID: GstNavigationEventType = 0;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_KEY_PRESS: GstNavigationEventType = 1;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_KEY_RELEASE: GstNavigationEventType = 2;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS: GstNavigationEventType =
    3;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE: GstNavigationEventType =
    4;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_MOUSE_MOVE: GstNavigationEventType = 5;
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_COMMAND: GstNavigationEventType = 6;
#[doc = " GST_NAVIGATION_EVENT_MOUSE_SCROLL:\n\n A mouse scroll event. Use gst_navigation_event_parse_mouse_scroll_event()\n to extract the details from the event.\n\n Since: 1.18"]
pub const GstNavigationEventType_GST_NAVIGATION_EVENT_MOUSE_SCROLL: GstNavigationEventType = 7;
#[doc = " GstNavigationEventType:\n @GST_NAVIGATION_EVENT_INVALID: Returned from\n gst_navigation_event_get_type() when the passed event is not a navigation event.\n @GST_NAVIGATION_EVENT_KEY_PRESS: A key press event. Use\n gst_navigation_event_parse_key_event() to extract the details from the event.\n @GST_NAVIGATION_EVENT_KEY_RELEASE: A key release event. Use\n gst_navigation_event_parse_key_event() to extract the details from the event.\n @GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS: A mouse button press event. Use\n gst_navigation_event_parse_mouse_button_event() to extract the details from the\n event.\n @GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE: A mouse button release event. Use\n gst_navigation_event_parse_mouse_button_event() to extract the details from the\n event.\n @GST_NAVIGATION_EVENT_MOUSE_MOVE: A mouse movement event. Use\n gst_navigation_event_parse_mouse_move_event() to extract the details from the\n event.\n @GST_NAVIGATION_EVENT_COMMAND: A navigation command event. Use\n gst_navigation_event_parse_command() to extract the details from the event.\n @GST_NAVIGATION_EVENT_MOUSE_SCROLL: A mouse scroll event. Use\n gst_navigation_event_parse_mouse_scroll_event() to extract the details from\n the event. (Since: 1.18)\n\n Enum values for the various events that an element implementing the\n GstNavigation interface might send up the pipeline."]
pub type GstNavigationEventType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_navigation_event_get_type(event: *mut GstEvent) -> GstNavigationEventType;
}
unsafe extern "C" {
    pub fn gst_navigation_event_parse_key_event(
        event: *mut GstEvent,
        key: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_event_parse_mouse_button_event(
        event: *mut GstEvent,
        button: *mut gint,
        x: *mut gdouble,
        y: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_event_parse_mouse_move_event(
        event: *mut GstEvent,
        x: *mut gdouble,
        y: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_event_parse_mouse_scroll_event(
        event: *mut GstEvent,
        x: *mut gdouble,
        y: *mut gdouble,
        delta_x: *mut gdouble,
        delta_y: *mut gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_event_parse_command(
        event: *mut GstEvent,
        command: *mut GstNavigationCommand,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_navigation_send_event(navigation: *mut GstNavigation, structure: *mut GstStructure);
}
unsafe extern "C" {
    pub fn gst_navigation_send_key_event(
        navigation: *mut GstNavigation,
        event: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn gst_navigation_send_mouse_event(
        navigation: *mut GstNavigation,
        event: *const ::std::os::raw::c_char,
        button: ::std::os::raw::c_int,
        x: f64,
        y: f64,
    );
}
unsafe extern "C" {
    pub fn gst_navigation_send_mouse_scroll_event(
        navigation: *mut GstNavigation,
        x: f64,
        y: f64,
        delta_x: f64,
        delta_y: f64,
    );
}
unsafe extern "C" {
    pub fn gst_navigation_send_command(
        navigation: *mut GstNavigation,
        command: GstNavigationCommand,
    );
}
#[doc = " GstVideoAncillary:\n @DID: The Data Identifier\n @SDID_block_number: The Secondary Data Identifier (if type 2) or the Data\n                     Block Number (if type 1)\n @data_count: The amount of data (in bytes) in @data (max 255 bytes)\n @data: (array length=data_count): The user data content of the Ancillary packet.\n    Does not contain the ADF, DID, SDID nor CS.\n\n Video Ancillary data, according to SMPTE-291M specification.\n\n Note that the contents of the data are always stored as 8bit data (i.e. do not contain\n the parity check bits).\n\n Since: 1.16"]
pub type GstVideoAncillary = _GstVideoAncillary;
#[doc = " GstVideoAncillary:\n @DID: The Data Identifier\n @SDID_block_number: The Secondary Data Identifier (if type 2) or the Data\n                     Block Number (if type 1)\n @data_count: The amount of data (in bytes) in @data (max 255 bytes)\n @data: (array length=data_count): The user data content of the Ancillary packet.\n    Does not contain the ADF, DID, SDID nor CS.\n\n Video Ancillary data, according to SMPTE-291M specification.\n\n Note that the contents of the data are always stored as 8bit data (i.e. do not contain\n the parity check bits).\n\n Since: 1.16"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoAncillary {
    pub DID: guint8,
    pub SDID_block_number: guint8,
    pub data_count: guint8,
    pub data: [guint8; 256usize],
    pub _gst_reserved: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoAncillary"][::std::mem::size_of::<_GstVideoAncillary>() - 296usize];
    ["Alignment of _GstVideoAncillary"][::std::mem::align_of::<_GstVideoAncillary>() - 8usize];
    ["Offset of field: _GstVideoAncillary::DID"]
        [::std::mem::offset_of!(_GstVideoAncillary, DID) - 0usize];
    ["Offset of field: _GstVideoAncillary::SDID_block_number"]
        [::std::mem::offset_of!(_GstVideoAncillary, SDID_block_number) - 1usize];
    ["Offset of field: _GstVideoAncillary::data_count"]
        [::std::mem::offset_of!(_GstVideoAncillary, data_count) - 2usize];
    ["Offset of field: _GstVideoAncillary::data"]
        [::std::mem::offset_of!(_GstVideoAncillary, data) - 3usize];
    ["Offset of field: _GstVideoAncillary::_gst_reserved"]
        [::std::mem::offset_of!(_GstVideoAncillary, _gst_reserved) - 264usize];
};
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_UNDEFINED: GstVideoAncillaryDID = 0;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_DELETION: GstVideoAncillaryDID = 128;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_3G_AUDIO_DATA_FIRST:
    GstVideoAncillaryDID = 160;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_3G_AUDIO_DATA_LAST:
    GstVideoAncillaryDID = 167;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_HDTV_AUDIO_DATA_FIRST:
    GstVideoAncillaryDID = 224;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_HDTV_AUDIO_DATA_LAST:
    GstVideoAncillaryDID = 231;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_SDTV_AUDIO_DATA_1_FIRST:
    GstVideoAncillaryDID = 236;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_SDTV_AUDIO_DATA_1_LAST:
    GstVideoAncillaryDID = 239;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_CAMERA_POSITION: GstVideoAncillaryDID = 240;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_ERROR_DETECTION: GstVideoAncillaryDID =
    244;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_SDTV_AUDIO_DATA_2_FIRST:
    GstVideoAncillaryDID = 248;
pub const GstVideoAncillaryDID_GST_VIDEO_ANCILLARY_DID_HANC_SDTV_AUDIO_DATA_2_LAST:
    GstVideoAncillaryDID = 255;
#[doc = " GstVideoAncillaryDID:\n\n Since: 1.16"]
pub type GstVideoAncillaryDID = ::std::os::raw::c_uint;
pub const GstVideoAncillaryDID16_GST_VIDEO_ANCILLARY_DID16_S334_EIA_708: GstVideoAncillaryDID16 =
    24833;
pub const GstVideoAncillaryDID16_GST_VIDEO_ANCILLARY_DID16_S334_EIA_608: GstVideoAncillaryDID16 =
    24834;
pub const GstVideoAncillaryDID16_GST_VIDEO_ANCILLARY_DID16_S2016_3_AFD_BAR: GstVideoAncillaryDID16 =
    16645;
#[doc = " GstVideoAncillaryDID16:\n @GST_VIDEO_ANCILLARY_DID16_S334_EIA_708: CEA 708 Ancillary data according to SMPTE 334\n @GST_VIDEO_ANCILLARY_DID16_S334_EIA_608: CEA 608 Ancillary data according to SMPTE 334\n @GST_VIDEO_ANCILLARY_DID16_S2016_3_AFD_BAR: AFD/Bar Ancillary data according to SMPTE 2016-3 (Since: 1.18)\n\n Some know types of Ancillary Data identifiers.\n\n Since: 1.16"]
pub type GstVideoAncillaryDID16 = ::std::os::raw::c_uint;
pub const GstVideoAFDValue_GST_VIDEO_AFD_UNAVAILABLE: GstVideoAFDValue = 0;
pub const GstVideoAFDValue_GST_VIDEO_AFD_16_9_TOP_ALIGNED: GstVideoAFDValue = 2;
pub const GstVideoAFDValue_GST_VIDEO_AFD_14_9_TOP_ALIGNED: GstVideoAFDValue = 3;
pub const GstVideoAFDValue_GST_VIDEO_AFD_GREATER_THAN_16_9: GstVideoAFDValue = 4;
pub const GstVideoAFDValue_GST_VIDEO_AFD_4_3_FULL_16_9_FULL: GstVideoAFDValue = 8;
pub const GstVideoAFDValue_GST_VIDEO_AFD_4_3_FULL_4_3_PILLAR: GstVideoAFDValue = 9;
pub const GstVideoAFDValue_GST_VIDEO_AFD_16_9_LETTER_16_9_FULL: GstVideoAFDValue = 10;
pub const GstVideoAFDValue_GST_VIDEO_AFD_14_9_LETTER_14_9_PILLAR: GstVideoAFDValue = 11;
pub const GstVideoAFDValue_GST_VIDEO_AFD_4_3_FULL_14_9_CENTER: GstVideoAFDValue = 13;
pub const GstVideoAFDValue_GST_VIDEO_AFD_16_9_LETTER_14_9_CENTER: GstVideoAFDValue = 14;
pub const GstVideoAFDValue_GST_VIDEO_AFD_16_9_LETTER_4_3_CENTER: GstVideoAFDValue = 15;
#[doc = " GstVideoAFDValue:\n @GST_VIDEO_AFD_UNAVAILABLE: Unavailable (see note 0 below).\n @GST_VIDEO_AFD_16_9_TOP_ALIGNED: For 4:3 coded frame, letterbox 16:9 image,\n      at top of the coded frame. For 16:9 coded frame, full frame 16:9 image,\n      the same as the coded frame.\n @GST_VIDEO_AFD_14_9_TOP_ALIGNED: For 4:3 coded frame, letterbox 14:9 image,\n      at top of the coded frame. For 16:9 coded frame, pillarbox 14:9 image,\n      horizontally centered in the coded frame.\n @GST_VIDEO_AFD_GREATER_THAN_16_9: For 4:3 coded frame, letterbox image with an aspect ratio\n      greater than 16:9, vertically centered in the coded frame. For 16:9 coded frame,\n      letterbox image with an aspect ratio greater than 16:9.\n @GST_VIDEO_AFD_4_3_FULL_16_9_FULL: For 4:3 coded frame, full frame 4:3 image,\n      the same as the coded frame. For 16:9 coded frame, full frame 16:9 image, the same as\n      the coded frame.\n @GST_VIDEO_AFD_4_3_FULL_4_3_PILLAR: For 4:3 coded frame, full frame 4:3 image, the same as\n      the coded frame. For 16:9 coded frame, pillarbox 4:3 image, horizontally centered in the\n      coded frame.\n @GST_VIDEO_AFD_16_9_LETTER_16_9_FULL: For 4:3 coded frame, letterbox 16:9 image, vertically centered in\n      the coded frame with all image areas protected. For 16:9 coded frame, full frame 16:9 image,\n      with all image areas protected.\n @GST_VIDEO_AFD_14_9_LETTER_14_9_PILLAR: For 4:3 coded frame, letterbox 14:9 image, vertically centered in\n      the coded frame. For 16:9 coded frame, pillarbox 14:9 image, horizontally centered in the\n      coded frame.\n @GST_VIDEO_AFD_4_3_FULL_14_9_CENTER: For 4:3 coded frame, full frame 4:3 image, with alternative 14:9\n      center. For 16:9 coded frame, pillarbox 4:3 image, with alternative 14:9 center.\n @GST_VIDEO_AFD_16_9_LETTER_14_9_CENTER: For 4:3 coded frame, letterbox 16:9 image, with alternative 14:9\n      center. For 16:9 coded frame, full frame 16:9 image, with alternative 14:9 center.\n @GST_VIDEO_AFD_16_9_LETTER_4_3_CENTER: For 4:3 coded frame, letterbox 16:9 image, with alternative 4:3\n      center. For 16:9 coded frame, full frame 16:9 image, with alternative 4:3 center.\n\n Enumeration of the various values for Active Format Description (AFD)\n\n AFD should be included in video user data whenever the rectangular\n picture area containing useful information does not extend to the full height or width of the coded\n frame. AFD data may also be included in user data when the rectangular picture area containing\n useful information extends to the full height and width of the coded frame.\n\n For details, see Table 6.14 Active Format in:\n\n ATSC Digital Television Standard:\n Part 4  MPEG-2 Video System Characteristics\n\n https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf\n\n and Active Format Description in Complete list of AFD codes\n\n https://en.wikipedia.org/wiki/Active_Format_Description#Complete_list_of_AFD_codes\n\n and SMPTE ST2016-1\n\n Notes:\n\n 1) AFD 0 is undefined for ATSC and SMPTE ST2016-1, indicating that AFD data is not available:\n If Bar Data is not present, AFD '0000' indicates that exact information\n is not available and the active image should be assumed to be the same as the coded frame. AFD '0000'.\n AFD '0000' accompanied by Bar Data signals that the active images aspect ratio is narrower than 16:9,\n but is not 4:3 or 14:9. As the exact aspect ratio cannot be conveyed by AFD alone, wherever possible,\n AFD 0000 should be accompanied by Bar Data to define the exact vertical or horizontal extent\n of the active image.\n 2) AFD 0 is reserved for DVB/ETSI\n 3) values 1, 5, 6, 7, and 12 are reserved for both ATSC and DVB/ETSI\n 4) values 2 and 3 are not recommended for ATSC, but are valid for DVB/ETSI\n\n Since: 1.18"]
pub type GstVideoAFDValue = ::std::os::raw::c_uint;
pub const GstVideoAFDSpec_GST_VIDEO_AFD_SPEC_DVB_ETSI: GstVideoAFDSpec = 0;
pub const GstVideoAFDSpec_GST_VIDEO_AFD_SPEC_ATSC_A53: GstVideoAFDSpec = 1;
pub const GstVideoAFDSpec_GST_VIDEO_AFD_SPEC_SMPTE_ST2016_1: GstVideoAFDSpec = 2;
#[doc = " GstVideoAFDSpec:\n @GST_VIDEO_AFD_SPEC_DVB_ETSI: AFD value is from DVB/ETSI standard\n @GST_VIDEO_AFD_SPEC_ATSC_A53: AFD value is from ATSC A/53 standard\n @GST_VIDEO_AFD_SPEC_SMPT_ST2016_1 : AFD value is from SMPTE ST2016-1 standard\n\n Enumeration of the different standards that may apply to AFD data:\n\n 0) ETSI/DVB:\n https://www.etsi.org/deliver/etsi_ts/101100_101199/101154/02.01.01_60/ts_101154v020101p.pdf\n\n 1) ATSC A/53:\n https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf\n\n 2) SMPTE ST2016-1:\n\n Since: 1.18"]
pub type GstVideoAFDSpec = ::std::os::raw::c_uint;
#[doc = " GstVideoAFDMeta:\n @meta: parent #GstMeta\n @field: 0 for progressive or field 1 and 1 for field 2\n @spec: #GstVideoAFDSpec that applies to @afd\n @afd: #GstVideoAFDValue AFD value\n\n Active Format Description (AFD)\n\n For details, see Table 6.14 Active Format in:\n\n ATSC Digital Television Standard:\n Part 4  MPEG-2 Video System Characteristics\n\n https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf\n\n and Active Format Description in Complete list of AFD codes\n\n https://en.wikipedia.org/wiki/Active_Format_Description#Complete_list_of_AFD_codes\n\n and SMPTE ST2016-1\n\n Since: 1.18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoAFDMeta {
    pub meta: GstMeta,
    pub field: guint8,
    pub spec: GstVideoAFDSpec,
    pub afd: GstVideoAFDValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoAFDMeta"][::std::mem::size_of::<GstVideoAFDMeta>() - 32usize];
    ["Alignment of GstVideoAFDMeta"][::std::mem::align_of::<GstVideoAFDMeta>() - 8usize];
    ["Offset of field: GstVideoAFDMeta::meta"]
        [::std::mem::offset_of!(GstVideoAFDMeta, meta) - 0usize];
    ["Offset of field: GstVideoAFDMeta::field"]
        [::std::mem::offset_of!(GstVideoAFDMeta, field) - 16usize];
    ["Offset of field: GstVideoAFDMeta::spec"]
        [::std::mem::offset_of!(GstVideoAFDMeta, spec) - 20usize];
    ["Offset of field: GstVideoAFDMeta::afd"]
        [::std::mem::offset_of!(GstVideoAFDMeta, afd) - 24usize];
};
unsafe extern "C" {
    pub fn gst_video_afd_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_afd_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_afd_meta(
        buffer: *mut GstBuffer,
        field: guint8,
        spec: GstVideoAFDSpec,
        afd: GstVideoAFDValue,
    ) -> *mut GstVideoAFDMeta;
}
#[doc = " GstVideoBarMeta:\n @meta: parent #GstMeta\n @field: 0 for progressive or field 1 and 1 for field 2\n @is_letterbox: if true then bar data specifies letterbox, otherwise pillarbox\n @bar_data1: If @is_letterbox is true, then the value specifies the\n      last line of a horizontal letterbox bar area at top of reconstructed frame.\n      Otherwise, it specifies the last horizontal luminance sample of a vertical pillarbox\n      bar area at the left side of the reconstructed frame\n @bar_data2: If @is_letterbox is true, then the value specifies the\n      first line of a horizontal letterbox bar area at bottom of reconstructed frame.\n      Otherwise, it specifies the first horizontal\n      luminance sample of a vertical pillarbox bar area at the right side of the reconstructed frame.\n\n Bar data should be included in video user data\n whenever the rectangular picture area containing useful information\n does not extend to the full height or width of the coded frame\n and AFD alone is insufficient to describe the extent of the image.\n\n Note: either vertical or horizontal bars are specified, but not both.\n\n For more details, see:\n\n https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf\n\n and SMPTE ST2016-1\n\n Since: 1.18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoBarMeta {
    pub meta: GstMeta,
    pub field: guint8,
    pub is_letterbox: gboolean,
    pub bar_data1: guint,
    pub bar_data2: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoBarMeta"][::std::mem::size_of::<GstVideoBarMeta>() - 32usize];
    ["Alignment of GstVideoBarMeta"][::std::mem::align_of::<GstVideoBarMeta>() - 8usize];
    ["Offset of field: GstVideoBarMeta::meta"]
        [::std::mem::offset_of!(GstVideoBarMeta, meta) - 0usize];
    ["Offset of field: GstVideoBarMeta::field"]
        [::std::mem::offset_of!(GstVideoBarMeta, field) - 16usize];
    ["Offset of field: GstVideoBarMeta::is_letterbox"]
        [::std::mem::offset_of!(GstVideoBarMeta, is_letterbox) - 20usize];
    ["Offset of field: GstVideoBarMeta::bar_data1"]
        [::std::mem::offset_of!(GstVideoBarMeta, bar_data1) - 24usize];
    ["Offset of field: GstVideoBarMeta::bar_data2"]
        [::std::mem::offset_of!(GstVideoBarMeta, bar_data2) - 28usize];
};
unsafe extern "C" {
    pub fn gst_video_bar_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_bar_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_bar_meta(
        buffer: *mut GstBuffer,
        field: guint8,
        is_letterbox: gboolean,
        bar_data1: guint,
        bar_data2: guint,
    ) -> *mut GstVideoBarMeta;
}
pub const GstVideoCaptionType_GST_VIDEO_CAPTION_TYPE_UNKNOWN: GstVideoCaptionType = 0;
pub const GstVideoCaptionType_GST_VIDEO_CAPTION_TYPE_CEA608_RAW: GstVideoCaptionType = 1;
pub const GstVideoCaptionType_GST_VIDEO_CAPTION_TYPE_CEA608_S334_1A: GstVideoCaptionType = 2;
pub const GstVideoCaptionType_GST_VIDEO_CAPTION_TYPE_CEA708_RAW: GstVideoCaptionType = 3;
pub const GstVideoCaptionType_GST_VIDEO_CAPTION_TYPE_CEA708_CDP: GstVideoCaptionType = 4;
#[doc = " GstVideoCaptionType:\n @GST_VIDEO_CAPTION_TYPE_UNKNOWN: Unknown type of CC\n @GST_VIDEO_CAPTION_TYPE_CEA608_RAW: CEA-608 as byte pairs. Note that\n      this format is not recommended since is does not specify to\n      which field the caption comes from and therefore assumes\n      it comes from the first field (and that there is no information\n      on the second field). Use @GST_VIDEO_CAPTION_TYPE_CEA708_RAW\n      if you wish to store CEA-608 from two fields and prefix each byte pair\n      with 0xFC for the first field and 0xFD for the second field.\n @GST_VIDEO_CAPTION_TYPE_CEA608_S334_1A: CEA-608 as byte triplets as defined\n      in SMPTE S334-1 Annex A. The second and third byte of the byte triplet\n      is the raw CEA608 data, the first byte is a bitfield: The top/7th bit is\n      0 for the second field, 1 for the first field, bit 6 and 5 are 0 and\n      bits 4 to 0 are a 5 bit unsigned integer that represents the line\n      offset relative to the base-line of the original image format (line 9\n      for 525-line field 1, line 272 for 525-line field 2, line 5 for\n      625-line field 1 and line 318 for 625-line field 2).\n @GST_VIDEO_CAPTION_TYPE_CEA708_RAW: CEA-708 as cc_data byte triplets. They\n      can also contain 608-in-708 and the first byte of each triplet has to\n      be inspected for detecting the type.\n @GST_VIDEO_CAPTION_TYPE_CEA708_CDP: CEA-708 (and optionally CEA-608) in\n      a CDP (Caption Distribution Packet) defined by SMPTE S-334-2.\n      Contains the whole CDP (starting with 0x9669).\n\n The various known types of Closed Caption (CC).\n\n Since: 1.16"]
pub type GstVideoCaptionType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_caption_type_from_caps(caps: *const GstCaps) -> GstVideoCaptionType;
}
unsafe extern "C" {
    pub fn gst_video_caption_type_to_caps(type_: GstVideoCaptionType) -> *mut GstCaps;
}
#[doc = " GstVideoCaptionMeta:\n @meta: parent #GstMeta\n @caption_type: The type of Closed Caption contained in the meta.\n @data: (array length=size): The Closed Caption data.\n @size: The size in bytes of @data\n\n Extra buffer metadata providing Closed Caption.\n\n Since: 1.16"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GstVideoCaptionMeta {
    pub meta: GstMeta,
    pub caption_type: GstVideoCaptionType,
    pub data: *mut guint8,
    pub size: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GstVideoCaptionMeta"][::std::mem::size_of::<GstVideoCaptionMeta>() - 40usize];
    ["Alignment of GstVideoCaptionMeta"][::std::mem::align_of::<GstVideoCaptionMeta>() - 8usize];
    ["Offset of field: GstVideoCaptionMeta::meta"]
        [::std::mem::offset_of!(GstVideoCaptionMeta, meta) - 0usize];
    ["Offset of field: GstVideoCaptionMeta::caption_type"]
        [::std::mem::offset_of!(GstVideoCaptionMeta, caption_type) - 16usize];
    ["Offset of field: GstVideoCaptionMeta::data"]
        [::std::mem::offset_of!(GstVideoCaptionMeta, data) - 24usize];
    ["Offset of field: GstVideoCaptionMeta::size"]
        [::std::mem::offset_of!(GstVideoCaptionMeta, size) - 32usize];
};
unsafe extern "C" {
    pub fn gst_video_caption_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_caption_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_caption_meta(
        buffer: *mut GstBuffer,
        caption_type: GstVideoCaptionType,
        data: *const guint8,
        size: gsize,
    ) -> *mut GstVideoCaptionMeta;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoVBIParser {
    _unused: [u8; 0],
}
#[doc = " GstVideoVBIParser:\n\n A parser for detecting and extracting @GstVideoAncillary data from\n Vertical Blanking Interval lines of component signals.\n\n Since: 1.16"]
pub type GstVideoVBIParser = _GstVideoVBIParser;
unsafe extern "C" {
    pub fn gst_video_vbi_parser_get_type() -> GType;
}
pub const GstVideoVBIParserResult_GST_VIDEO_VBI_PARSER_RESULT_DONE: GstVideoVBIParserResult = 0;
pub const GstVideoVBIParserResult_GST_VIDEO_VBI_PARSER_RESULT_OK: GstVideoVBIParserResult = 1;
pub const GstVideoVBIParserResult_GST_VIDEO_VBI_PARSER_RESULT_ERROR: GstVideoVBIParserResult = 2;
#[doc = " GstVideoVBIParserResult:\n @GST_VIDEO_VBI_PARSER_RESULT_DONE: No line were provided, or no more Ancillary data was found.\n @GST_VIDEO_VBI_PARSER_RESULT_OK: A #GstVideoAncillary was found.\n @GST_VIDEO_VBI_PARSER_RESULT_ERROR: An error occurred\n\n Return values for #GstVideoVBIParser\n\n Since: 1.16"]
pub type GstVideoVBIParserResult = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_vbi_parser_get_ancillary(
        parser: *mut GstVideoVBIParser,
        anc: *mut GstVideoAncillary,
    ) -> GstVideoVBIParserResult;
}
unsafe extern "C" {
    pub fn gst_video_vbi_parser_new(
        format: GstVideoFormat,
        pixel_width: guint32,
    ) -> *mut GstVideoVBIParser;
}
unsafe extern "C" {
    pub fn gst_video_vbi_parser_copy(parser: *const GstVideoVBIParser) -> *mut GstVideoVBIParser;
}
unsafe extern "C" {
    pub fn gst_video_vbi_parser_free(parser: *mut GstVideoVBIParser);
}
unsafe extern "C" {
    pub fn gst_video_vbi_parser_add_line(parser: *mut GstVideoVBIParser, data: *const guint8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoVBIEncoder {
    _unused: [u8; 0],
}
#[doc = " GstVideoVBIEncoder:\n\n An encoder for writing ancillary data to the\n Vertical Blanking Interval lines of component signals.\n\n Since: 1.16"]
pub type GstVideoVBIEncoder = _GstVideoVBIEncoder;
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_new(
        format: GstVideoFormat,
        pixel_width: guint32,
    ) -> *mut GstVideoVBIEncoder;
}
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_copy(
        encoder: *const GstVideoVBIEncoder,
    ) -> *mut GstVideoVBIEncoder;
}
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_free(encoder: *mut GstVideoVBIEncoder);
}
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_add_ancillary(
        encoder: *mut GstVideoVBIEncoder,
        composite: gboolean,
        DID: guint8,
        SDID_block_number: guint8,
        data: *const guint8,
        data_count: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_vbi_encoder_write_line(encoder: *mut GstVideoVBIEncoder, data: *mut guint8);
}
unsafe extern "C" {
    pub fn gst_video_blend_scale_linear_RGBA(
        src: *mut GstVideoInfo,
        src_buffer: *mut GstBuffer,
        dest_height: gint,
        dest_width: gint,
        dest: *mut GstVideoInfo,
        dest_buffer: *mut *mut GstBuffer,
    );
}
unsafe extern "C" {
    pub fn gst_video_blend(
        dest: *mut GstVideoFrame,
        src: *mut GstVideoFrame,
        x: gint,
        y: gint,
        global_alpha: gfloat,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoDirection {
    _unused: [u8; 0],
}
#[doc = " GstVideoDirection:\n\n Opaque #GstVideoDirection data structure.\n\n Since: 1.10"]
pub type GstVideoDirection = _GstVideoDirection;
#[doc = " GstVideoDirectionInterface:\n @iface: parent interface type.\n\n #GstVideoDirectionInterface interface.\n\n Since: 1.10"]
pub type GstVideoDirectionInterface = _GstVideoDirectionInterface;
#[doc = " GstVideoDirectionInterface:\n @iface: parent interface type.\n\n #GstVideoDirectionInterface interface.\n\n Since: 1.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoDirectionInterface {
    pub iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoDirectionInterface"]
        [::std::mem::size_of::<_GstVideoDirectionInterface>() - 16usize];
    ["Alignment of _GstVideoDirectionInterface"]
        [::std::mem::align_of::<_GstVideoDirectionInterface>() - 8usize];
    ["Offset of field: _GstVideoDirectionInterface::iface"]
        [::std::mem::offset_of!(_GstVideoDirectionInterface, iface) - 0usize];
};
unsafe extern "C" {
    pub fn gst_video_direction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_event_new_still_frame(in_still: gboolean) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_video_event_parse_still_frame(
        event: *mut GstEvent,
        in_still: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_event_new_downstream_force_key_unit(
        timestamp: GstClockTime,
        stream_time: GstClockTime,
        running_time: GstClockTime,
        all_headers: gboolean,
        count: guint,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_video_event_parse_downstream_force_key_unit(
        event: *mut GstEvent,
        timestamp: *mut GstClockTime,
        stream_time: *mut GstClockTime,
        running_time: *mut GstClockTime,
        all_headers: *mut gboolean,
        count: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_event_new_upstream_force_key_unit(
        running_time: GstClockTime,
        all_headers: gboolean,
        count: guint,
    ) -> *mut GstEvent;
}
unsafe extern "C" {
    pub fn gst_video_event_parse_upstream_force_key_unit(
        event: *mut GstEvent,
        running_time: *mut GstClockTime,
        all_headers: *mut gboolean,
        count: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_event_is_force_key_unit(event: *mut GstEvent) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOrientation {
    _unused: [u8; 0],
}
#[doc = " GstVideoOrientation:\n\n Opaque #GstVideoOrientation data structure."]
pub type GstVideoOrientation = _GstVideoOrientation;
#[doc = " GstVideoOrientationInterface:\n @iface: parent interface type.\n @get_hflip: virtual method to get horizontal flipping state\n @get_vflip: virtual method to get vertical flipping state\n @get_hcenter: virtual method to get horizontal centering state\n @get_vcenter: virtual method to get vertical centering state\n @set_hflip: virtual method to set horizontal flipping state\n @set_vflip: virtual method to set vertical flipping state\n @set_hcenter: virtual method to set horizontal centering state\n @set_vcenter: virtual method to set vertical centering state\n\n #GstVideoOrientationInterface interface."]
pub type GstVideoOrientationInterface = _GstVideoOrientationInterface;
#[doc = " GstVideoOrientationInterface:\n @iface: parent interface type.\n @get_hflip: virtual method to get horizontal flipping state\n @get_vflip: virtual method to get vertical flipping state\n @get_hcenter: virtual method to get horizontal centering state\n @get_vcenter: virtual method to get vertical centering state\n @set_hflip: virtual method to set horizontal flipping state\n @set_vflip: virtual method to set vertical flipping state\n @set_hcenter: virtual method to set horizontal centering state\n @set_vcenter: virtual method to set vertical centering state\n\n #GstVideoOrientationInterface interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOrientationInterface {
    pub iface: GTypeInterface,
    pub get_hflip: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            flip: *mut gboolean,
        ) -> gboolean,
    >,
    pub get_vflip: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            flip: *mut gboolean,
        ) -> gboolean,
    >,
    pub get_hcenter: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            center: *mut gint,
        ) -> gboolean,
    >,
    pub get_vcenter: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            center: *mut gint,
        ) -> gboolean,
    >,
    pub set_hflip: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            flip: gboolean,
        ) -> gboolean,
    >,
    pub set_vflip: ::std::option::Option<
        unsafe extern "C" fn(
            video_orientation: *mut GstVideoOrientation,
            flip: gboolean,
        ) -> gboolean,
    >,
    pub set_hcenter: ::std::option::Option<
        unsafe extern "C" fn(video_orientation: *mut GstVideoOrientation, center: gint) -> gboolean,
    >,
    pub set_vcenter: ::std::option::Option<
        unsafe extern "C" fn(video_orientation: *mut GstVideoOrientation, center: gint) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoOrientationInterface"]
        [::std::mem::size_of::<_GstVideoOrientationInterface>() - 80usize];
    ["Alignment of _GstVideoOrientationInterface"]
        [::std::mem::align_of::<_GstVideoOrientationInterface>() - 8usize];
    ["Offset of field: _GstVideoOrientationInterface::iface"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, iface) - 0usize];
    ["Offset of field: _GstVideoOrientationInterface::get_hflip"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, get_hflip) - 16usize];
    ["Offset of field: _GstVideoOrientationInterface::get_vflip"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, get_vflip) - 24usize];
    ["Offset of field: _GstVideoOrientationInterface::get_hcenter"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, get_hcenter) - 32usize];
    ["Offset of field: _GstVideoOrientationInterface::get_vcenter"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, get_vcenter) - 40usize];
    ["Offset of field: _GstVideoOrientationInterface::set_hflip"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, set_hflip) - 48usize];
    ["Offset of field: _GstVideoOrientationInterface::set_vflip"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, set_vflip) - 56usize];
    ["Offset of field: _GstVideoOrientationInterface::set_hcenter"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, set_hcenter) - 64usize];
    ["Offset of field: _GstVideoOrientationInterface::set_vcenter"]
        [::std::mem::offset_of!(_GstVideoOrientationInterface, set_vcenter) - 72usize];
};
unsafe extern "C" {
    pub fn gst_video_orientation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_orientation_get_hflip(
        video_orientation: *mut GstVideoOrientation,
        flip: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_get_vflip(
        video_orientation: *mut GstVideoOrientation,
        flip: *mut gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_get_hcenter(
        video_orientation: *mut GstVideoOrientation,
        center: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_get_vcenter(
        video_orientation: *mut GstVideoOrientation,
        center: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_set_hflip(
        video_orientation: *mut GstVideoOrientation,
        flip: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_set_vflip(
        video_orientation: *mut GstVideoOrientation,
        flip: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_set_hcenter(
        video_orientation: *mut GstVideoOrientation,
        center: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_orientation_set_vcenter(
        video_orientation: *mut GstVideoOrientation,
        center: gint,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOverlayRectangle {
    _unused: [u8; 0],
}
pub type GstVideoOverlayRectangle = _GstVideoOverlayRectangle;
pub const GstVideoOverlayFormatFlags_GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE:
    GstVideoOverlayFormatFlags = 0;
pub const GstVideoOverlayFormatFlags_GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA:
    GstVideoOverlayFormatFlags = 1;
pub const GstVideoOverlayFormatFlags_GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA:
    GstVideoOverlayFormatFlags = 2;
#[doc = " GstVideoOverlayFormatFlags:\n @GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE: no flags\n @GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA: RGB are premultiplied by A/255.\n @GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA: a global-alpha value != 1 is set.\n\n Overlay format flags."]
pub type GstVideoOverlayFormatFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_new_raw(
        pixels: *mut GstBuffer,
        render_x: gint,
        render_y: gint,
        render_width: guint,
        render_height: guint,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstVideoOverlayRectangle;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_copy(
        rectangle: *mut GstVideoOverlayRectangle,
    ) -> *mut GstVideoOverlayRectangle;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_seqnum(
        rectangle: *mut GstVideoOverlayRectangle,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_set_render_rectangle(
        rectangle: *mut GstVideoOverlayRectangle,
        render_x: gint,
        render_y: gint,
        render_width: guint,
        render_height: guint,
    );
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_render_rectangle(
        rectangle: *mut GstVideoOverlayRectangle,
        render_x: *mut gint,
        render_y: *mut gint,
        render_width: *mut guint,
        render_height: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_raw(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_argb(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_ayuv(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_raw(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_argb(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_ayuv(
        rectangle: *mut GstVideoOverlayRectangle,
        flags: GstVideoOverlayFormatFlags,
    ) -> *mut GstBuffer;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_flags(
        rectangle: *mut GstVideoOverlayRectangle,
    ) -> GstVideoOverlayFormatFlags;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_get_global_alpha(
        rectangle: *mut GstVideoOverlayRectangle,
    ) -> gfloat;
}
unsafe extern "C" {
    pub fn gst_video_overlay_rectangle_set_global_alpha(
        rectangle: *mut GstVideoOverlayRectangle,
        global_alpha: gfloat,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOverlayComposition {
    _unused: [u8; 0],
}
pub type GstVideoOverlayComposition = _GstVideoOverlayComposition;
unsafe extern "C" {
    pub fn gst_video_overlay_composition_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_copy(
        comp: *mut GstVideoOverlayComposition,
    ) -> *mut GstVideoOverlayComposition;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_make_writable(
        comp: *mut GstVideoOverlayComposition,
    ) -> *mut GstVideoOverlayComposition;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_new(
        rectangle: *mut GstVideoOverlayRectangle,
    ) -> *mut GstVideoOverlayComposition;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_add_rectangle(
        comp: *mut GstVideoOverlayComposition,
        rectangle: *mut GstVideoOverlayRectangle,
    );
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_n_rectangles(
        comp: *mut GstVideoOverlayComposition,
    ) -> guint;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_get_rectangle(
        comp: *mut GstVideoOverlayComposition,
        n: guint,
    ) -> *mut GstVideoOverlayRectangle;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_get_seqnum(comp: *mut GstVideoOverlayComposition)
    -> guint;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_blend(
        comp: *mut GstVideoOverlayComposition,
        video_buf: *mut GstVideoFrame,
    ) -> gboolean;
}
#[doc = " GstVideoOverlayCompositionMeta:\n @meta: parent #GstMeta\n @overlay: the attached #GstVideoOverlayComposition\n\n Extra buffer metadata describing image overlay data."]
pub type GstVideoOverlayCompositionMeta = _GstVideoOverlayCompositionMeta;
#[doc = " GstVideoOverlayCompositionMeta:\n @meta: parent #GstMeta\n @overlay: the attached #GstVideoOverlayComposition\n\n Extra buffer metadata describing image overlay data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOverlayCompositionMeta {
    pub meta: GstMeta,
    pub overlay: *mut GstVideoOverlayComposition,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoOverlayCompositionMeta"]
        [::std::mem::size_of::<_GstVideoOverlayCompositionMeta>() - 24usize];
    ["Alignment of _GstVideoOverlayCompositionMeta"]
        [::std::mem::align_of::<_GstVideoOverlayCompositionMeta>() - 8usize];
    ["Offset of field: _GstVideoOverlayCompositionMeta::meta"]
        [::std::mem::offset_of!(_GstVideoOverlayCompositionMeta, meta) - 0usize];
    ["Offset of field: _GstVideoOverlayCompositionMeta::overlay"]
        [::std::mem::offset_of!(_GstVideoOverlayCompositionMeta, overlay) - 16usize];
};
unsafe extern "C" {
    pub fn gst_video_overlay_composition_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_overlay_composition_meta_get_info() -> *const GstMetaInfo;
}
unsafe extern "C" {
    pub fn gst_buffer_add_video_overlay_composition_meta(
        buf: *mut GstBuffer,
        comp: *mut GstVideoOverlayComposition,
    ) -> *mut GstVideoOverlayCompositionMeta;
}
pub type GstVideoOverlayComposition_autoptr = *mut GstVideoOverlayComposition;
pub type GstVideoOverlayComposition_listautoptr = *mut GList;
pub type GstVideoOverlayComposition_slistautoptr = *mut GSList;
pub type GstVideoOverlayComposition_queueautoptr = *mut GQueue;
pub type GstVideoOverlayRectangle_autoptr = *mut GstVideoOverlayRectangle;
pub type GstVideoOverlayRectangle_listautoptr = *mut GList;
pub type GstVideoOverlayRectangle_slistautoptr = *mut GSList;
pub type GstVideoOverlayRectangle_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOverlay {
    _unused: [u8; 0],
}
#[doc = " GstVideoOverlay:\n\n Opaque #GstVideoOverlay interface structure"]
pub type GstVideoOverlay = _GstVideoOverlay;
#[doc = " GstVideoOverlayInterface:\n @iface: parent interface type.\n @expose: virtual method to handle expose events\n @handle_events: virtual method to handle events\n @set_render_rectangle: virtual method to set the render rectangle\n @set_window_handle: virtual method to configure the window handle\n\n #GstVideoOverlay interface"]
pub type GstVideoOverlayInterface = _GstVideoOverlayInterface;
#[doc = " GstVideoOverlayInterface:\n @iface: parent interface type.\n @expose: virtual method to handle expose events\n @handle_events: virtual method to handle events\n @set_render_rectangle: virtual method to set the render rectangle\n @set_window_handle: virtual method to configure the window handle\n\n #GstVideoOverlay interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstVideoOverlayInterface {
    pub iface: GTypeInterface,
    pub expose: ::std::option::Option<unsafe extern "C" fn(overlay: *mut GstVideoOverlay)>,
    pub handle_events: ::std::option::Option<
        unsafe extern "C" fn(overlay: *mut GstVideoOverlay, handle_events: gboolean),
    >,
    pub set_render_rectangle: ::std::option::Option<
        unsafe extern "C" fn(
            overlay: *mut GstVideoOverlay,
            x: gint,
            y: gint,
            width: gint,
            height: gint,
        ),
    >,
    pub set_window_handle: ::std::option::Option<
        unsafe extern "C" fn(overlay: *mut GstVideoOverlay, handle: guintptr),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GstVideoOverlayInterface"]
        [::std::mem::size_of::<_GstVideoOverlayInterface>() - 48usize];
    ["Alignment of _GstVideoOverlayInterface"]
        [::std::mem::align_of::<_GstVideoOverlayInterface>() - 8usize];
    ["Offset of field: _GstVideoOverlayInterface::iface"]
        [::std::mem::offset_of!(_GstVideoOverlayInterface, iface) - 0usize];
    ["Offset of field: _GstVideoOverlayInterface::expose"]
        [::std::mem::offset_of!(_GstVideoOverlayInterface, expose) - 16usize];
    ["Offset of field: _GstVideoOverlayInterface::handle_events"]
        [::std::mem::offset_of!(_GstVideoOverlayInterface, handle_events) - 24usize];
    ["Offset of field: _GstVideoOverlayInterface::set_render_rectangle"]
        [::std::mem::offset_of!(_GstVideoOverlayInterface, set_render_rectangle) - 32usize];
    ["Offset of field: _GstVideoOverlayInterface::set_window_handle"]
        [::std::mem::offset_of!(_GstVideoOverlayInterface, set_window_handle) - 40usize];
};
unsafe extern "C" {
    pub fn gst_video_overlay_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gst_video_overlay_set_render_rectangle(
        overlay: *mut GstVideoOverlay,
        x: gint,
        y: gint,
        width: gint,
        height: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_overlay_expose(overlay: *mut GstVideoOverlay);
}
unsafe extern "C" {
    pub fn gst_video_overlay_handle_events(overlay: *mut GstVideoOverlay, handle_events: gboolean);
}
unsafe extern "C" {
    pub fn gst_video_overlay_set_window_handle(overlay: *mut GstVideoOverlay, handle: guintptr);
}
unsafe extern "C" {
    pub fn gst_video_overlay_got_window_handle(overlay: *mut GstVideoOverlay, handle: guintptr);
}
unsafe extern "C" {
    pub fn gst_video_overlay_prepare_window_handle(overlay: *mut GstVideoOverlay);
}
unsafe extern "C" {
    pub fn gst_is_video_overlay_prepare_window_handle_message(msg: *mut GstMessage) -> gboolean;
}
unsafe extern "C" {
    pub fn gst_video_overlay_install_properties(oclass: *mut GObjectClass, last_prop_id: gint);
}
unsafe extern "C" {
    pub fn gst_video_overlay_set_property(
        object: *mut GObject,
        last_prop_id: gint,
        property_id: guint,
        value: *const GValue,
    ) -> gboolean;
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:\n @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when\n     needed. The default action is to bind all symbols when the module\n     is loaded.\n @G_MODULE_BIND_LOCAL: specifies that symbols in the module should\n     not be added to the global name space. The default action on most\n     platforms is to place symbols in the module in the global name space,\n     which may cause conflicts with existing symbols.\n @G_MODULE_BIND_MASK: mask for all flags.\n\n Flags passed to g_module_open().\n Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
unsafe extern "C" {
    pub fn g_module_error_quark() -> GQuark;
}
pub const GModuleError_G_MODULE_ERROR_FAILED: GModuleError = 0;
pub const GModuleError_G_MODULE_ERROR_CHECK_FAILED: GModuleError = 1;
#[doc = " GModuleError:\n @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file\n @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function\n\n Errors returned by g_module_open_full().\n\n Since: 2.70"]
pub type GModuleError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_module_supported() -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_open_full(
        file_name: *const gchar,
        flags: GModuleFlags,
        error: *mut *mut GError,
    ) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
unsafe extern "C" {
    pub fn g_module_error() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
#[doc = "< Specifies using the CPU for OSD processing.\nWorks with RGBA data only"]
pub const NvOSD_Mode_MODE_CPU: NvOSD_Mode = 0;
#[doc = "< Specifies using the GPU for OSD processing.\nCurrently not implemented."]
pub const NvOSD_Mode_MODE_GPU: NvOSD_Mode = 1;
#[doc = "< Invalid mode. Instead GPU mode will be used."]
pub const NvOSD_Mode_MODE_NONE: NvOSD_Mode = 2;
#[doc = " Defines modes used to overlay boxes and text."]
pub type NvOSD_Mode = ::std::os::raw::c_uint;
#[doc = " Specifies an arrow head only at start = 0."]
pub const NvOSD_Arrow_Head_Direction_START_HEAD: NvOSD_Arrow_Head_Direction = 0;
#[doc = " Specifies an arrow head only at end = 1."]
pub const NvOSD_Arrow_Head_Direction_END_HEAD: NvOSD_Arrow_Head_Direction = 1;
#[doc = " Specifies arrow heads at both start and end = 2."]
pub const NvOSD_Arrow_Head_Direction_BOTH_HEAD: NvOSD_Arrow_Head_Direction = 2;
#[doc = " Specifies arrow head positions."]
pub type NvOSD_Arrow_Head_Direction = ::std::os::raw::c_uint;
#[doc = " Holds unclipped bounding box coordinates of the object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvBbox_Coords {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvBbox_Coords"][::std::mem::size_of::<_NvBbox_Coords>() - 16usize];
    ["Alignment of _NvBbox_Coords"][::std::mem::align_of::<_NvBbox_Coords>() - 4usize];
    ["Offset of field: _NvBbox_Coords::left"]
        [::std::mem::offset_of!(_NvBbox_Coords, left) - 0usize];
    ["Offset of field: _NvBbox_Coords::top"][::std::mem::offset_of!(_NvBbox_Coords, top) - 4usize];
    ["Offset of field: _NvBbox_Coords::width"]
        [::std::mem::offset_of!(_NvBbox_Coords, width) - 8usize];
    ["Offset of field: _NvBbox_Coords::height"]
        [::std::mem::offset_of!(_NvBbox_Coords, height) - 12usize];
};
#[doc = " Holds unclipped bounding box coordinates of the object."]
pub type NvBbox_Coords = _NvBbox_Coords;
#[doc = " Holds the color parameters of the box or text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ColorParams {
    #[doc = "< Holds the red component of color.\nValue must be in the range 0.0-1.0."]
    pub red: f64,
    #[doc = "< Holds the green component of color.\nValue must be in the range 0.0-1.0."]
    pub green: f64,
    #[doc = "< Holds the blue component of color.\nValue must be in the range 0.0-1.0."]
    pub blue: f64,
    #[doc = "< Holds the alpha component of color.\nValue must be in the range 0.0-1.0."]
    pub alpha: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_ColorParams"][::std::mem::size_of::<_NvOSD_ColorParams>() - 32usize];
    ["Alignment of _NvOSD_ColorParams"][::std::mem::align_of::<_NvOSD_ColorParams>() - 8usize];
    ["Offset of field: _NvOSD_ColorParams::red"]
        [::std::mem::offset_of!(_NvOSD_ColorParams, red) - 0usize];
    ["Offset of field: _NvOSD_ColorParams::green"]
        [::std::mem::offset_of!(_NvOSD_ColorParams, green) - 8usize];
    ["Offset of field: _NvOSD_ColorParams::blue"]
        [::std::mem::offset_of!(_NvOSD_ColorParams, blue) - 16usize];
    ["Offset of field: _NvOSD_ColorParams::alpha"]
        [::std::mem::offset_of!(_NvOSD_ColorParams, alpha) - 24usize];
};
#[doc = " Holds the color parameters of the box or text to be overlayed."]
pub type NvOSD_ColorParams = _NvOSD_ColorParams;
#[doc = " Holds the font parameters of the text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_FontParams {
    #[doc = "< Holds a pointer to the string containing\nthe font name. To display a list of\nsupported fonts, run the fc-list command."]
    pub font_name: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the size of the font."]
    pub font_size: ::std::os::raw::c_uint,
    #[doc = "< Holds the font color."]
    pub font_color: NvOSD_ColorParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_FontParams"][::std::mem::size_of::<_NvOSD_FontParams>() - 48usize];
    ["Alignment of _NvOSD_FontParams"][::std::mem::align_of::<_NvOSD_FontParams>() - 8usize];
    ["Offset of field: _NvOSD_FontParams::font_name"]
        [::std::mem::offset_of!(_NvOSD_FontParams, font_name) - 0usize];
    ["Offset of field: _NvOSD_FontParams::font_size"]
        [::std::mem::offset_of!(_NvOSD_FontParams, font_size) - 8usize];
    ["Offset of field: _NvOSD_FontParams::font_color"]
        [::std::mem::offset_of!(_NvOSD_FontParams, font_color) - 16usize];
};
#[doc = " Holds the font parameters of the text to be overlayed."]
pub type NvOSD_FontParams = _NvOSD_FontParams;
#[doc = " Holds parameters of text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_TextParams {
    #[doc = "< Holds the text to be overlayed."]
    pub display_text: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the text's horizontal offset from\nthe top left pixel of the frame."]
    pub x_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the text's vertical offset from the\ntop left pixel of the frame."]
    pub y_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the font parameters of the text\nto be overlaid."]
    pub font_params: NvOSD_FontParams,
    #[doc = "< Holds a Boolean; true if the text has a\nbackground color."]
    pub set_bg_clr: ::std::os::raw::c_int,
    #[doc = "< Holds the text's background color, if\nspecified."]
    pub text_bg_clr: NvOSD_ColorParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_TextParams"][::std::mem::size_of::<_NvOSD_TextParams>() - 104usize];
    ["Alignment of _NvOSD_TextParams"][::std::mem::align_of::<_NvOSD_TextParams>() - 8usize];
    ["Offset of field: _NvOSD_TextParams::display_text"]
        [::std::mem::offset_of!(_NvOSD_TextParams, display_text) - 0usize];
    ["Offset of field: _NvOSD_TextParams::x_offset"]
        [::std::mem::offset_of!(_NvOSD_TextParams, x_offset) - 8usize];
    ["Offset of field: _NvOSD_TextParams::y_offset"]
        [::std::mem::offset_of!(_NvOSD_TextParams, y_offset) - 12usize];
    ["Offset of field: _NvOSD_TextParams::font_params"]
        [::std::mem::offset_of!(_NvOSD_TextParams, font_params) - 16usize];
    ["Offset of field: _NvOSD_TextParams::set_bg_clr"]
        [::std::mem::offset_of!(_NvOSD_TextParams, set_bg_clr) - 64usize];
    ["Offset of field: _NvOSD_TextParams::text_bg_clr"]
        [::std::mem::offset_of!(_NvOSD_TextParams, text_bg_clr) - 72usize];
};
#[doc = " Holds parameters of text to be overlayed."]
pub type NvOSD_TextParams = _NvOSD_TextParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_Color_info {
    pub id: ::std::os::raw::c_int,
    pub color: NvOSD_ColorParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_Color_info"][::std::mem::size_of::<_NvOSD_Color_info>() - 40usize];
    ["Alignment of _NvOSD_Color_info"][::std::mem::align_of::<_NvOSD_Color_info>() - 8usize];
    ["Offset of field: _NvOSD_Color_info::id"]
        [::std::mem::offset_of!(_NvOSD_Color_info, id) - 0usize];
    ["Offset of field: _NvOSD_Color_info::color"]
        [::std::mem::offset_of!(_NvOSD_Color_info, color) - 8usize];
};
pub type NvOSD_Color_info = _NvOSD_Color_info;
#[doc = " Holds the box parameters of the box to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_RectParams {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
    #[doc = "< Holds the box's border width in pixels."]
    pub border_width: ::std::os::raw::c_uint,
    pub border_color: NvOSD_ColorParams,
    #[doc = "< Holds a Boolean; true if the box has a\nbackground color."]
    pub has_bg_color: ::std::os::raw::c_uint,
    #[doc = "< Holds a field reserved for future use."]
    pub reserved: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's background color."]
    pub bg_color: NvOSD_ColorParams,
    pub has_color_info: ::std::os::raw::c_int,
    pub color_id: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_RectParams"][::std::mem::size_of::<_NvOSD_RectParams>() - 104usize];
    ["Alignment of _NvOSD_RectParams"][::std::mem::align_of::<_NvOSD_RectParams>() - 8usize];
    ["Offset of field: _NvOSD_RectParams::left"]
        [::std::mem::offset_of!(_NvOSD_RectParams, left) - 0usize];
    ["Offset of field: _NvOSD_RectParams::top"]
        [::std::mem::offset_of!(_NvOSD_RectParams, top) - 4usize];
    ["Offset of field: _NvOSD_RectParams::width"]
        [::std::mem::offset_of!(_NvOSD_RectParams, width) - 8usize];
    ["Offset of field: _NvOSD_RectParams::height"]
        [::std::mem::offset_of!(_NvOSD_RectParams, height) - 12usize];
    ["Offset of field: _NvOSD_RectParams::border_width"]
        [::std::mem::offset_of!(_NvOSD_RectParams, border_width) - 16usize];
    ["Offset of field: _NvOSD_RectParams::border_color"]
        [::std::mem::offset_of!(_NvOSD_RectParams, border_color) - 24usize];
    ["Offset of field: _NvOSD_RectParams::has_bg_color"]
        [::std::mem::offset_of!(_NvOSD_RectParams, has_bg_color) - 56usize];
    ["Offset of field: _NvOSD_RectParams::reserved"]
        [::std::mem::offset_of!(_NvOSD_RectParams, reserved) - 60usize];
    ["Offset of field: _NvOSD_RectParams::bg_color"]
        [::std::mem::offset_of!(_NvOSD_RectParams, bg_color) - 64usize];
    ["Offset of field: _NvOSD_RectParams::has_color_info"]
        [::std::mem::offset_of!(_NvOSD_RectParams, has_color_info) - 96usize];
    ["Offset of field: _NvOSD_RectParams::color_id"]
        [::std::mem::offset_of!(_NvOSD_RectParams, color_id) - 100usize];
};
#[doc = " Holds the box parameters of the box to be overlayed."]
pub type NvOSD_RectParams = _NvOSD_RectParams;
#[doc = " Holds the mask parameters of the segment to be overlayed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_MaskParams {
    pub data: *mut f32,
    #[doc = " Mask buffer"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " Size of mask buffer in bytes"]
    pub threshold: f32,
    #[doc = " Threshold for binarization"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Mask width"]
    pub height: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_MaskParams"][::std::mem::size_of::<_NvOSD_MaskParams>() - 24usize];
    ["Alignment of _NvOSD_MaskParams"][::std::mem::align_of::<_NvOSD_MaskParams>() - 8usize];
    ["Offset of field: _NvOSD_MaskParams::data"]
        [::std::mem::offset_of!(_NvOSD_MaskParams, data) - 0usize];
    ["Offset of field: _NvOSD_MaskParams::size"]
        [::std::mem::offset_of!(_NvOSD_MaskParams, size) - 8usize];
    ["Offset of field: _NvOSD_MaskParams::threshold"]
        [::std::mem::offset_of!(_NvOSD_MaskParams, threshold) - 12usize];
    ["Offset of field: _NvOSD_MaskParams::width"]
        [::std::mem::offset_of!(_NvOSD_MaskParams, width) - 16usize];
    ["Offset of field: _NvOSD_MaskParams::height"]
        [::std::mem::offset_of!(_NvOSD_MaskParams, height) - 20usize];
};
#[doc = " Holds the mask parameters of the segment to be overlayed"]
pub type NvOSD_MaskParams = _NvOSD_MaskParams;
#[doc = " Holds the box parameters of a line to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_LineParams {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's width in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's height in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border width in pixels."]
    pub line_width: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border color."]
    pub line_color: NvOSD_ColorParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_LineParams"][::std::mem::size_of::<_NvOSD_LineParams>() - 56usize];
    ["Alignment of _NvOSD_LineParams"][::std::mem::align_of::<_NvOSD_LineParams>() - 8usize];
    ["Offset of field: _NvOSD_LineParams::x1"]
        [::std::mem::offset_of!(_NvOSD_LineParams, x1) - 0usize];
    ["Offset of field: _NvOSD_LineParams::y1"]
        [::std::mem::offset_of!(_NvOSD_LineParams, y1) - 4usize];
    ["Offset of field: _NvOSD_LineParams::x2"]
        [::std::mem::offset_of!(_NvOSD_LineParams, x2) - 8usize];
    ["Offset of field: _NvOSD_LineParams::y2"]
        [::std::mem::offset_of!(_NvOSD_LineParams, y2) - 12usize];
    ["Offset of field: _NvOSD_LineParams::line_width"]
        [::std::mem::offset_of!(_NvOSD_LineParams, line_width) - 16usize];
    ["Offset of field: _NvOSD_LineParams::line_color"]
        [::std::mem::offset_of!(_NvOSD_LineParams, line_color) - 24usize];
};
#[doc = " Holds the box parameters of a line to be overlayed."]
pub type NvOSD_LineParams = _NvOSD_LineParams;
#[doc = " Holds arrow parameters to be overlaid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ArrowParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the end horizontal coordinate in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the end vertical coordinate in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the arrow shaft width in pixels."]
    pub arrow_width: ::std::os::raw::c_uint,
    pub arrow_head: NvOSD_Arrow_Head_Direction,
    pub arrow_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently\nfor internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_ArrowParams"][::std::mem::size_of::<_NvOSD_ArrowParams>() - 64usize];
    ["Alignment of _NvOSD_ArrowParams"][::std::mem::align_of::<_NvOSD_ArrowParams>() - 8usize];
    ["Offset of field: _NvOSD_ArrowParams::x1"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, x1) - 0usize];
    ["Offset of field: _NvOSD_ArrowParams::y1"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, y1) - 4usize];
    ["Offset of field: _NvOSD_ArrowParams::x2"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, x2) - 8usize];
    ["Offset of field: _NvOSD_ArrowParams::y2"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, y2) - 12usize];
    ["Offset of field: _NvOSD_ArrowParams::arrow_width"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, arrow_width) - 16usize];
    ["Offset of field: _NvOSD_ArrowParams::arrow_head"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, arrow_head) - 20usize];
    ["Offset of field: _NvOSD_ArrowParams::arrow_color"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, arrow_color) - 24usize];
    ["Offset of field: _NvOSD_ArrowParams::reserved"]
        [::std::mem::offset_of!(_NvOSD_ArrowParams, reserved) - 56usize];
};
#[doc = " Holds arrow parameters to be overlaid."]
pub type NvOSD_ArrowParams = _NvOSD_ArrowParams;
#[doc = " Holds circle parameters to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_CircleParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub xc: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub yc: ::std::os::raw::c_uint,
    #[doc = "< Holds the radius of circle in pixels."]
    pub radius: ::std::os::raw::c_uint,
    pub circle_color: NvOSD_ColorParams,
    pub has_bg_color: ::std::os::raw::c_uint,
    pub bg_color: NvOSD_ColorParams,
    #[doc = "< Holds the circle's border width in pixels."]
    pub circle_width: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use; currently\nfor internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvOSD_CircleParams"][::std::mem::size_of::<_NvOSD_CircleParams>() - 96usize];
    ["Alignment of _NvOSD_CircleParams"][::std::mem::align_of::<_NvOSD_CircleParams>() - 8usize];
    ["Offset of field: _NvOSD_CircleParams::xc"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, xc) - 0usize];
    ["Offset of field: _NvOSD_CircleParams::yc"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, yc) - 4usize];
    ["Offset of field: _NvOSD_CircleParams::radius"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, radius) - 8usize];
    ["Offset of field: _NvOSD_CircleParams::circle_color"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, circle_color) - 16usize];
    ["Offset of field: _NvOSD_CircleParams::has_bg_color"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, has_bg_color) - 48usize];
    ["Offset of field: _NvOSD_CircleParams::bg_color"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, bg_color) - 56usize];
    ["Offset of field: _NvOSD_CircleParams::circle_width"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, circle_width) - 88usize];
    ["Offset of field: _NvOSD_CircleParams::reserved"]
        [::std::mem::offset_of!(_NvOSD_CircleParams, reserved) - 92usize];
};
#[doc = " Holds circle parameters to be overlayed."]
pub type NvOSD_CircleParams = _NvOSD_CircleParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceParams {
    _unused: [u8; 0],
}
#[doc = " DS NvDsFrameMeta"]
pub type NvDsFrameMeta = _NvDsFrameMeta;
#[doc = " DS NvDsObjectMeta"]
pub type NvDsObjectMeta = _NvDsObjectMeta;
#[doc = " classifier meta list"]
pub type NvDsClassifierMetaList = GList;
#[doc = " user meta list"]
pub type NvDsUserMetaList = GList;
#[doc = " FP32 data type"]
pub const NvDsDataType_NvDsDataType_FP32: NvDsDataType = 0;
#[doc = " UINT8 data type"]
pub const NvDsDataType_NvDsDataType_UINT8: NvDsDataType = 1;
#[doc = " INT8 data type"]
pub const NvDsDataType_NvDsDataType_INT8: NvDsDataType = 2;
#[doc = " UINT32 data type"]
pub const NvDsDataType_NvDsDataType_UINT32: NvDsDataType = 3;
#[doc = " INT32 data type"]
pub const NvDsDataType_NvDsDataType_INT32: NvDsDataType = 4;
#[doc = " FP16 data type"]
pub const NvDsDataType_NvDsDataType_FP16: NvDsDataType = 5;
#[doc = " Data type used for model in infer"]
pub type NvDsDataType = ::std::os::raw::c_uint;
#[doc = " Full frames"]
pub const NvDsUnitType_NvDsUnitType_FullFrame: NvDsUnitType = 0;
#[doc = " Region of Interests (ROIs)"]
pub const NvDsUnitType_NvDsUnitType_ROI: NvDsUnitType = 1;
#[doc = " object mode"]
pub const NvDsUnitType_NvDsUnitType_Object: NvDsUnitType = 2;
#[doc = " Unit Type Fullframe/ROI/Crop Objects"]
pub type NvDsUnitType = ::std::os::raw::c_uint;
#[doc = " Holds Information about ROI Metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsRoiMeta {
    pub roi: NvOSD_RectParams,
    #[doc = " currently not being used"]
    pub roi_polygon: [[guint; 2usize]; 8usize],
    pub converted_buffer: *mut NvBufSurfaceParams,
    pub frame_meta: *mut NvDsFrameMeta,
    #[doc = " Ratio by which the frame/ROI crop was scaled in horizontal direction\n Required when scaling co-ordinates/sizes in metadata\n back to input resolution."]
    pub scale_ratio_x: gdouble,
    #[doc = " Ratio by which the frame/ROI crop was scaled in vertical direction\n Required when scaling co-ordinates/sizes in metadata\n back to input resolution."]
    pub scale_ratio_y: gdouble,
    #[doc = " offsets in horizontal direction while scaling"]
    pub offset_left: gdouble,
    #[doc = " offsets in vertical direction while scaling"]
    pub offset_top: gdouble,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub roi_user_meta_list: *mut NvDsUserMetaList,
    pub object_meta: *mut NvDsObjectMeta,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsRoiMeta"][::std::mem::size_of::<NvDsRoiMeta>() - 240usize];
    ["Alignment of NvDsRoiMeta"][::std::mem::align_of::<NvDsRoiMeta>() - 8usize];
    ["Offset of field: NvDsRoiMeta::roi"][::std::mem::offset_of!(NvDsRoiMeta, roi) - 0usize];
    ["Offset of field: NvDsRoiMeta::roi_polygon"]
        [::std::mem::offset_of!(NvDsRoiMeta, roi_polygon) - 104usize];
    ["Offset of field: NvDsRoiMeta::converted_buffer"]
        [::std::mem::offset_of!(NvDsRoiMeta, converted_buffer) - 168usize];
    ["Offset of field: NvDsRoiMeta::frame_meta"]
        [::std::mem::offset_of!(NvDsRoiMeta, frame_meta) - 176usize];
    ["Offset of field: NvDsRoiMeta::scale_ratio_x"]
        [::std::mem::offset_of!(NvDsRoiMeta, scale_ratio_x) - 184usize];
    ["Offset of field: NvDsRoiMeta::scale_ratio_y"]
        [::std::mem::offset_of!(NvDsRoiMeta, scale_ratio_y) - 192usize];
    ["Offset of field: NvDsRoiMeta::offset_left"]
        [::std::mem::offset_of!(NvDsRoiMeta, offset_left) - 200usize];
    ["Offset of field: NvDsRoiMeta::offset_top"]
        [::std::mem::offset_of!(NvDsRoiMeta, offset_top) - 208usize];
    ["Offset of field: NvDsRoiMeta::classifier_meta_list"]
        [::std::mem::offset_of!(NvDsRoiMeta, classifier_meta_list) - 216usize];
    ["Offset of field: NvDsRoiMeta::roi_user_meta_list"]
        [::std::mem::offset_of!(NvDsRoiMeta, roi_user_meta_list) - 224usize];
    ["Offset of field: NvDsRoiMeta::object_meta"]
        [::std::mem::offset_of!(NvDsRoiMeta, object_meta) - 232usize];
};
pub type NvDsFrameMetaList = GList;
pub type NvDsObjectMetaList = GList;
pub type NvDisplayMetaList = GList;
pub type NvDsLabelInfoList = GList;
pub type NvDsMetaList = GList;
pub type NvDsElementMeta = ::std::os::raw::c_void;
#[doc = " \\brief  Defines the type of a callback to copy metadata.\n\n The callback is passed pointers to source metadata. It allocates the\n required memory, copies the content from the source metadata and returns\n a pointer to the destination.\n\n @param[in]  data         A pointer to the source metadata.\n @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
#[doc = " \\brief  Defines the type of a callback to free metadata.\n\n The callback is passed a pointer to metadata created by NvDsMetaCopyFunc().\n It frees the metadata and\n any other resources that the metadata uses.\n\n @param[in]  data         A pointer to the metadata to be freed.\n @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaReleaseFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub const NvDsMetaType_NVDS_INVALID_META: NvDsMetaType = -1;
#[doc = " Specifies metadata type for formed batch."]
pub const NvDsMetaType_NVDS_BATCH_META: NvDsMetaType = 1;
#[doc = " Specifies metadata type for frame."]
pub const NvDsMetaType_NVDS_FRAME_META: NvDsMetaType = 2;
#[doc = " Specifies metadata type for a detected object."]
pub const NvDsMetaType_NVDS_OBJ_META: NvDsMetaType = 3;
#[doc = " Specifies metadata type for display."]
pub const NvDsMetaType_NVDS_DISPLAY_META: NvDsMetaType = 4;
#[doc = " Specifies metadata type for an object classifier."]
pub const NvDsMetaType_NVDS_CLASSIFIER_META: NvDsMetaType = 5;
#[doc = " Specifies metadata type for a label assigned by a classifier."]
pub const NvDsMetaType_NVDS_LABEL_INFO_META: NvDsMetaType = 6;
#[doc = " Reserved for internal use."]
pub const NvDsMetaType_NVDS_USER_META: NvDsMetaType = 7;
#[doc = " Specifies metadata type for a payload generated by a message converter."]
pub const NvDsMetaType_NVDS_PAYLOAD_META: NvDsMetaType = 8;
#[doc = " Specifies metadata type for a payload generated by a message broker."]
pub const NvDsMetaType_NVDS_EVENT_MSG_META: NvDsMetaType = 9;
#[doc = " Specifies metadata type for an optical flow."]
pub const NvDsMetaType_NVDS_OPTICAL_FLOW_META: NvDsMetaType = 10;
#[doc = " Specifies metadata type for a latency measurement."]
pub const NvDsMetaType_NVDS_LATENCY_MEASUREMENT_META: NvDsMetaType = 11;
#[doc = " Specifies metadata type for raw inference output attached by Gst-nvinfer.\n@see NvDsInferTensorMeta for details."]
pub const NvDsMetaType_NVDSINFER_TENSOR_OUTPUT_META: NvDsMetaType = 12;
#[doc = " Specifies metadata type for segmentation model output attached by\nGst-nvinfer. @see NvDsInferSegmentationMeta for details."]
pub const NvDsMetaType_NVDSINFER_SEGMENTATION_META: NvDsMetaType = 13;
#[doc = " Specifies metadata type for JPEG-encoded object crops.\n See the deepstream-image-meta-test app for details."]
pub const NvDsMetaType_NVDS_CROP_IMAGE_META: NvDsMetaType = 14;
#[doc = " Metadata type to be set for tracking previous frames"]
pub const NvDsMetaType_NVDS_TRACKER_PAST_FRAME_META: NvDsMetaType = 15;
#[doc = " The ReID vectors for the whole batch generated by tracker."]
pub const NvDsMetaType_NVDS_TRACKER_BATCH_REID_META: NvDsMetaType = 16;
#[doc = " The ReID information for a single object generated by tracker."]
pub const NvDsMetaType_NVDS_TRACKER_OBJ_REID_META: NvDsMetaType = 17;
#[doc = " Information on all terminated Tracks"]
pub const NvDsMetaType_NVDS_TRACKER_TERMINATED_LIST_META: NvDsMetaType = 18;
#[doc = " Information on all terminated Tracks"]
pub const NvDsMetaType_NVDS_TRACKER_SHADOW_LIST_META: NvDsMetaType = 19;
#[doc = " Specifies the visibility of an object."]
pub const NvDsMetaType_NVDS_OBJ_VISIBILITY: NvDsMetaType = 20;
#[doc = " Specifies the foot location of an object on a frame."]
pub const NvDsMetaType_NVDS_OBJ_IMAGE_FOOT_LOCATION: NvDsMetaType = 21;
#[doc = " Specifies the foot location of an object on the estimated world ground."]
pub const NvDsMetaType_NVDS_OBJ_WORLD_FOOT_LOCATION: NvDsMetaType = 22;
#[doc = " Specifies the convex hull of an object on a frame."]
pub const NvDsMetaType_NVDS_OBJ_IMAGE_CONVEX_HULL: NvDsMetaType = 23;
#[doc = " Specifies metadata type for formed audio batch."]
pub const NvDsMetaType_NVDS_AUDIO_BATCH_META: NvDsMetaType = 24;
#[doc = " Specifies metadata type for audio frame."]
pub const NvDsMetaType_NVDS_AUDIO_FRAME_META: NvDsMetaType = 25;
#[doc = " Specifies metadata type for preprocess scale&converted ROIs attached by Gst-nvdspreprocess.\n@see NvDsPreProcessFrameMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_FRAME_META: NvDsMetaType = 26;
#[doc = " Specifies metadata type for preprocess batch level attached by Gst-nvdspreprocess.\n@see NvDsPreProcessBatchMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_BATCH_META: NvDsMetaType = 27;
#[doc = " Specifies user defined custom message blob to be part of payload generated"]
pub const NvDsMetaType_NVDS_CUSTOM_MSG_BLOB: NvDsMetaType = 28;
#[doc = " Reserved field"]
pub const NvDsMetaType_NVDS_RESERVED_META: NvDsMetaType = 4095;
#[doc = " Specifies the start of a range of enum values that represent types of\n NVIDIA-defined Gst metas. The range is from NVDS_GST_CUSTOM_META to\n NVDS_GST_CUSTOM_META+4096, inclusive."]
pub const NvDsMetaType_NVDS_GST_CUSTOM_META: NvDsMetaType = 4096;
#[doc = " Start adding user specific meta types from here */\n/**\n Specifies the start of a range of enum values that represent custom\n (application-specific) Gst meta types. A custom meta type may be assigned\n any enum value equal to or larger than this.\n\n Such Gst metas may be attached by GStreamer plugins upstream from\n Gst-nvstreammux. They may have any contents that is a superset of\n the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_START_USER_META: NvDsMetaType = 8193;
#[doc = " Start adding user specific meta types from here */\n/**\n Specifies the start of a range of enum values that represent custom\n (application-specific) Gst meta types. A custom meta type may be assigned\n any enum value equal to or larger than this.\n\n Such Gst metas may be attached by GStreamer plugins upstream from\n Gst-nvstreammux. They may have any contents that is a superset of\n the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_FORCE32_META: NvDsMetaType = 2147483647;
#[doc = " Specifies the type of metadata. All metadata types are subtypes of\n @ref NvDsMetaType. Members that represent NVIDIA-defined types are\n in the range from @ref NVDS_BATCH_META to @ref NVDS_START_USER_META.\n User-defined types may be assigned values greater than or equal to\n @ref NVDS_START_USER_META."]
pub type NvDsMetaType = ::std::os::raw::c_int;
#[doc = " Holds unclipped positional bounding box coordinates of the object processed\n by the component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsComp_BboxInfo {
    pub org_bbox_coords: NvBbox_Coords,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsComp_BboxInfo"][::std::mem::size_of::<_NvDsComp_BboxInfo>() - 16usize];
    ["Alignment of _NvDsComp_BboxInfo"][::std::mem::align_of::<_NvDsComp_BboxInfo>() - 4usize];
    ["Offset of field: _NvDsComp_BboxInfo::org_bbox_coords"]
        [::std::mem::offset_of!(_NvDsComp_BboxInfo, org_bbox_coords) - 0usize];
};
#[doc = " Holds unclipped positional bounding box coordinates of the object processed\n by the component."]
pub type NvDsComp_BboxInfo = _NvDsComp_BboxInfo;
#[doc = " Holds information about a given metadata pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaPool {
    pub meta_type: NvDsMetaType,
    pub max_elements_in_pool: guint,
    pub element_size: guint,
    pub num_empty_elements: guint,
    pub num_full_elements: guint,
    pub empty_list: *mut NvDsMetaList,
    pub full_list: *mut NvDsMetaList,
    pub copy_func: NvDsMetaCopyFunc,
    pub release_func: NvDsMetaReleaseFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsMetaPool"][::std::mem::size_of::<_NvDsMetaPool>() - 56usize];
    ["Alignment of _NvDsMetaPool"][::std::mem::align_of::<_NvDsMetaPool>() - 8usize];
    ["Offset of field: _NvDsMetaPool::meta_type"]
        [::std::mem::offset_of!(_NvDsMetaPool, meta_type) - 0usize];
    ["Offset of field: _NvDsMetaPool::max_elements_in_pool"]
        [::std::mem::offset_of!(_NvDsMetaPool, max_elements_in_pool) - 4usize];
    ["Offset of field: _NvDsMetaPool::element_size"]
        [::std::mem::offset_of!(_NvDsMetaPool, element_size) - 8usize];
    ["Offset of field: _NvDsMetaPool::num_empty_elements"]
        [::std::mem::offset_of!(_NvDsMetaPool, num_empty_elements) - 12usize];
    ["Offset of field: _NvDsMetaPool::num_full_elements"]
        [::std::mem::offset_of!(_NvDsMetaPool, num_full_elements) - 16usize];
    ["Offset of field: _NvDsMetaPool::empty_list"]
        [::std::mem::offset_of!(_NvDsMetaPool, empty_list) - 24usize];
    ["Offset of field: _NvDsMetaPool::full_list"]
        [::std::mem::offset_of!(_NvDsMetaPool, full_list) - 32usize];
    ["Offset of field: _NvDsMetaPool::copy_func"]
        [::std::mem::offset_of!(_NvDsMetaPool, copy_func) - 40usize];
    ["Offset of field: _NvDsMetaPool::release_func"]
        [::std::mem::offset_of!(_NvDsMetaPool, release_func) - 48usize];
};
#[doc = " Holds information about a given metadata pool."]
pub type NvDsMetaPool = _NvDsMetaPool;
#[doc = " Holds information about base metadata of a given metadata type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBaseMeta {
    #[doc = " Holds a pointer to batch_meta @ref NvDsBatchMeta."]
    pub batch_meta: *mut _NvDsBatchMeta,
    #[doc = " Holds the metadata type of this metadata element."]
    pub meta_type: NvDsMetaType,
    #[doc = " Holds a pointer to a user context."]
    pub uContext: *mut ::std::os::raw::c_void,
    #[doc = " Holds a user-defined copy function. The function is called to copy\nor transform metadata from one buffer to another. @a meta_data and\n@a user_data are passed as arguments."]
    pub copy_func: NvDsMetaCopyFunc,
    #[doc = " Holds a user-defined release function. The function is called\nwhen @a meta_data is to be released."]
    pub release_func: NvDsMetaReleaseFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsBaseMeta"][::std::mem::size_of::<_NvDsBaseMeta>() - 40usize];
    ["Alignment of _NvDsBaseMeta"][::std::mem::align_of::<_NvDsBaseMeta>() - 8usize];
    ["Offset of field: _NvDsBaseMeta::batch_meta"]
        [::std::mem::offset_of!(_NvDsBaseMeta, batch_meta) - 0usize];
    ["Offset of field: _NvDsBaseMeta::meta_type"]
        [::std::mem::offset_of!(_NvDsBaseMeta, meta_type) - 8usize];
    ["Offset of field: _NvDsBaseMeta::uContext"]
        [::std::mem::offset_of!(_NvDsBaseMeta, uContext) - 16usize];
    ["Offset of field: _NvDsBaseMeta::copy_func"]
        [::std::mem::offset_of!(_NvDsBaseMeta, copy_func) - 24usize];
    ["Offset of field: _NvDsBaseMeta::release_func"]
        [::std::mem::offset_of!(_NvDsBaseMeta, release_func) - 32usize];
};
#[doc = " Holds information about base metadata of a given metadata type."]
pub type NvDsBaseMeta = _NvDsBaseMeta;
#[doc = " Holds information about a formed batch containing frames from different\n sources.\n NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type.\n NOTE: Audio batch metadata is formed within nvinferaudio plugin\n and will not be corresponding to any one buffer output from nvinferaudio.\n The NvDsBatchMeta for audio is attached to the last input buffer\n when the audio batch buffering reach configurable threshold\n (audio frame length) and this is when inference output is available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBatchMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the maximum number of frames in the batch."]
    pub max_frames_in_batch: guint,
    #[doc = " Holds the number of frames now in the batch."]
    pub num_frames_in_batch: guint,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsFrameMeta,\nrepresenting a pool of frame metas."]
    pub frame_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type NvDsObjMeta,\nrepresenting a pool of object metas."]
    pub obj_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsClassifierMeta,\nrepresenting a pool of classifier metas."]
    pub classifier_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsDisplayMeta,\nrepresenting a pool of display metas."]
    pub display_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsUserMeta,\nrepresenting a pool of user metas."]
    pub user_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsLabelInfo,\nrepresenting a pool of label metas."]
    pub label_info_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a list of pointers of type NvDsFrameMeta\nor NvDsAudioFrameMeta (when the batch represent audio batch),\nrepresenting frame metas used in the current batch."]
    pub frame_meta_list: *mut NvDsFrameMetaList,
    #[doc = " Holds a pointer to a list of pointers of type NvDsUserMeta,\nrepresenting user metas in the current batch."]
    pub batch_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds a lock to be set before accessing metadata to avoid\nsimultaneous update by multiple components."]
    pub meta_mutex: GRecMutex,
    #[doc = " Holds an array of user-specific batch information."]
    pub misc_batch_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsBatchMeta"][::std::mem::size_of::<_NvDsBatchMeta>() - 192usize];
    ["Alignment of _NvDsBatchMeta"][::std::mem::align_of::<_NvDsBatchMeta>() - 8usize];
    ["Offset of field: _NvDsBatchMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsBatchMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsBatchMeta::max_frames_in_batch"]
        [::std::mem::offset_of!(_NvDsBatchMeta, max_frames_in_batch) - 40usize];
    ["Offset of field: _NvDsBatchMeta::num_frames_in_batch"]
        [::std::mem::offset_of!(_NvDsBatchMeta, num_frames_in_batch) - 44usize];
    ["Offset of field: _NvDsBatchMeta::frame_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, frame_meta_pool) - 48usize];
    ["Offset of field: _NvDsBatchMeta::obj_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, obj_meta_pool) - 56usize];
    ["Offset of field: _NvDsBatchMeta::classifier_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, classifier_meta_pool) - 64usize];
    ["Offset of field: _NvDsBatchMeta::display_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, display_meta_pool) - 72usize];
    ["Offset of field: _NvDsBatchMeta::user_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, user_meta_pool) - 80usize];
    ["Offset of field: _NvDsBatchMeta::label_info_meta_pool"]
        [::std::mem::offset_of!(_NvDsBatchMeta, label_info_meta_pool) - 88usize];
    ["Offset of field: _NvDsBatchMeta::frame_meta_list"]
        [::std::mem::offset_of!(_NvDsBatchMeta, frame_meta_list) - 96usize];
    ["Offset of field: _NvDsBatchMeta::batch_user_meta_list"]
        [::std::mem::offset_of!(_NvDsBatchMeta, batch_user_meta_list) - 104usize];
    ["Offset of field: _NvDsBatchMeta::meta_mutex"]
        [::std::mem::offset_of!(_NvDsBatchMeta, meta_mutex) - 112usize];
    ["Offset of field: _NvDsBatchMeta::misc_batch_info"]
        [::std::mem::offset_of!(_NvDsBatchMeta, misc_batch_info) - 128usize];
    ["Offset of field: _NvDsBatchMeta::reserved"]
        [::std::mem::offset_of!(_NvDsBatchMeta, reserved) - 160usize];
};
#[doc = " Holds information about a formed batch containing frames from different\n sources.\n NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type.\n NOTE: Audio batch metadata is formed within nvinferaudio plugin\n and will not be corresponding to any one buffer output from nvinferaudio.\n The NvDsBatchMeta for audio is attached to the last input buffer\n when the audio batch buffering reach configurable threshold\n (audio frame length) and this is when inference output is available."]
pub type NvDsBatchMeta = _NvDsBatchMeta;
#[doc = " Holds metadata for a frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch. The frame's\n@ref NvBufSurfaceParams are at index @a batch_id in the @a surfaceList\narray of @ref NvBufSurface."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID.\nIt need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of surfaces in the frame, required in case of\nmultiple surfaces in the frame."]
    pub num_surfaces_per_frame: gint,
    pub source_frame_width: guint,
    pub source_frame_height: guint,
    pub surface_type: guint,
    pub surface_index: guint,
    #[doc = " Holds the number of object meta elements attached to current frame."]
    pub num_obj_meta: guint,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsObjectMeta\nin use for the frame."]
    pub obj_meta_list: *mut NvDsObjectMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsDisplayMeta\nin use for the frame."]
    pub display_meta_list: *mut NvDisplayMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta\nin use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    pub pipeline_width: guint,
    pub pipeline_height: guint,
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsFrameMeta"][::std::mem::size_of::<_NvDsFrameMeta>() - 200usize];
    ["Alignment of _NvDsFrameMeta"][::std::mem::align_of::<_NvDsFrameMeta>() - 8usize];
    ["Offset of field: _NvDsFrameMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsFrameMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsFrameMeta::pad_index"]
        [::std::mem::offset_of!(_NvDsFrameMeta, pad_index) - 40usize];
    ["Offset of field: _NvDsFrameMeta::batch_id"]
        [::std::mem::offset_of!(_NvDsFrameMeta, batch_id) - 44usize];
    ["Offset of field: _NvDsFrameMeta::frame_num"]
        [::std::mem::offset_of!(_NvDsFrameMeta, frame_num) - 48usize];
    ["Offset of field: _NvDsFrameMeta::buf_pts"]
        [::std::mem::offset_of!(_NvDsFrameMeta, buf_pts) - 56usize];
    ["Offset of field: _NvDsFrameMeta::ntp_timestamp"]
        [::std::mem::offset_of!(_NvDsFrameMeta, ntp_timestamp) - 64usize];
    ["Offset of field: _NvDsFrameMeta::source_id"]
        [::std::mem::offset_of!(_NvDsFrameMeta, source_id) - 72usize];
    ["Offset of field: _NvDsFrameMeta::num_surfaces_per_frame"]
        [::std::mem::offset_of!(_NvDsFrameMeta, num_surfaces_per_frame) - 76usize];
    ["Offset of field: _NvDsFrameMeta::source_frame_width"]
        [::std::mem::offset_of!(_NvDsFrameMeta, source_frame_width) - 80usize];
    ["Offset of field: _NvDsFrameMeta::source_frame_height"]
        [::std::mem::offset_of!(_NvDsFrameMeta, source_frame_height) - 84usize];
    ["Offset of field: _NvDsFrameMeta::surface_type"]
        [::std::mem::offset_of!(_NvDsFrameMeta, surface_type) - 88usize];
    ["Offset of field: _NvDsFrameMeta::surface_index"]
        [::std::mem::offset_of!(_NvDsFrameMeta, surface_index) - 92usize];
    ["Offset of field: _NvDsFrameMeta::num_obj_meta"]
        [::std::mem::offset_of!(_NvDsFrameMeta, num_obj_meta) - 96usize];
    ["Offset of field: _NvDsFrameMeta::bInferDone"]
        [::std::mem::offset_of!(_NvDsFrameMeta, bInferDone) - 100usize];
    ["Offset of field: _NvDsFrameMeta::obj_meta_list"]
        [::std::mem::offset_of!(_NvDsFrameMeta, obj_meta_list) - 104usize];
    ["Offset of field: _NvDsFrameMeta::display_meta_list"]
        [::std::mem::offset_of!(_NvDsFrameMeta, display_meta_list) - 112usize];
    ["Offset of field: _NvDsFrameMeta::frame_user_meta_list"]
        [::std::mem::offset_of!(_NvDsFrameMeta, frame_user_meta_list) - 120usize];
    ["Offset of field: _NvDsFrameMeta::misc_frame_info"]
        [::std::mem::offset_of!(_NvDsFrameMeta, misc_frame_info) - 128usize];
    ["Offset of field: _NvDsFrameMeta::pipeline_width"]
        [::std::mem::offset_of!(_NvDsFrameMeta, pipeline_width) - 160usize];
    ["Offset of field: _NvDsFrameMeta::pipeline_height"]
        [::std::mem::offset_of!(_NvDsFrameMeta, pipeline_height) - 164usize];
    ["Offset of field: _NvDsFrameMeta::reserved"]
        [::std::mem::offset_of!(_NvDsFrameMeta, reserved) - 168usize];
};
#[doc = " Holds metadata for an object in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsObjectMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to the parent @ref NvDsObjectMeta. Set to NULL if\nno parent exists."]
    pub parent: *mut _NvDsObjectMeta,
    #[doc = " Holds a unique component ID that identifies the metadata\nin this structure."]
    pub unique_component_id: gint,
    #[doc = " Holds the index of the object class inferred by the primary\ndetector/classifier."]
    pub class_id: gint,
    #[doc = " Holds a unique ID for tracking the object. @ref UNTRACKED_OBJECT_ID\nindicates that the object has not been tracked."]
    pub object_id: guint64,
    #[doc = " Holds a structure containing bounding box parameters of the object when\ndetected by detector."]
    pub detector_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a structure containing bounding box coordinates of the object when\n processed by tracker."]
    pub tracker_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a confidence value for the object, set by the inference\ncomponent. confidence will be set to -0.1, if \"Group Rectangles\" mode of\nclustering is chosen since the algorithm does not preserve confidence\nvalues. Also, for objects found by tracker and not inference component,\nconfidence will be set to -0.1"]
    pub confidence: gfloat,
    #[doc = " Holds a confidence value for the object set by nvdcf_tracker.\n tracker_confidence will be set to -0.1 for KLT and IOU tracker"]
    pub tracker_confidence: gfloat,
    #[doc = " Holds a structure containing positional parameters of the object\n processed by the last component that updates it in the pipeline.\n e.g. If the tracker component is after the detector component in the\n pipeline then positinal parameters are from tracker component.\n Positional parameters are clipped so that they do not fall outside frame\n boundary. Can also be used to overlay borders or semi-transparent boxes on\n objects. @see NvOSD_RectParams."]
    pub rect_params: NvOSD_RectParams,
    #[doc = " Holds mask parameters for the object. This mask is overlayed on object\n @see NvOSD_MaskParams."]
    pub mask_params: NvOSD_MaskParams,
    #[doc = " Holds text describing the object. This text can be overlayed on the\nstandard text that identifies the object. @see NvOSD_TextParams."]
    pub text_params: NvOSD_TextParams,
    #[doc = " Holds a string describing the class of the detected object."]
    pub obj_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub obj_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined object information."]
    pub misc_obj_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsObjectMeta"][::std::mem::size_of::<_NvDsObjectMeta>() - 544usize];
    ["Alignment of _NvDsObjectMeta"][::std::mem::align_of::<_NvDsObjectMeta>() - 8usize];
    ["Offset of field: _NvDsObjectMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsObjectMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsObjectMeta::parent"]
        [::std::mem::offset_of!(_NvDsObjectMeta, parent) - 40usize];
    ["Offset of field: _NvDsObjectMeta::unique_component_id"]
        [::std::mem::offset_of!(_NvDsObjectMeta, unique_component_id) - 48usize];
    ["Offset of field: _NvDsObjectMeta::class_id"]
        [::std::mem::offset_of!(_NvDsObjectMeta, class_id) - 52usize];
    ["Offset of field: _NvDsObjectMeta::object_id"]
        [::std::mem::offset_of!(_NvDsObjectMeta, object_id) - 56usize];
    ["Offset of field: _NvDsObjectMeta::detector_bbox_info"]
        [::std::mem::offset_of!(_NvDsObjectMeta, detector_bbox_info) - 64usize];
    ["Offset of field: _NvDsObjectMeta::tracker_bbox_info"]
        [::std::mem::offset_of!(_NvDsObjectMeta, tracker_bbox_info) - 80usize];
    ["Offset of field: _NvDsObjectMeta::confidence"]
        [::std::mem::offset_of!(_NvDsObjectMeta, confidence) - 96usize];
    ["Offset of field: _NvDsObjectMeta::tracker_confidence"]
        [::std::mem::offset_of!(_NvDsObjectMeta, tracker_confidence) - 100usize];
    ["Offset of field: _NvDsObjectMeta::rect_params"]
        [::std::mem::offset_of!(_NvDsObjectMeta, rect_params) - 104usize];
    ["Offset of field: _NvDsObjectMeta::mask_params"]
        [::std::mem::offset_of!(_NvDsObjectMeta, mask_params) - 208usize];
    ["Offset of field: _NvDsObjectMeta::text_params"]
        [::std::mem::offset_of!(_NvDsObjectMeta, text_params) - 232usize];
    ["Offset of field: _NvDsObjectMeta::obj_label"]
        [::std::mem::offset_of!(_NvDsObjectMeta, obj_label) - 336usize];
    ["Offset of field: _NvDsObjectMeta::classifier_meta_list"]
        [::std::mem::offset_of!(_NvDsObjectMeta, classifier_meta_list) - 464usize];
    ["Offset of field: _NvDsObjectMeta::obj_user_meta_list"]
        [::std::mem::offset_of!(_NvDsObjectMeta, obj_user_meta_list) - 472usize];
    ["Offset of field: _NvDsObjectMeta::misc_obj_info"]
        [::std::mem::offset_of!(_NvDsObjectMeta, misc_obj_info) - 480usize];
    ["Offset of field: _NvDsObjectMeta::reserved"]
        [::std::mem::offset_of!(_NvDsObjectMeta, reserved) - 512usize];
};
#[doc = " Holds classifier metadata for an object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsClassifierMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of outputs/labels produced by the classifier."]
    pub num_labels: guint,
    #[doc = " Holds a unique component ID for the classifier metadata."]
    pub unique_component_id: gint,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsLabelInfo."]
    pub label_info_list: *mut NvDsLabelInfoList,
    #[doc = " Holds the type of the classifier."]
    pub classifier_type: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsClassifierMeta"][::std::mem::size_of::<_NvDsClassifierMeta>() - 64usize];
    ["Alignment of _NvDsClassifierMeta"][::std::mem::align_of::<_NvDsClassifierMeta>() - 8usize];
    ["Offset of field: _NvDsClassifierMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsClassifierMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsClassifierMeta::num_labels"]
        [::std::mem::offset_of!(_NvDsClassifierMeta, num_labels) - 40usize];
    ["Offset of field: _NvDsClassifierMeta::unique_component_id"]
        [::std::mem::offset_of!(_NvDsClassifierMeta, unique_component_id) - 44usize];
    ["Offset of field: _NvDsClassifierMeta::label_info_list"]
        [::std::mem::offset_of!(_NvDsClassifierMeta, label_info_list) - 48usize];
    ["Offset of field: _NvDsClassifierMeta::classifier_type"]
        [::std::mem::offset_of!(_NvDsClassifierMeta, classifier_type) - 56usize];
};
#[doc = " Holds classifier metadata for an object."]
pub type NvDsClassifierMeta = _NvDsClassifierMeta;
#[doc = " Holds label metadata for the classifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsLabelInfo {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of classes of the given label."]
    pub num_classes: guint,
    #[doc = " Holds an string describing the label of the classified object."]
    pub result_label: [gchar; 128usize],
    #[doc = " Holds a pointer to the result label if its length exceeds MAX_LABEL_SIZE bytes."]
    pub pResult_label: *mut gchar,
    #[doc = " Holds the class UD of the best result."]
    pub result_class_id: guint,
    #[doc = " Holds the label ID in case there are multiple label classifiers."]
    pub label_id: guint,
    #[doc = " Holds the probability of best result."]
    pub result_prob: gfloat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsLabelInfo"][::std::mem::size_of::<_NvDsLabelInfo>() - 200usize];
    ["Alignment of _NvDsLabelInfo"][::std::mem::align_of::<_NvDsLabelInfo>() - 8usize];
    ["Offset of field: _NvDsLabelInfo::base_meta"]
        [::std::mem::offset_of!(_NvDsLabelInfo, base_meta) - 0usize];
    ["Offset of field: _NvDsLabelInfo::num_classes"]
        [::std::mem::offset_of!(_NvDsLabelInfo, num_classes) - 40usize];
    ["Offset of field: _NvDsLabelInfo::result_label"]
        [::std::mem::offset_of!(_NvDsLabelInfo, result_label) - 44usize];
    ["Offset of field: _NvDsLabelInfo::pResult_label"]
        [::std::mem::offset_of!(_NvDsLabelInfo, pResult_label) - 176usize];
    ["Offset of field: _NvDsLabelInfo::result_class_id"]
        [::std::mem::offset_of!(_NvDsLabelInfo, result_class_id) - 184usize];
    ["Offset of field: _NvDsLabelInfo::label_id"]
        [::std::mem::offset_of!(_NvDsLabelInfo, label_id) - 188usize];
    ["Offset of field: _NvDsLabelInfo::result_prob"]
        [::std::mem::offset_of!(_NvDsLabelInfo, result_prob) - 192usize];
};
#[doc = " Holds label metadata for the classifier."]
pub type NvDsLabelInfo = _NvDsLabelInfo;
#[doc = " Holds display metadata that the user can specify in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsDisplayMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of rectangles described."]
    pub num_rects: guint,
    #[doc = " Holds the number of labels (strings) described."]
    pub num_labels: guint,
    #[doc = " Holds the number of lines described."]
    pub num_lines: guint,
    #[doc = " Holds the number of arrows described."]
    pub num_arrows: guint,
    #[doc = " Holds the number of circles described."]
    pub num_circles: guint,
    #[doc = " Holds an array of positional parameters for rectangles.\nUsed to overlay borders or semi-transparent rectangles,\nas required by the application. @see NvOSD_RectParams."]
    pub rect_params: [NvOSD_RectParams; 16usize],
    #[doc = " Holds an array of text parameters for user-defined strings that can be\noverlayed using this structure. @see NvOSD_TextParams."]
    pub text_params: [NvOSD_TextParams; 16usize],
    #[doc = " Holds an array of line parameters that the user can use to draw polygons\nin the frame, e.g. to show a RoI in the frame. @see NvOSD_LineParams."]
    pub line_params: [NvOSD_LineParams; 16usize],
    #[doc = " Holds an array of arrow parameters that the user can use to draw arrows\nin the frame. @see NvOSD_ArrowParams"]
    pub arrow_params: [NvOSD_ArrowParams; 16usize],
    #[doc = " Holds an array of circle parameters that the user can use to draw circles\nin the frame. @see NvOSD_CircleParams"]
    pub circle_params: [NvOSD_CircleParams; 16usize],
    #[doc = " Holds an array of user-defined OSD metadata."]
    pub misc_osd_data: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsDisplayMeta"][::std::mem::size_of::<NvDsDisplayMeta>() - 6912usize];
    ["Alignment of NvDsDisplayMeta"][::std::mem::align_of::<NvDsDisplayMeta>() - 8usize];
    ["Offset of field: NvDsDisplayMeta::base_meta"]
        [::std::mem::offset_of!(NvDsDisplayMeta, base_meta) - 0usize];
    ["Offset of field: NvDsDisplayMeta::num_rects"]
        [::std::mem::offset_of!(NvDsDisplayMeta, num_rects) - 40usize];
    ["Offset of field: NvDsDisplayMeta::num_labels"]
        [::std::mem::offset_of!(NvDsDisplayMeta, num_labels) - 44usize];
    ["Offset of field: NvDsDisplayMeta::num_lines"]
        [::std::mem::offset_of!(NvDsDisplayMeta, num_lines) - 48usize];
    ["Offset of field: NvDsDisplayMeta::num_arrows"]
        [::std::mem::offset_of!(NvDsDisplayMeta, num_arrows) - 52usize];
    ["Offset of field: NvDsDisplayMeta::num_circles"]
        [::std::mem::offset_of!(NvDsDisplayMeta, num_circles) - 56usize];
    ["Offset of field: NvDsDisplayMeta::rect_params"]
        [::std::mem::offset_of!(NvDsDisplayMeta, rect_params) - 64usize];
    ["Offset of field: NvDsDisplayMeta::text_params"]
        [::std::mem::offset_of!(NvDsDisplayMeta, text_params) - 1728usize];
    ["Offset of field: NvDsDisplayMeta::line_params"]
        [::std::mem::offset_of!(NvDsDisplayMeta, line_params) - 3392usize];
    ["Offset of field: NvDsDisplayMeta::arrow_params"]
        [::std::mem::offset_of!(NvDsDisplayMeta, arrow_params) - 4288usize];
    ["Offset of field: NvDsDisplayMeta::circle_params"]
        [::std::mem::offset_of!(NvDsDisplayMeta, circle_params) - 5312usize];
    ["Offset of field: NvDsDisplayMeta::misc_osd_data"]
        [::std::mem::offset_of!(NvDsDisplayMeta, misc_osd_data) - 6848usize];
    ["Offset of field: NvDsDisplayMeta::reserved"]
        [::std::mem::offset_of!(NvDsDisplayMeta, reserved) - 6880usize];
};
#[doc = " Holds user metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsUserMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to user data to be attached.\nSee the deepstream-user-metadata-test example for usage."]
    pub user_meta_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsUserMeta"][::std::mem::size_of::<_NvDsUserMeta>() - 48usize];
    ["Alignment of _NvDsUserMeta"][::std::mem::align_of::<_NvDsUserMeta>() - 8usize];
    ["Offset of field: _NvDsUserMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsUserMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsUserMeta::user_meta_data"]
        [::std::mem::offset_of!(_NvDsUserMeta, user_meta_data) - 40usize];
};
#[doc = " Holds user metadata."]
pub type NvDsUserMeta = _NvDsUserMeta;
unsafe extern "C" {
    #[doc = " Acquires a lock before updating metadata.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta structure\n                          to be locked."]
    pub fn nvds_acquire_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
unsafe extern "C" {
    #[doc = " Releases the lock after updating metadata.\n\n @param[in] batch_meta    A pointer to NvDsBatchMeta structure to be unlocked."]
    pub fn nvds_release_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
unsafe extern "C" {
    #[doc = " Creates a batch metadata structure for a batch of specified size.\n\n @param[in] max_batch_size    The maximum number of frames in the batch.\n @ return  A pointer to the created structure."]
    pub fn nvds_create_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
unsafe extern "C" {
    #[doc = " Destroys a batch metadata structure.\n\n @param[in] batch_meta    A pointer to batch metadata structure\n                          to be destroyed.\n @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief  Acquires a frame meta from a batch's frame meta pool.\n\n You must acquire a frame meta before you can fill it with frame metadata.\n\n @param[in] batch_meta    A pointer to batch meta from which to acquire\n                          a frame meta.\n\n @return  A pointer to the acquired frame meta."]
    pub fn nvds_acquire_frame_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsFrameMeta;
}
unsafe extern "C" {
    #[doc = " Adds a frame meta to a batch meta.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta to which\n                          @a frame_meta is to be added.\n @param[in] frame_meta    A pointer to a frame meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_frame_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a frame meta from a batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta\n                          is to be removed.\n @param[in] frame_meta    A pointer to the frame meta to be removed from\n                          @a batch_meta."]
    pub fn nvds_remove_frame_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Acquires an object meta from a batch meta's object meta pool.\n\n You must acquire an object meta before you can fill it with object metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          an object meta.\n\n @return  A pointer to the acquired object meta."]
    pub fn nvds_acquire_obj_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsObjectMeta;
}
unsafe extern "C" {
    #[doc = " @brief  Adds an object meta to a frame meta.\n\n You must acquire the object meta with nvds_acquire_object_meta_from_pool()\n and fill it with metadata before you add to to the frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a obj_meta\n                          is to be added.\n @param[in] obj_meta      A pointer to an object meta to be added to @a frame_meta.\n @param[in] obj_parent    A pointer to the this object meta's parent object meta.\n                          This pointer is stored in @a obj_meta->parent."]
    pub fn nvds_add_obj_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
        obj_parent: *mut NvDsObjectMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes an object meta from the frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to frame meta from which @a obj_meta\n                          is to be removed.\n @param[in] obj_meta      A pointer to the object meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_obj_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Acquires a classifier meta from a batch meta's classifier meta pool.\n\n You must acquire a classifier meta from the classifier meta pool before you\n can fill it with classifier metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a classifier meta.\n\n @return  The classifier meta acquired from the batch meta's\n  classifier meta pool."]
    pub fn nvds_acquire_classifier_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsClassifierMeta;
}
unsafe extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate roi meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the roi metadata.\n\n @param[in] roi_meta          A pointer to the roi meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a roi_meta."]
    pub fn nvds_add_classifier_meta_to_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a classifier meta from the roi meta to which it is attached.\n\n @param[in] roi_meta          A pointer to the roi meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a roi_meta."]
    pub fn nvds_remove_classifier_meta_from_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate object meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the object metadata.\n\n @param[in] obj_meta          A pointer to the object meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_object(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a classifier meta from the object meta to which it is attached.\n\n @param[in] obj_meta          A pointer to the object meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a obj_meta."]
    pub fn nvds_remove_classifier_meta_from_obj(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Acquires a display meta from a batch meta's display meta pool.\n\n You must acquire a display meta before you can fill it with display metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a display meta.\n\n @return  The display meta acquired from the batch meta's display meta pool."]
    pub fn nvds_acquire_display_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsDisplayMeta;
}
unsafe extern "C" {
    #[doc = " @brief  Adds a display meta to the appropriate frame meta.\n\n You must acquire a display meta with nvds_)acquire_display_meta_from_pool()\n and fill it with display metadata before you can add it to the frame meta.\n\n @param[in] frame_meta    A pointer to frame meta to which @a display_meta\n                          is to be added.\n @param[in] display_meta  A pointer to the display meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_display_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a display meta from the frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which\n                          @a display_meta is to be removed.\n @param[in] display_meta  A pointer to the display meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_display_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Acquires a label info meta from a batch meta's label info meta pool.\n\n You must acquire a label info meta before you can fill it and add it to a\n classifier meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a label info meta.\n\n @return  The label info meta acquired from the batch meta's\n  label info meta pool."]
    pub fn nvds_acquire_label_info_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsLabelInfo;
}
unsafe extern "C" {
    #[doc = " Adds a label info meta to a classifier meta.\n\n @param[in] classifier_meta   A pointer to the classifier meta to which\n                              @a label_info_meta is to be added.\n @param[in] label_info_meta   A pointer to the label info meta to be added\n                              to @a classifier_meta."]
    pub fn nvds_add_label_info_meta_to_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
unsafe extern "C" {
    #[doc = " Removes a label info meta from the classifier meta to which it is attached.\n\n @param[in] classifier_meta   A pointer to the classifier meta from which\n                              @a label_info_meta is to be removed.\n @param[in] label_info_meta   A pointer to the label info meta to be removed\n                              from @a classifier_meta."]
    pub fn nvds_remove_label_info_meta_from_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
unsafe extern "C" {
    #[doc = " Add a user meta to a batch meta.\n\n @param[in] batch_meta    A pointer to batch meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Add a user meta to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Add a user meta user to an roi meta.\n\n @param[in] roi_meta      A pointer to the roi meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to the user meta to be added to\n                          @a roi_meta."]
    pub fn nvds_add_user_meta_to_roi(roi_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
unsafe extern "C" {
    #[doc = " Add a user meta user to an object meta.\n\n @param[in] obj_meta      A pointer to the object meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to the user meta to be added to\n                          @a obj_meta."]
    pub fn nvds_add_user_meta_to_obj(obj_meta: *mut NvDsObjectMeta, user_meta: *mut NvDsUserMeta);
}
unsafe extern "C" {
    #[doc = " @brief  Acquires a user meta from a batch meta's user meta pool.\n\n You must acquire a user meta before you can fill it with user metdata and\n add it to a batch, frame, or object meta (call nvds_add_user_data_to_batch(),\n  nvds_add_user_data_to_frame(), or nvds_add_user_data_to_obj()).\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a user meta."]
    pub fn nvds_acquire_user_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsUserMeta;
}
unsafe extern "C" {
    #[doc = " Removes a user meta from a batch meta to which it is attached.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a batch_meta.\n\n returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a user meta from a frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a user meta from an roi meta to which it is attached.\n\n @param[in] roi_meta      A pointer to the roi meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user to be removed from\n                          @a roi_meta."]
    pub fn nvds_remove_user_meta_from_roi(obj_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
unsafe extern "C" {
    #[doc = " Removes a user meta from an object meta to which it is attached.\n\n @param[in] obj_meta      A pointer to the object meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user to be removed from\n                          @a obj_meta."]
    pub fn nvds_remove_user_meta_from_object(
        obj_meta: *mut NvDsObjectMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " A debugging function; prints current metadata information available after\n inference. This function should be called after inference.\n\n @param[in] batch_meta    A pointer to a batch meta from which to\n                          print information.\n @return"]
    pub fn nvds_get_current_metadata_info(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another.\n\n @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL.\n\n @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
unsafe extern "C" {
    #[doc = " Releases metadata from a batch meta.\n\n @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list.\n\n @param[in] frame_meta_list   A pointer to a list of pointers to frame metas.\n @param[in] index             The index of the frame meta to be returned.\n\n @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsFrameMeta;
}
unsafe extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta.\n\n @param[in] batch_meta    A pointer to the batch whose frame meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all the object metadata attached to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose object meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the object meta list to be cleared."]
    pub fn nvds_clear_obj_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsObjectMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an object meta.\n\n @param[in] obj_meta A pointer to @ref NvDsObjectMeta from which @a\n            NvDsClassifierMetaList needs to be cleared\n @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to\n            be cleared"]
    pub fn nvds_clear_classifier_meta_list(
        obj_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the label info metadata attached to a classifier meta.\n\n @param[in] classifier_meta   A pointer to the classifier meta whose\n                              label info meta list is to be cleared.\n @param[in] meta_list         A pointer to the label info meta list to be\n                              cleared."]
    pub fn nvds_clear_label_info_meta_list(
        classifier_meta: *mut NvDsClassifierMeta,
        meta_list: *mut NvDsLabelInfoList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the display metadata attached to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose display meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the display meta list to be cleared."]
    pub fn nvds_clear_display_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDisplayMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the user metadata attached to the batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be\n            cleared"]
    pub fn nvds_clear_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the user metadata attached to the frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_frame_user_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the user metadata attached to an object meta.\n\n @param[in] object_meta   A pointer to the object meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_obj_user_meta_list(
        object_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the metadata elements attached to a metadata list.\n\n @param[in] batch_meta    A pointer to a batch meta.\n @param[in] meta_list     A pointer to meta list to be cleared.\n @param[in] meta_pool     A pointer to the meta pool that contains\n                          @a meta_list.\n @return  A pointer to the updated meta list."]
    pub fn nvds_clear_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsMetaList,
        meta_pool: *mut NvDsMetaPool,
    ) -> *mut NvDsMetaList;
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta.\n\n @param[in] src_frame_meta    A pointer to the source frame meta.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_meta(
        src_frame_meta: *mut NvDsFrameMeta,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of an object meta to another object meta.\n\n @param[in] src_object_meta   A pointer to the source object meta.\n @param[in] dst_object_meta   A pointer to the destination object meta."]
    pub fn nvds_copy_obj_meta(
        src_object_meta: *mut NvDsObjectMeta,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a classifier meta to another classifier meta.\n\n @param[in] src_classifier_meta   A pointer to the source classifier meta.\n @param[in] dst_classifier_meta A pointer to the destination classifier meta."]
    pub fn nvds_copy_classifier_meta(
        src_classifier_meta: *mut NvDsClassifierMeta,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a label info meta to another label info meta.\n\n @param[in] src_label_info    A pointer to the source label info meta.\n @param[in] dst_label_info    A pointer to the destination label info meta."]
    pub fn nvds_copy_label_info_meta(
        src_label_info: *mut NvDsLabelInfo,
        dst_label_info: *mut NvDsLabelInfo,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a display meta to another display meta.\n\n @param[in] src_display_meta  A pointer to the source display meta.\n @param[in] dst_display_meta  A pointer to destination display meta."]
    pub fn nvds_copy_display_meta(
        src_display_meta: *mut NvDsDisplayMeta,
        dst_display_meta: *mut NvDsDisplayMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list\n in a specified batch meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified frame meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified object meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_object_meta       A pointer to the destination object meta."]
    pub fn nvds_copy_obj_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source display meta list to the\n  display meta list in a specified frame meta.\n\n @param[in] src_display_meta_list A pointer to the source display meta list.\n @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_display_meta_list(
        src_display_meta_list: *mut NvDisplayMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list\n  in a specified batch meta.\n\n @param[in] src_frame_meta_list   A pointer to the source frame meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source object meta list to the\n  object meta list in a specified frame meta.\n\n @param[in] src_obj_meta_list A pointer to the source object meta list.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_obj_meta_list(
        src_obj_meta_list: *mut NvDsObjectMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the\n  classifier meta list in a specified object meta.\n\n @param[in] src_classifier_meta_list  A pointer to the source\n                                      classifier meta list.\n @param[in] dst_object_meta           A pointer to the destination\n                                      object meta."]
    pub fn nvds_copy_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source label info meta list to the\n  label info meta list in a specified classifier meta.\n\n @param[in] src_label_info_list   A pointer to the source\n                                  label info meta list.\n @param[in] dst_classifier_meta   A pointer to the destination\n                                  classifier meta."]
    pub fn nvds_copy_label_info_list(
        src_label_info_list: *mut NvDsLabelInfoList,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " Generates a unique user metadata type from a specified string describing\n user-specific metadata.\n\n @param[in] meta_descriptor   A pointer to a string describing user-specific\n                              metadata. The string must be in the format\n                              @a ORG_NAME.COMPONENT_NAME.METADATA_DESCRIPTION,\n                              e.g. @c NVIDIA.NVINFER.TENSOR_METADATA."]
    pub fn nvds_get_user_meta_type(meta_descriptor: *mut gchar) -> NvDsMetaType;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const NvBufAudioFormat_NVBUF_AUDIO_INVALID_FORMAT: NvBufAudioFormat = 0;
pub const NvBufAudioFormat_NVBUF_AUDIO_S8: NvBufAudioFormat = 1;
pub const NvBufAudioFormat_NVBUF_AUDIO_U8: NvBufAudioFormat = 2;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16LE: NvBufAudioFormat = 3;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16BE: NvBufAudioFormat = 4;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16LE: NvBufAudioFormat = 5;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16BE: NvBufAudioFormat = 6;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32LE: NvBufAudioFormat = 7;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32BE: NvBufAudioFormat = 8;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32LE: NvBufAudioFormat = 9;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32BE: NvBufAudioFormat = 10;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32LE: NvBufAudioFormat = 11;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32BE: NvBufAudioFormat = 12;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32LE: NvBufAudioFormat = 13;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32BE: NvBufAudioFormat = 14;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24LE: NvBufAudioFormat = 15;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24BE: NvBufAudioFormat = 16;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24LE: NvBufAudioFormat = 17;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24BE: NvBufAudioFormat = 18;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20LE: NvBufAudioFormat = 19;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20BE: NvBufAudioFormat = 20;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20LE: NvBufAudioFormat = 21;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20BE: NvBufAudioFormat = 22;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18LE: NvBufAudioFormat = 23;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18BE: NvBufAudioFormat = 24;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18LE: NvBufAudioFormat = 25;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18BE: NvBufAudioFormat = 26;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32LE: NvBufAudioFormat = 27;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32BE: NvBufAudioFormat = 28;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64LE: NvBufAudioFormat = 29;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64BE: NvBufAudioFormat = 30;
#[doc = " Specifies audio formats"]
pub type NvBufAudioFormat = ::std::os::raw::c_uint;
pub const NvBufAudioLayout_NVBUF_AUDIO_INVALID_LAYOUT: NvBufAudioLayout = 0;
#[doc = "< audio sample from each channel shall be interleaved LRLRLRLR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_INTERLEAVED: NvBufAudioLayout = 1;
#[doc = "< audio sample from each channel shall be interleaved ; LLLLLLLLRRRRRRRR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_NON_INTERLEAVED: NvBufAudioLayout = 2;
#[doc = " Specifies audio data layout in memory"]
pub type NvBufAudioLayout = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufAudioParams {
    pub layout: NvBufAudioLayout,
    pub format: NvBufAudioFormat,
    #[doc = "< Bytes per frame; the size of a frame;\n size of one sample * @channels"]
    pub bpf: u32,
    #[doc = "< Number of audio channels"]
    pub channels: u32,
    #[doc = "< audio sample rate in samples per second"]
    pub rate: u32,
    pub dataSize: u32,
    pub dataPtr: *mut ::std::os::raw::c_void,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\n in the batch."]
    pub padId: u32,
    #[doc = " source ID of this buffer;\n This is w.r.t the multisrc DeepStream usecases"]
    pub sourceId: u32,
    #[doc = " NTP Timestamp of this audio buffer"]
    pub ntpTimestamp: u64,
    #[doc = " Buffer PTS of this audio buffer"]
    pub bufPts: u64,
    #[doc = " duration of this audio buffer"]
    pub duration: u64,
    pub reserved: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvBufAudioParams"][::std::mem::size_of::<NvBufAudioParams>() - 80usize];
    ["Alignment of NvBufAudioParams"][::std::mem::align_of::<NvBufAudioParams>() - 8usize];
    ["Offset of field: NvBufAudioParams::layout"]
        [::std::mem::offset_of!(NvBufAudioParams, layout) - 0usize];
    ["Offset of field: NvBufAudioParams::format"]
        [::std::mem::offset_of!(NvBufAudioParams, format) - 4usize];
    ["Offset of field: NvBufAudioParams::bpf"]
        [::std::mem::offset_of!(NvBufAudioParams, bpf) - 8usize];
    ["Offset of field: NvBufAudioParams::channels"]
        [::std::mem::offset_of!(NvBufAudioParams, channels) - 12usize];
    ["Offset of field: NvBufAudioParams::rate"]
        [::std::mem::offset_of!(NvBufAudioParams, rate) - 16usize];
    ["Offset of field: NvBufAudioParams::dataSize"]
        [::std::mem::offset_of!(NvBufAudioParams, dataSize) - 20usize];
    ["Offset of field: NvBufAudioParams::dataPtr"]
        [::std::mem::offset_of!(NvBufAudioParams, dataPtr) - 24usize];
    ["Offset of field: NvBufAudioParams::padId"]
        [::std::mem::offset_of!(NvBufAudioParams, padId) - 32usize];
    ["Offset of field: NvBufAudioParams::sourceId"]
        [::std::mem::offset_of!(NvBufAudioParams, sourceId) - 36usize];
    ["Offset of field: NvBufAudioParams::ntpTimestamp"]
        [::std::mem::offset_of!(NvBufAudioParams, ntpTimestamp) - 40usize];
    ["Offset of field: NvBufAudioParams::bufPts"]
        [::std::mem::offset_of!(NvBufAudioParams, bufPts) - 48usize];
    ["Offset of field: NvBufAudioParams::duration"]
        [::std::mem::offset_of!(NvBufAudioParams, duration) - 56usize];
    ["Offset of field: NvBufAudioParams::reserved"]
        [::std::mem::offset_of!(NvBufAudioParams, reserved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufAudio {
    #[doc = " The size of this NvBufAudio batch"]
    pub numFilled: u32,
    #[doc = " The size of this NvBufAudio batch"]
    pub batchSize: u32,
    #[doc = " isContiguous is true when\n the dataPtr in audioBuffers[] array is\n contiguous with the previous and following entry\n in the array"]
    pub isContiguous: bool,
    #[doc = " Array of #batchSize audio bufffers"]
    pub audioBuffers: *mut NvBufAudioParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvBufAudio"][::std::mem::size_of::<NvBufAudio>() - 24usize];
    ["Alignment of NvBufAudio"][::std::mem::align_of::<NvBufAudio>() - 8usize];
    ["Offset of field: NvBufAudio::numFilled"]
        [::std::mem::offset_of!(NvBufAudio, numFilled) - 0usize];
    ["Offset of field: NvBufAudio::batchSize"]
        [::std::mem::offset_of!(NvBufAudio, batchSize) - 4usize];
    ["Offset of field: NvBufAudio::isContiguous"]
        [::std::mem::offset_of!(NvBufAudio, isContiguous) - 8usize];
    ["Offset of field: NvBufAudio::audioBuffers"]
        [::std::mem::offset_of!(NvBufAudio, audioBuffers) - 16usize];
};
#[doc = " Holds metadata for a audio frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsAudioFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID.\nIt need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of samples in the frame"]
    pub num_samples_per_frame: gint,
    pub sample_rate: guint,
    pub num_channels: guint,
    pub format: NvBufAudioFormat,
    pub layout: NvBufAudioLayout,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds the index of the last object class inferred by the primary\ndetector/classifier."]
    pub class_id: gint,
    #[doc = " Hold confidence for last event detected (last NvDsClassifierMeta)"]
    pub confidence: gfloat,
    #[doc = " Holds a string describing the class of the detected event."]
    pub class_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta\nin use for the frame."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta\nin use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsAudioFrameMeta"][::std::mem::size_of::<_NvDsAudioFrameMeta>() - 320usize];
    ["Alignment of _NvDsAudioFrameMeta"][::std::mem::align_of::<_NvDsAudioFrameMeta>() - 8usize];
    ["Offset of field: _NvDsAudioFrameMeta::base_meta"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, base_meta) - 0usize];
    ["Offset of field: _NvDsAudioFrameMeta::pad_index"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, pad_index) - 40usize];
    ["Offset of field: _NvDsAudioFrameMeta::batch_id"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, batch_id) - 44usize];
    ["Offset of field: _NvDsAudioFrameMeta::frame_num"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, frame_num) - 48usize];
    ["Offset of field: _NvDsAudioFrameMeta::buf_pts"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, buf_pts) - 56usize];
    ["Offset of field: _NvDsAudioFrameMeta::ntp_timestamp"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, ntp_timestamp) - 64usize];
    ["Offset of field: _NvDsAudioFrameMeta::source_id"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, source_id) - 72usize];
    ["Offset of field: _NvDsAudioFrameMeta::num_samples_per_frame"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, num_samples_per_frame) - 76usize];
    ["Offset of field: _NvDsAudioFrameMeta::sample_rate"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, sample_rate) - 80usize];
    ["Offset of field: _NvDsAudioFrameMeta::num_channels"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, num_channels) - 84usize];
    ["Offset of field: _NvDsAudioFrameMeta::format"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, format) - 88usize];
    ["Offset of field: _NvDsAudioFrameMeta::layout"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, layout) - 92usize];
    ["Offset of field: _NvDsAudioFrameMeta::bInferDone"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, bInferDone) - 96usize];
    ["Offset of field: _NvDsAudioFrameMeta::class_id"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, class_id) - 100usize];
    ["Offset of field: _NvDsAudioFrameMeta::confidence"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, confidence) - 104usize];
    ["Offset of field: _NvDsAudioFrameMeta::class_label"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, class_label) - 108usize];
    ["Offset of field: _NvDsAudioFrameMeta::classifier_meta_list"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, classifier_meta_list) - 240usize];
    ["Offset of field: _NvDsAudioFrameMeta::frame_user_meta_list"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, frame_user_meta_list) - 248usize];
    ["Offset of field: _NvDsAudioFrameMeta::misc_frame_info"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, misc_frame_info) - 256usize];
    ["Offset of field: _NvDsAudioFrameMeta::reserved"]
        [::std::mem::offset_of!(_NvDsAudioFrameMeta, reserved) - 288usize];
};
#[doc = " Holds metadata for a audio frame in a batch."]
pub type NvDsAudioFrameMeta = _NvDsAudioFrameMeta;
unsafe extern "C" {
    #[doc = " Creates a batch metadata structure for a audio batch of specified size.\n\n @param[in] max_batch_size    The maximum number of frames in the batch.\n @ return  A pointer to the created structure."]
    pub fn nvds_create_audio_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
unsafe extern "C" {
    #[doc = " Destroys a batch metadata structure.\n\n @param[in] batch_meta    A pointer to audio batch metadata structure\n                          to be destroyed.\n @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_audio_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief  Acquires a audio frame meta from a batch's audio frame meta pool.\n\n You must acquire a audio frame meta before you can fill it with audio frame metadata.\n\n @param[in] batch_meta    A pointer to batch meta from which to acquire\n                          a audio frame meta.\n\n @return  A pointer to the acquired audio frame meta."]
    pub fn nvds_acquire_audio_frame_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsAudioFrameMeta;
}
unsafe extern "C" {
    #[doc = " Adds a audio frame meta to a batch meta.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta to which\n                          @a frame_meta is to be added.\n @param[in] frame_meta    A pointer to a frame meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_audio_frame_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a audio frame meta from a batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta\n                          is to be removed.\n @param[in] frame_meta    A pointer to the frame meta to be removed from\n                          @a batch_meta."]
    pub fn nvds_remove_audio_frame_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Adds a classifier meta the audio frame meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the audio frame metadata.\n\n @param[in] frame_meta        A pointer to the frame meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a classifier meta from the audio frame meta to which it is attached.\n\n @param[in] frame_meta          A pointer to the frame meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a frame_meta."]
    pub fn nvds_remove_classifier_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
unsafe extern "C" {
    #[doc = " Add a user meta to a audio batch meta.\n\n @param[in] batch_meta    A pointer to batch meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Add a user meta to a audio frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a user meta from a audio batch meta to which it is attached.\n\n @param[in] batch_meta    A pointer to the audio batch meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a batch_meta.\n\n returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " Removes a user meta from a audio frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another.\n\n @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL.\n\n @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_audio_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
unsafe extern "C" {
    #[doc = " Releases metadata from a batch meta.\n\n @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_audio_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list.\n\n @param[in] frame_meta_list   A pointer to a list of pointers to frame metas.\n @param[in] index             The index of the frame meta to be returned.\n\n @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_audio_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsAudioFrameMeta;
}
unsafe extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta.\n\n @param[in] batch_meta    A pointer to the batch whose frame meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_audio_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an audio frame meta.\n\n @param[in] frame_meta A pointer to @ref NvDsAudioFrameMeta from which @a\n            NvDsClassifierMetaList needs to be cleared\n @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to\n            be cleared"]
    pub fn nvds_clear_audio_classifier_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio batch meta.\n\n @param[in] batch_meta    A pointer to the audio batch meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be\n            cleared"]
    pub fn nvds_clear_audio_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
unsafe extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio frame meta.\n\n @param[in] frame_meta    A pointer to the audio frame meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_audio_frame_user_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list\n in a specified audio batch meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta.\n\n @param[in] src_frame_meta    A pointer to the source frame meta.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_audio_frame_meta(
        src_frame_meta: *mut NvDsAudioFrameMeta,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified audio frame meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_frame_meta        A pointer to the destination audio frame meta."]
    pub fn nvds_copy_audio_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list\n  in a specified batch meta.\n\n @param[in] src_frame_meta_list   A pointer to the source frame meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
unsafe extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the\n  classifier meta list in a specified object meta.\n\n @param[in] src_classifier_meta_list  A pointer to the source\n                                      classifier meta list.\n @param[in] dst_frame_meta           A pointer to the destination\n                                      audio frame meta."]
    pub fn nvds_copy_audio_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
#[doc = " Holds information about latency of the given subcomponent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaSubCompLatency {
    #[doc = " Holds the subcomponent names."]
    pub sub_comp_name: [gchar; 64usize],
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the component."]
    pub in_system_timestamp: gdouble,
    #[doc = " Holds the system timestamp of the buffer when it leaves\nat the output of the component."]
    pub out_system_timestamp: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsMetaSubCompLatency"][::std::mem::size_of::<_NvDsMetaSubCompLatency>() - 80usize];
    ["Alignment of _NvDsMetaSubCompLatency"]
        [::std::mem::align_of::<_NvDsMetaSubCompLatency>() - 8usize];
    ["Offset of field: _NvDsMetaSubCompLatency::sub_comp_name"]
        [::std::mem::offset_of!(_NvDsMetaSubCompLatency, sub_comp_name) - 0usize];
    ["Offset of field: _NvDsMetaSubCompLatency::in_system_timestamp"]
        [::std::mem::offset_of!(_NvDsMetaSubCompLatency, in_system_timestamp) - 64usize];
    ["Offset of field: _NvDsMetaSubCompLatency::out_system_timestamp"]
        [::std::mem::offset_of!(_NvDsMetaSubCompLatency, out_system_timestamp) - 72usize];
};
#[doc = " Holds information about latency of the given subcomponent"]
pub type NvDsMetaSubCompLatency = _NvDsMetaSubCompLatency;
#[doc = " Holds information about latency of the given component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaCompLatency {
    #[doc = " Holds the name of the component for which latency is measured."]
    pub component_name: [gchar; 64usize],
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the component."]
    pub in_system_timestamp: gdouble,
    #[doc = " Holds the system timestamp of buffer when it\nis sent to the downstream component."]
    pub out_system_timestamp: gdouble,
    #[doc = " Holds the source ID of the component, e.g. the camera ID."]
    pub source_id: guint,
    #[doc = " Holds the current frame number for which latency is measured."]
    pub frame_num: guint,
    #[doc = " Holds the pad or port index of the stream muxer for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds latency information of subcomponent in an array"]
    pub sub_comp_latencies: [NvDsMetaSubCompLatency; 16usize],
    #[doc = " Holds the number of subcomponents for the given component"]
    pub num_sub_comps: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsMetaCompLatency"][::std::mem::size_of::<_NvDsMetaCompLatency>() - 1384usize];
    ["Alignment of _NvDsMetaCompLatency"][::std::mem::align_of::<_NvDsMetaCompLatency>() - 8usize];
    ["Offset of field: _NvDsMetaCompLatency::component_name"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, component_name) - 0usize];
    ["Offset of field: _NvDsMetaCompLatency::in_system_timestamp"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, in_system_timestamp) - 64usize];
    ["Offset of field: _NvDsMetaCompLatency::out_system_timestamp"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, out_system_timestamp) - 72usize];
    ["Offset of field: _NvDsMetaCompLatency::source_id"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, source_id) - 80usize];
    ["Offset of field: _NvDsMetaCompLatency::frame_num"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, frame_num) - 84usize];
    ["Offset of field: _NvDsMetaCompLatency::pad_index"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, pad_index) - 88usize];
    ["Offset of field: _NvDsMetaCompLatency::sub_comp_latencies"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, sub_comp_latencies) - 96usize];
    ["Offset of field: _NvDsMetaCompLatency::num_sub_comps"]
        [::std::mem::offset_of!(_NvDsMetaCompLatency, num_sub_comps) - 1376usize];
};
#[doc = " Holds information about latency of the given component"]
pub type NvDsMetaCompLatency = _NvDsMetaCompLatency;
#[doc = " Holds information about the latency of a given frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsFrameLatencyInfo {
    #[doc = " Holds the source ID of the component, e.g. the camera ID."]
    pub source_id: guint,
    #[doc = " Holds the current frame number for which latency is measured."]
    pub frame_num: guint,
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the first component in the pipeline. By default,\nthe decoder is considered to be the first component in the pipeline."]
    pub comp_in_timestamp: gdouble,
    #[doc = " Holds the latency of the frame in milliseconds."]
    pub latency: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsFrameLatencyInfo"][::std::mem::size_of::<NvDsFrameLatencyInfo>() - 24usize];
    ["Alignment of NvDsFrameLatencyInfo"][::std::mem::align_of::<NvDsFrameLatencyInfo>() - 8usize];
    ["Offset of field: NvDsFrameLatencyInfo::source_id"]
        [::std::mem::offset_of!(NvDsFrameLatencyInfo, source_id) - 0usize];
    ["Offset of field: NvDsFrameLatencyInfo::frame_num"]
        [::std::mem::offset_of!(NvDsFrameLatencyInfo, frame_num) - 4usize];
    ["Offset of field: NvDsFrameLatencyInfo::comp_in_timestamp"]
        [::std::mem::offset_of!(NvDsFrameLatencyInfo, comp_in_timestamp) - 8usize];
    ["Offset of field: NvDsFrameLatencyInfo::latency"]
        [::std::mem::offset_of!(NvDsFrameLatencyInfo, latency) - 16usize];
};
unsafe extern "C" {
    #[doc = " Sets the system timestamp when the Gst Buffer arrives as input at the\n component.\n\n @param[in] buffer        A pointer to the arriving Gst Buffer.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n\n @returns  A pointer to a @ref NvDsUserMeta structure which holds an\n          @ref NvDsMetaCompLatency as @a NvDsUserMeta.user_meta_data."]
    pub fn nvds_set_input_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> *mut NvDsUserMeta;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the system timestamp when a Gst Buffer that is pushed\n  to the downstream component.\n\n This is a corresponding function to nvds_set_input_system_timestamp().\n\n @param[in] buffer        A pointer to a Gst Buffer to be pushed\n                          to the downstream component.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n\n @returns  TRUE if the timestamp is attached successfully, or FALSE otherwise."]
    pub fn nvds_set_output_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief  Measures the latency of all frames present in the current batch.\n\n The latency is computed from decoder input up to the point this API is called.\n You can install the probe on either pad of the component and call\n this function to measure the latency.\n\n @param[in]  buf          A pointer to a Gst Buffer to which\n                          @ref NvDsBatchMeta is attached as metadata.\n @param[out] latency_info A pointer to an NvDsFrameLatencyInfo structure\n                          allocated for a batch of this size. The function\n                          fills it with information about all of the sources."]
    pub fn nvds_measure_buffer_latency(
        buf: *mut GstBuffer,
        latency_info: *mut NvDsFrameLatencyInfo,
    ) -> guint;
}
unsafe extern "C" {
    #[doc = " Indicates whether the environment variable\n @c NVDS_ENABLE_LATENCY_MEASUREMENT is exported.\n\n @returns  True if the environment variable is exported, or false otherwise."]
    pub fn nvds_get_enable_latency_measurement() -> gboolean;
}
unsafe extern "C" {
    #[doc = " Adds the reference timestamp metadata for this buffer\n Note: element_name == \"audiodecoder\" and \"nvv4l2decoder\" will be used for\n latency measurement calculations where the timestamp will be used\n by API: nvds_measure_buffer_latency()\n to calculate the latency of buffers downstream relative to the decoder.\n\n @param[in] buffer        A pointer to the arriving Gst Buffer.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n @param[in] frame_id      The id/number of this frame/buffer produced by\n                          the component that produces this buffer.\n"]
    pub fn nvds_add_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
        frame_id: guint,
    );
}
unsafe extern "C" {
    pub fn nvds_meta_api_get_type() -> GType;
}
unsafe extern "C" {
    pub fn nvds_meta_get_info() -> *const GstMetaInfo;
}
pub const GstNvDsMetaType_NVDS_GST_INVALID_META: GstNvDsMetaType = -1;
pub const GstNvDsMetaType_NVDS_BATCH_GST_META: GstNvDsMetaType = 4097;
pub const GstNvDsMetaType_NVDS_DECODER_GST_META: GstNvDsMetaType = 4098;
pub const GstNvDsMetaType_NVDS_DEWARPER_GST_META: GstNvDsMetaType = 4099;
pub const GstNvDsMetaType_NVDS_BUFFER_GST_AS_FRAME_USER_META: GstNvDsMetaType = 4100;
pub const GstNvDsMetaType_NVDS_RESERVED_GST_META: GstNvDsMetaType = 8192;
pub const GstNvDsMetaType_NVDS_GST_META_FORCE32: GstNvDsMetaType = 2147483647;
#[doc = " Defines the type of metadata. NVIDIA-defined %GstNvDsMetaType values are\n in the range from @ref NVDS_BATCH_GST_META to @ref NVDS_START_USER_META."]
pub type GstNvDsMetaType = ::std::os::raw::c_int;
#[doc = " Holds DeepSteam metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMeta {
    pub meta: GstMeta,
    #[doc = " Holds a pointer to metadata. Must be cast to another structure based\non @a meta_type."]
    pub meta_data: gpointer,
    #[doc = " Holds a pointer to user-specific data ."]
    pub user_data: gpointer,
    #[doc = " Holds the type of metadata, one of values of enum @ref GstNvDsMetaType."]
    pub meta_type: gint,
    #[doc = " A callback to be called when @a meta_data is to be copied or transformed\nfrom one buffer to other. @a meta_data and @a user_data are passed\nas arguments."]
    pub copyfunc: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data is to be destroyed.\n@a meta_data and @a user_data are passed as arguments."]
    pub freefunc: NvDsMetaReleaseFunc,
    #[doc = " A callback to be called when @a meta_data is transformed into\n @a NvDsUserMeta.\n This function must be provided by a GStreamer plugin that precedes\n @a Gst-nvstreammux in the DeepStream pipeline.\n Gst-nvstreammux copies @a meta_data to\n user meta data at frame level inside @ref NvDsFrameMeta.\n @a meta_data and @a user_data are passed as arguments.\n\n To retrive the content of @a meta_data, iterate over\n @ref NvDsFrameMetaList. Then search for @a meta_type of @ref NvDsUserMeta\n which the user has attached. (See deepstream-gst-metadata-test source\n code for more details.)\n\n @a meta_data and @a user_data are passed as arguments."]
    pub gst_to_nvds_meta_transform_func: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data transformed into\n @a NvDsUserMeta is to be destroyed.\n This function must be provided by a GStreamer plugin that precedes\n @a Gst-nvstreammux in the DeepStream pipeline."]
    pub gst_to_nvds_meta_release_func: NvDsMetaReleaseFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NvDsMeta"][::std::mem::size_of::<_NvDsMeta>() - 72usize];
    ["Alignment of _NvDsMeta"][::std::mem::align_of::<_NvDsMeta>() - 8usize];
    ["Offset of field: _NvDsMeta::meta"][::std::mem::offset_of!(_NvDsMeta, meta) - 0usize];
    ["Offset of field: _NvDsMeta::meta_data"]
        [::std::mem::offset_of!(_NvDsMeta, meta_data) - 16usize];
    ["Offset of field: _NvDsMeta::user_data"]
        [::std::mem::offset_of!(_NvDsMeta, user_data) - 24usize];
    ["Offset of field: _NvDsMeta::meta_type"]
        [::std::mem::offset_of!(_NvDsMeta, meta_type) - 32usize];
    ["Offset of field: _NvDsMeta::copyfunc"][::std::mem::offset_of!(_NvDsMeta, copyfunc) - 40usize];
    ["Offset of field: _NvDsMeta::freefunc"][::std::mem::offset_of!(_NvDsMeta, freefunc) - 48usize];
    ["Offset of field: _NvDsMeta::gst_to_nvds_meta_transform_func"]
        [::std::mem::offset_of!(_NvDsMeta, gst_to_nvds_meta_transform_func) - 56usize];
    ["Offset of field: _NvDsMeta::gst_to_nvds_meta_release_func"]
        [::std::mem::offset_of!(_NvDsMeta, gst_to_nvds_meta_release_func) - 64usize];
};
#[doc = " Holds DeepSteam metadata."]
pub type NvDsMeta = _NvDsMeta;
unsafe extern "C" {
    #[doc = " Adds %GstMeta of type @ref NvDsMeta to the GstBuffer and sets the @a meta_data\n member of @ref NvDsMeta.\n\n @param[in] buffer    A pointer to a %GstBuffer to which the function adds\n                      metadata.\n @param[in] meta_data A pointer at which the function sets the @a meta_data\n                      member of @ref NvDsMeta.\n @param[in] user_data A pointer to the user-specific data.\n @param[in] copy_func The callback to be called when\n                      NvDsMeta is to be copied. The function is called with\n                      @a meta_data and @a user_data as parameters.\n @param[in] release_func\n                      The callback to be called when\n                      NvDsMeta is to be destroyed. The function is called with\n                      @a meta_data and @a user_data as parameters.\n\n @return  A pointer to the attached NvDsMeta structure if successful,\n  or NULL otherwise."]
    pub fn gst_buffer_add_nvds_meta(
        buffer: *mut GstBuffer,
        meta_data: gpointer,
        user_data: gpointer,
        copy_func: NvDsMetaCopyFunc,
        release_func: NvDsMetaReleaseFunc,
    ) -> *mut NvDsMeta;
}
unsafe extern "C" {
    #[doc = " Gets the @ref NvDsMeta last added to a GstBuffer.\n\n @param[in] buffer    A pointer to the GstBuffer.\n\n @return  A pointer to the last added NvDsMeta structure, or NULL if no\n          %NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_meta(buffer: *mut GstBuffer) -> *mut NvDsMeta;
}
unsafe extern "C" {
    #[doc = " Gets the @ref NvDsBatchMeta added to a GstBuffer.\n\n @param[in] buffer    A pointer to the GstBuffer.\n\n @return  A pointer to the NvDsBatchMeta structure, or NULL if no\n          NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_batch_meta(buffer: *mut GstBuffer) -> *mut NvDsBatchMeta;
}
unsafe extern "C" {
    #[doc = " Copies all GstMeta objects on src_gst_buffer to\n the batched buffer's @ref NvDsBatchMeta\n The GstMeta objects are copied into the user_meta_list\n within @ref NvDsFrameMeta.\n\n Note: the list of plain GstMeta from @src_gst_buffer are copied into\n @frame_meta as a single frame_meta->user_meta\n with NvDsUserMeta->base_meta.meta_type == @ref NVDS_USER_FRAME_META_GST_META.\n The list of N X NvDsMeta from @src_gst_buffer are copied into\n @frame_meta as N X frame_meta->user_meta\n with each NvDsUserMeta->base_meta.meta_type == NvDsMeta->meta_type.\n\n @param[in] src_gst_buffer    A pointer to the GstBuffer.\n                              GstMeta objects in this GstBuffer\n                              will be copied.\n @param[in] batch_meta        A pointer to the @ref NvDsBatchMeta obtained\n                              from nvstreammux plugin. (Note: Works only\n                              for nvstreammux2 (Beta))\n @param[in] frame_meta        A pointer to the @ref NvDsFrameMeta\n                              @ref NvDsFrameMeta (metadata) for\n                              the batched input frame to which GstMeta objects\n                              will be copied as frame @ref NvDsUserMeta.\n"]
    pub fn nvds_copy_gst_meta_to_frame_meta(
        src_gst_buffer: *mut GstBuffer,
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
unsafe extern "C" {
    #[doc = " Copies all GstMeta objects on src_gst_buffer to\n the batched buffer's @ref NvDsBatchMeta\n The GstMeta objects are copied into the user_meta_list\n within @ref NvDsAudioFrameMeta.\n\n Note: the list of plain GstMeta from @src_gst_buffer are copied into\n @frame_meta as a single frame_meta->user_meta\n with NvDsUserMeta->base_meta.meta_type == @ref NVDS_USER_FRAME_META_GST_META.\n The list of N X NvDsMeta from @src_gst_buffer are copied into\n @frame_meta as N X frame_meta->user_meta\n with each NvDsUserMeta->base_meta.meta_type == NvDsMeta->meta_type.\n\n @param[in] src_gst_buffer    A pointer to the GstBuffer.\n                              GstMeta objects in this GstBuffer\n                              will be copied.\n @param[in] batch_meta        A pointer to the @ref NvDsBatchMeta obtained\n                              from nvstreammux plugin. (Note: Works only\n                              for nvstreammux2 (Beta))\n @param[in] frame_meta        A pointer to the @ref NvDsAudioFrameMeta\n                              @ref NvDsAudioFrameMeta (metadata) for\n                              the batched input frame to which GstMeta objects\n                              will be copied as frame @ref NvDsUserMeta.\n"]
    pub fn nvds_copy_gst_meta_to_audio_frame_meta(
        src_gst_buffer: *mut GstBuffer,
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
#[doc = " Holds the dimensions of a layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferDims {
    #[doc = " Holds the number of dimesions in the layer."]
    pub numDims: ::std::os::raw::c_uint,
    #[doc = " Holds the size of the layer in each dimension."]
    pub d: [::std::os::raw::c_uint; 8usize],
    #[doc = " Holds the number of elements in the layer, including all dimensions."]
    pub numElements: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferDims"][::std::mem::size_of::<NvDsInferDims>() - 40usize];
    ["Alignment of NvDsInferDims"][::std::mem::align_of::<NvDsInferDims>() - 4usize];
    ["Offset of field: NvDsInferDims::numDims"]
        [::std::mem::offset_of!(NvDsInferDims, numDims) - 0usize];
    ["Offset of field: NvDsInferDims::d"][::std::mem::offset_of!(NvDsInferDims, d) - 4usize];
    ["Offset of field: NvDsInferDims::numElements"]
        [::std::mem::offset_of!(NvDsInferDims, numElements) - 36usize];
};
#[doc = " Holds the dimensions of a three-dimensional layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferDimsCHW {
    #[doc = " Holds the channel count of the layer."]
    pub c: ::std::os::raw::c_uint,
    #[doc = " Holds the height of the layer."]
    pub h: ::std::os::raw::c_uint,
    #[doc = " Holds the width of the layer."]
    pub w: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferDimsCHW"][::std::mem::size_of::<NvDsInferDimsCHW>() - 12usize];
    ["Alignment of NvDsInferDimsCHW"][::std::mem::align_of::<NvDsInferDimsCHW>() - 4usize];
    ["Offset of field: NvDsInferDimsCHW::c"][::std::mem::offset_of!(NvDsInferDimsCHW, c) - 0usize];
    ["Offset of field: NvDsInferDimsCHW::h"][::std::mem::offset_of!(NvDsInferDimsCHW, h) - 4usize];
    ["Offset of field: NvDsInferDimsCHW::w"][::std::mem::offset_of!(NvDsInferDimsCHW, w) - 8usize];
};
#[doc = " Specifies FP32 format."]
pub const NvDsInferDataType_FLOAT: NvDsInferDataType = 0;
#[doc = " Specifies FP16 format."]
pub const NvDsInferDataType_HALF: NvDsInferDataType = 1;
#[doc = " Specifies INT8 format."]
pub const NvDsInferDataType_INT8: NvDsInferDataType = 2;
#[doc = " Specifies INT32 format."]
pub const NvDsInferDataType_INT32: NvDsInferDataType = 3;
#[doc = " Specifies the data type of a layer."]
pub type NvDsInferDataType = ::std::os::raw::c_uint;
#[doc = " Holds information about one layer in the model."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDsInferLayerInfo {
    #[doc = " Holds the data type of the layer."]
    pub dataType: NvDsInferDataType,
    pub __bindgen_anon_1: NvDsInferLayerInfo__bindgen_ty_1,
    #[doc = " Holds the TensorRT binding index of the layer."]
    pub bindingIndex: ::std::os::raw::c_int,
    #[doc = " Holds the name of the layer."]
    pub layerName: *const ::std::os::raw::c_char,
    #[doc = " Holds a pointer to the buffer for the layer data."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = " Holds a Boolean; true if the layer is an input layer,\nor false if an output layer."]
    pub isInput: ::std::os::raw::c_int,
}
#[doc = " Holds the dimensions of the layer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NvDsInferLayerInfo__bindgen_ty_1 {
    pub inferDims: NvDsInferDims,
    pub dims: NvDsInferDims,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferLayerInfo__bindgen_ty_1"]
        [::std::mem::size_of::<NvDsInferLayerInfo__bindgen_ty_1>() - 40usize];
    ["Alignment of NvDsInferLayerInfo__bindgen_ty_1"]
        [::std::mem::align_of::<NvDsInferLayerInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: NvDsInferLayerInfo__bindgen_ty_1::inferDims"]
        [::std::mem::offset_of!(NvDsInferLayerInfo__bindgen_ty_1, inferDims) - 0usize];
    ["Offset of field: NvDsInferLayerInfo__bindgen_ty_1::dims"]
        [::std::mem::offset_of!(NvDsInferLayerInfo__bindgen_ty_1, dims) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferLayerInfo"][::std::mem::size_of::<NvDsInferLayerInfo>() - 72usize];
    ["Alignment of NvDsInferLayerInfo"][::std::mem::align_of::<NvDsInferLayerInfo>() - 8usize];
    ["Offset of field: NvDsInferLayerInfo::dataType"]
        [::std::mem::offset_of!(NvDsInferLayerInfo, dataType) - 0usize];
    ["Offset of field: NvDsInferLayerInfo::bindingIndex"]
        [::std::mem::offset_of!(NvDsInferLayerInfo, bindingIndex) - 44usize];
    ["Offset of field: NvDsInferLayerInfo::layerName"]
        [::std::mem::offset_of!(NvDsInferLayerInfo, layerName) - 48usize];
    ["Offset of field: NvDsInferLayerInfo::buffer"]
        [::std::mem::offset_of!(NvDsInferLayerInfo, buffer) - 56usize];
    ["Offset of field: NvDsInferLayerInfo::isInput"]
        [::std::mem::offset_of!(NvDsInferLayerInfo, isInput) - 64usize];
};
#[doc = " Holds information about the model network."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferNetworkInfo {
    #[doc = " Holds the input width for the model."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Holds the input height for the model."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " Holds the number of input channels for the model."]
    pub channels: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferNetworkInfo"][::std::mem::size_of::<NvDsInferNetworkInfo>() - 12usize];
    ["Alignment of NvDsInferNetworkInfo"][::std::mem::align_of::<NvDsInferNetworkInfo>() - 4usize];
    ["Offset of field: NvDsInferNetworkInfo::width"]
        [::std::mem::offset_of!(NvDsInferNetworkInfo, width) - 0usize];
    ["Offset of field: NvDsInferNetworkInfo::height"]
        [::std::mem::offset_of!(NvDsInferNetworkInfo, height) - 4usize];
    ["Offset of field: NvDsInferNetworkInfo::channels"]
        [::std::mem::offset_of!(NvDsInferNetworkInfo, channels) - 8usize];
};
#[doc = " Holds information about one parsed object from a detector's output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferObjectDetectionInfo {
    #[doc = " Holds the ID of the class to which the object belongs."]
    pub classId: ::std::os::raw::c_uint,
    #[doc = " Holds the horizontal offset of the bounding box shape for the object."]
    pub left: f32,
    #[doc = " Holds the vertical offset of the object's bounding box."]
    pub top: f32,
    #[doc = " Holds the width of the object's bounding box."]
    pub width: f32,
    #[doc = " Holds the height of the object's bounding box."]
    pub height: f32,
    #[doc = " Holds the object detection confidence level; must in the range\n[0.0,1.0]."]
    pub detectionConfidence: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferObjectDetectionInfo"]
        [::std::mem::size_of::<NvDsInferObjectDetectionInfo>() - 24usize];
    ["Alignment of NvDsInferObjectDetectionInfo"]
        [::std::mem::align_of::<NvDsInferObjectDetectionInfo>() - 4usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::classId"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, classId) - 0usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::left"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, left) - 4usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::top"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, top) - 8usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::width"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, width) - 12usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::height"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, height) - 16usize];
    ["Offset of field: NvDsInferObjectDetectionInfo::detectionConfidence"]
        [::std::mem::offset_of!(NvDsInferObjectDetectionInfo, detectionConfidence) - 20usize];
};
#[doc = " A typedef defined to maintain backward compatibility."]
pub type NvDsInferParseObjectInfo = NvDsInferObjectDetectionInfo;
#[doc = " Holds information about one parsed object and instance mask from a detector's output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferInstanceMaskInfo {
    #[doc = " Holds the ID of the class to which the object belongs."]
    pub classId: ::std::os::raw::c_uint,
    #[doc = " Holds the horizontal offset of the bounding box shape for the object."]
    pub left: f32,
    #[doc = " Holds the vertical offset of the object's bounding box."]
    pub top: f32,
    #[doc = " Holds the width of the object's bounding box."]
    pub width: f32,
    #[doc = " Holds the height of the object's bounding box."]
    pub height: f32,
    #[doc = " Holds the object detection confidence level; must in the range\n[0.0,1.0]."]
    pub detectionConfidence: f32,
    #[doc = " Holds object segment mask"]
    pub mask: *mut f32,
    #[doc = " Holds width of mask"]
    pub mask_width: ::std::os::raw::c_uint,
    #[doc = " Holds height of mask"]
    pub mask_height: ::std::os::raw::c_uint,
    #[doc = " Holds size of mask in bytes"]
    pub mask_size: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferInstanceMaskInfo"]
        [::std::mem::size_of::<NvDsInferInstanceMaskInfo>() - 48usize];
    ["Alignment of NvDsInferInstanceMaskInfo"]
        [::std::mem::align_of::<NvDsInferInstanceMaskInfo>() - 8usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::classId"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, classId) - 0usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::left"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, left) - 4usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::top"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, top) - 8usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::width"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, width) - 12usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::height"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, height) - 16usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::detectionConfidence"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, detectionConfidence) - 20usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::mask"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, mask) - 24usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::mask_width"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, mask_width) - 32usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::mask_height"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, mask_height) - 36usize];
    ["Offset of field: NvDsInferInstanceMaskInfo::mask_size"]
        [::std::mem::offset_of!(NvDsInferInstanceMaskInfo, mask_size) - 40usize];
};
#[doc = " Holds information about one classified attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferAttribute {
    #[doc = " Holds the index of the attribute's label. This index corresponds to\nthe order of output layers specified in the @a outputCoverageLayerNames\nvector during initialization."]
    pub attributeIndex: ::std::os::raw::c_uint,
    #[doc = " Holds the the attribute's output value."]
    pub attributeValue: ::std::os::raw::c_uint,
    #[doc = " Holds the attribute's confidence level."]
    pub attributeConfidence: f32,
    #[doc = " Holds a pointer to a string containing the attribute's label.\nMemory for the string must not be freed. Custom parsing functions must\nallocate strings on heap using strdup or equivalent."]
    pub attributeLabel: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferAttribute"][::std::mem::size_of::<NvDsInferAttribute>() - 24usize];
    ["Alignment of NvDsInferAttribute"][::std::mem::align_of::<NvDsInferAttribute>() - 8usize];
    ["Offset of field: NvDsInferAttribute::attributeIndex"]
        [::std::mem::offset_of!(NvDsInferAttribute, attributeIndex) - 0usize];
    ["Offset of field: NvDsInferAttribute::attributeValue"]
        [::std::mem::offset_of!(NvDsInferAttribute, attributeValue) - 4usize];
    ["Offset of field: NvDsInferAttribute::attributeConfidence"]
        [::std::mem::offset_of!(NvDsInferAttribute, attributeConfidence) - 8usize];
    ["Offset of field: NvDsInferAttribute::attributeLabel"]
        [::std::mem::offset_of!(NvDsInferAttribute, attributeLabel) - 16usize];
};
#[doc = " NvDsInferContext operation succeeded."]
pub const NvDsInferStatus_NVDSINFER_SUCCESS: NvDsInferStatus = 0;
#[doc = " Failed to configure the NvDsInferContext instance possibly due to an\n  erroneous initialization property."]
pub const NvDsInferStatus_NVDSINFER_CONFIG_FAILED: NvDsInferStatus = 1;
#[doc = " Custom Library interface implementation failed."]
pub const NvDsInferStatus_NVDSINFER_CUSTOM_LIB_FAILED: NvDsInferStatus = 2;
#[doc = " Invalid parameters were supplied."]
pub const NvDsInferStatus_NVDSINFER_INVALID_PARAMS: NvDsInferStatus = 3;
#[doc = " Output parsing failed."]
pub const NvDsInferStatus_NVDSINFER_OUTPUT_PARSING_FAILED: NvDsInferStatus = 4;
#[doc = " CUDA error was encountered."]
pub const NvDsInferStatus_NVDSINFER_CUDA_ERROR: NvDsInferStatus = 5;
#[doc = " TensorRT interface failed."]
pub const NvDsInferStatus_NVDSINFER_TENSORRT_ERROR: NvDsInferStatus = 6;
#[doc = " Resource error was encountered."]
pub const NvDsInferStatus_NVDSINFER_RESOURCE_ERROR: NvDsInferStatus = 7;
#[doc = " Triton error was encountered. Renamed TRT-IS to Triton."]
pub const NvDsInferStatus_NVDSINFER_TRITON_ERROR: NvDsInferStatus = 8;
#[doc = " [deprecated]TRT-IS error was encountered"]
pub const NvDsInferStatus_NVDSINFER_TRTIS_ERROR: NvDsInferStatus = 8;
#[doc = " Cuda Memory error was encountered."]
pub const NvDsInferStatus_NVDSINFER_MEM_ERROR: NvDsInferStatus = 9;
#[doc = " Unknown error was encountered."]
pub const NvDsInferStatus_NVDSINFER_UNKNOWN_ERROR: NvDsInferStatus = 10;
#[doc = " Enum for the status codes returned by NvDsInferContext."]
pub type NvDsInferStatus = ::std::os::raw::c_uint;
pub const NvDsInferLogLevel_NVDSINFER_LOG_ERROR: NvDsInferLogLevel = 0;
pub const NvDsInferLogLevel_NVDSINFER_LOG_WARNING: NvDsInferLogLevel = 1;
pub const NvDsInferLogLevel_NVDSINFER_LOG_INFO: NvDsInferLogLevel = 2;
pub const NvDsInferLogLevel_NVDSINFER_LOG_DEBUG: NvDsInferLogLevel = 3;
#[doc = " Enum for the log levels of NvDsInferContext."]
pub type NvDsInferLogLevel = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the string name for the status.\n\n @param[in] status An NvDsInferStatus value.\n @return String name for the status. Memory is owned by the function. Callers\n         should not free the pointer."]
    pub fn NvDsInferStatus2Str(status: NvDsInferStatus) -> *const ::std::os::raw::c_char;
}
#[doc = " Function definition for the inference raw output generated callback of\n Gst-NvInfer plugin.\n\n The callback function can be registered by setting \"raw-output-generated-callback\"\n property on an \"nvinfer\" element instance. Additionally, a pointer to\n user data can be set through the \"raw-output-generated-userdata\" property.\n This pointer will be passed to the raw output generated callback function\n through the userdata parameter.\n\n Refer to the reference deepstream-app sources for a sample implementation\n of the callback.\n\n @param[in]  buf Pointer to the GstBuffer on whose contents inference has been\n             executed. The implementation should assume the buffer to be\n             read-only and should not modify the buffer in any way.\n @param[in]  network_info Network information for the model specified for the\n             nvinfer element instance.\n @param[in]  layers_info Pointer to the array containing information for all\n             bound layers for the inference engine.\n @param[in]  num_layers Number of layers bound for the inference engine i.e.\n             number of elements in the layers_info array.\n @param[in]  batch_size Number of valid input frames in the batch.\n @param[in]  user_data Pointer to the user data set through the\n             \"raw-output-generated-userdata\" property."]
pub type gst_nvinfer_raw_output_generated_callback = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut GstBuffer,
        network_info: *mut NvDsInferNetworkInfo,
        layers_info: *mut NvDsInferLayerInfo,
        num_layers: guint,
        batch_size: guint,
        user_data: gpointer,
    ),
>;
#[doc = " Holds the raw tensor output information for one frame / one object.\n\n The \"nvinfer\" plugins adds this meta when the \"output-tensor-meta\" property\n of the element instance is set to TRUE.\n\n This meta data is added as NvDsUserMeta to the frame_user_meta_list of the\n corresponding frame_meta or object_user_meta_list of the corresponding object\n with the meta_type set to NVDSINFER_TENSOR_OUTPUT_META."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferTensorMeta {
    #[doc = " Unique ID of the gst-nvinfer instance which attached this meta."]
    pub unique_id: guint,
    #[doc = " Number of bound output layers."]
    pub num_output_layers: guint,
    #[doc = " Pointer to the array containing information for the bound output layers.\n Size of the array will be equal to num_output_layers. Pointers inside\n the NvDsInferLayerInfo structure are not valid for this array."]
    pub output_layers_info: *mut NvDsInferLayerInfo,
    #[doc = " Array of pointers to the output host buffers for the batch / frame / object."]
    pub out_buf_ptrs_host: *mut *mut ::std::os::raw::c_void,
    #[doc = " Array of pointers to the output device buffers for the batch / frame / object."]
    pub out_buf_ptrs_dev: *mut *mut ::std::os::raw::c_void,
    #[doc = " GPU device ID on which the device buffers have been allocated."]
    pub gpu_id: gint,
    #[doc = " Private data used for the meta producer's internal memory management."]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Network information for the model specified for the nvinfer element instance."]
    pub network_info: NvDsInferNetworkInfo,
    #[doc = " Whether aspect ratio was maintained while scaling to network resolution"]
    pub maintain_aspect_ratio: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferTensorMeta"][::std::mem::size_of::<NvDsInferTensorMeta>() - 64usize];
    ["Alignment of NvDsInferTensorMeta"][::std::mem::align_of::<NvDsInferTensorMeta>() - 8usize];
    ["Offset of field: NvDsInferTensorMeta::unique_id"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, unique_id) - 0usize];
    ["Offset of field: NvDsInferTensorMeta::num_output_layers"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, num_output_layers) - 4usize];
    ["Offset of field: NvDsInferTensorMeta::output_layers_info"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, output_layers_info) - 8usize];
    ["Offset of field: NvDsInferTensorMeta::out_buf_ptrs_host"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, out_buf_ptrs_host) - 16usize];
    ["Offset of field: NvDsInferTensorMeta::out_buf_ptrs_dev"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, out_buf_ptrs_dev) - 24usize];
    ["Offset of field: NvDsInferTensorMeta::gpu_id"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, gpu_id) - 32usize];
    ["Offset of field: NvDsInferTensorMeta::priv_data"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, priv_data) - 40usize];
    ["Offset of field: NvDsInferTensorMeta::network_info"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, network_info) - 48usize];
    ["Offset of field: NvDsInferTensorMeta::maintain_aspect_ratio"]
        [::std::mem::offset_of!(NvDsInferTensorMeta, maintain_aspect_ratio) - 60usize];
};
#[doc = " Holds the segmentation model output information for one frame / one object.\n\n The \"nvinfer\" plugins adds this meta for segmentation models.\n\n This meta data is added as NvDsUserMeta to the frame_user_meta_list of the\n corresponding frame_meta or object_user_meta_list of the corresponding object\n with the meta_type set to NVDSINFER_SEGMENTATION_META."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferSegmentationMeta {
    #[doc = " Number of classes in the segmentation output."]
    pub classes: guint,
    #[doc = " Width of the segmentation output class map."]
    pub width: guint,
    #[doc = " Height of the segmentation output class map."]
    pub height: guint,
    #[doc = " Pointer to the array for 2D pixel class map. The output for pixel (x,y)\n will be at index (y * width + x)."]
    pub class_map: *mut gint,
    #[doc = " Pointer to the raw array containing the probabilities. The probability for\n class c and pixel (x,y) will be at index (c * width *height + y * width + x)."]
    pub class_probabilities_map: *mut gfloat,
    #[doc = " Private data used for the meta producer's internal memory management."]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Unique ID of the gst-nvinfer instance which attached this meta."]
    pub unique_id: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NvDsInferSegmentationMeta"]
        [::std::mem::size_of::<NvDsInferSegmentationMeta>() - 48usize];
    ["Alignment of NvDsInferSegmentationMeta"]
        [::std::mem::align_of::<NvDsInferSegmentationMeta>() - 8usize];
    ["Offset of field: NvDsInferSegmentationMeta::classes"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, classes) - 0usize];
    ["Offset of field: NvDsInferSegmentationMeta::width"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, width) - 4usize];
    ["Offset of field: NvDsInferSegmentationMeta::height"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, height) - 8usize];
    ["Offset of field: NvDsInferSegmentationMeta::class_map"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, class_map) - 16usize];
    ["Offset of field: NvDsInferSegmentationMeta::class_probabilities_map"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, class_probabilities_map) - 24usize];
    ["Offset of field: NvDsInferSegmentationMeta::priv_data"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, priv_data) - 32usize];
    ["Offset of field: NvDsInferSegmentationMeta::unique_id"]
        [::std::mem::offset_of!(NvDsInferSegmentationMeta, unique_id) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
